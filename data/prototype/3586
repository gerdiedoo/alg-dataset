package U.zf;
import T.TR.li;
public class c {
	private c() {
	}
	public static void R(H[] b) {
		if(b == null)
			throw new ZM();
		H[] C = new H[b.CK];
		R(b, C, 0, b.CK - 1);
	}
	public static void R(e[] b, li U) {
		if(b == null)
			throw new ZM();
		H[] C = new H[b.CK];
		R(b, C, U, 0, b.CK - 1);
	}
	private static void R(H[] a, H[] C, int k6, int Q) {
		if (Q <= k6)
			return;
		int w = k6 + (Q - k6) / 2;
		R(a, C, k6, w);
		R(a, C, w + 1, Q);
		vL(a, C, k6, w, Q);
	}
	private static void R(e[] a, e[] C, li U, int k6,
			int Q) {
		if (Q <= k6)
			return;
		int w = k6 + (Q - k6) / 2;
		R(a, C, U, k6, w);
		R(a, C, U, w + 1, Q);
		vL(a, C, U, k6, w, Q);
	}
	private static void vL(H[] a, H[] C, int k6,
			int w, int Q) {
		for (int Z = k6; Z <= Q; Z++) {
			C[Z] = a[Z];
		}
		int Co = k6, r = w + 1;
		for (int Z = k6; Z <= Q; Z++) {
			if (Co > w)
				a[Z] = C[r++];
			else if (r > Q)
				a[Z] = C[Co++];
			else if (L4(C[r], C[Co]))
				a[Z] = C[r++];
			else
				a[Z] = C[Co++];
		}
	}
	private static void vL(e[] a, e[] C, li U, int k6,
			int w, int Q) {
		for (int Z = k6; Z <= Q; Z++) {
			C[Z] = a[Z];
		}
		int Co = k6, r = w + 1;
		for (int Z = k6; Z <= Q; Z++) {
			if (Co > w)
				a[Z] = C[r++];
			else if (r > Q)
				a[Z] = C[Co++];
			else if (L4(U, C[r], C[Co]))
				a[Z] = C[r++];
			else
				a[Z] = C[Co++];
		}
	}
	private static boolean L4(H Dq, H am) {
		return Dq.x(am) < 0;
	}
	private static boolean L4(li k, e Dq, e am) {
		return k.B(Dq, am) < 0;
	}
	private static void V(e[] a, int Co, int r) {
		e l = a[Co];
		a[Co] = a[r];
		a[r] = l;
	}
	public static void N(H[] b) {
		int s = b.CK;
		for (int Co = 0; Co < s; Co++) {
			System.out.W(b[Co] + ",");
		}
	}
}