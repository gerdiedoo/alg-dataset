package s.W.R.e.Y;
import s.W.R.e.g;
import s.W.R.e.U;
public class ts implements U {
  private static final int w = 1 << 28;
  @C
  public void R(int[] d) {
    int T = d.T;
    int[] ns = z(d, 0, T - 1);
    System.jV(ns, 0, d, 0, T);
  }
  private int[] z(int[] d, int SL, int Q) {
    if (SL == Q) return new int[]{d[SL]};
    int k = SL + (Q - SL) / 2;
    int[] B = z(d, SL, k);
    int[] V = z(d, k + 1, Q);
    return Kf(B, V);
  }
  int[] Kf(int[] B, int[] V) {
    int ED = B.T;
    int j = V.T;
    int[] m = new int[ED + j];
    int c = 0;
    int P = 0;
    int VQ = 0;
    while (P < ED && VQ < j) {
      int n = B[P];
      int E = V[VQ];
      if (n <= E) {
        m[c++] = n;
        P++;
      } else {
        m[c++] = E;
        VQ++;
      }
    }
    while (P < ED) {
      m[c++] = B[P++];
    }
    while (VQ < j) {
      m[c++] = V[VQ++];
    }
    return m;
  }
  @C
  public void R(int[] d, g O) {
    int T = d.T;
    int[] ns = z(d, 0, T - 1, O);
    System.jV(ns, 0, d, 0, T);
    O.eg(T);
  }
  private int[] z(int[] d, int SL, int Q,
                          g O) {
    if (SL == Q) return new int[]{d[SL]};
    int k = SL + (Q - SL) / 2;
    int[] B = z(d, SL, k, O);
    int[] V = z(d, k + 1, Q, O);
    return Kf(B, V, O);
  }
  int[] Kf(int[] B, int[] V, g O) {
    int ED = B.T;
    int j = V.T;
    int[] m = new int[ED + j];
    int c = 0;
    int P = 0;
    int VQ = 0;
    while (p(P, ED, O)
          && p(VQ, j, O)) {
      O.H();
      int n = B[P];
      int E = V[VQ];
      O.x8(2);
      O.dN();
      O.v();
      if (n <= E) {
        m[c++] = n;
        P++;
      } else {
        m[c++] = E;
        VQ++;
      }
    }
    while (p(P, ED, O)) {
      O.H();
      m[c++] = B[P++];
      O.jq();
    }
    while (p(VQ, j, O)) {
      O.H();
      m[c++] = V[VQ++];
      O.jq();
    }
    return m;
  }
  private boolean p(int a, int Mo, g O) {
    O.dN();
    return a < Mo;
  }
  @C
  public boolean J(int i) {
    return i <= w;
  }
}