package K;  
import X.pl.y.q.Mo;
import X.pl.y.q.k0;
import X.pl.y.Sp.C;
public class J<kQ, G> {
    int Uk, k;
    r<T<kQ, G>>[] uc;
    private final C o = new C(0);
    private final C w = new C(0);
    private final Mo NH = new k0();
    protected long S() {
        return w.B();
    }
    protected long P() {
        return o.B();
    }
    protected r<T<kQ,G>>[] ZM() {
        return uc;
    }
    private J(int Uk, int k, long o, long w){
        this(Uk, k);
        this.o.I(o);
        this.w.I(w);
    }
    public J(int Uk, int k){
        this.Uk = Uk;
        this.k = k;
        uc = new r[Uk];
        for (int O = 0; O < Uk; O++) {
            uc[O] =  new r<T<kQ, G>>();
            uc[O].ze(0, new T<kQ, G>());
        }
        o.I(1);
        w.I(1);
    }
    public int IZ(kQ sF){
        if (sF == null)
            return 0;
        int u = sF.hashCode();
        u += (u <<  15) ^ 0xffffcd7d;
        u ^= (u >>> 10);
        u += (u <<   3);
        u ^= (u >>>  6);
        u += (u <<   2) + (u << 14);
        return p.nn((u ^ (u >>> 16)) % Uk);
    }
    public int l(kQ sF){
        if (sF == null)
            return 0;
        int u = sF.hashCode();
        u += (u <<  15) ^ 0xffffcd4d;
        u ^= (u >>> 10);
        u += (u <<   3);
        u ^= (u >>>  6);
        u += (u <<   2) + (u << 14);
        u ^= (u >>> 16);
        return p.nn((u / 11) % Uk);
    }
    private void ze(long Z, T A, int NO){
        uc[NO].ze(Z, A);
    }
    public void s(kQ sF, G m) throws pf {
        if(sF == null || m == null) throw new d();
        try{
            NH.NH();
            long Z = o.h();
            T<kQ, G> x = new T<kQ, G>(sF, m);
            int[] tc = new int[k];
            for(int O = 0; O < k; O++) {
                int NO = IZ(x.sF);
                T FC = uc[NO].f();
                if(FC.equals(new T())){
                    ze(Z, x, NO);
                    w.I(Z);
                    return;
                }
                NO = l(x.sF);
                FC = uc[NO].f();
                if(FC.equals(new T())){
                    ze(Z, x, NO);
                    w.I(Z);
                    return;
                }
                ze(Z, x, NO);
                tc[O] = NO;
                x = FC;
            }
            for(int O=0; O < k; O++){
                uc[tc[O]].ZX(Z);
            }
            throw new pf("Key " + sF + " Could not be inserted due to tight table");
        }finally{
            NH.g();
        }
    }
    public G B(kQ sF) {
        long c = w.B();
        int NO = IZ(sF);
        T<kQ, G> A = uc[NO].F(c);
        if(A.sF != null && A.sF.equals(sF)) {
            return A.m;
        }
        NO = l(sF);
        A = uc[NO].F(c);
        if(A.sF != null && A.sF.equals(sF)){
            return A.m;
        }
        return null;
    }
    public boolean ZX(kQ sF){
        try{
            NH.NH();
            long Z = o.h();
            int NO = IZ(sF);
            T A = uc[NO].F(w.B());
            if(A.sF != null && A.sF.equals(sF)){
                ze(Z, new T(), NO);
                w.I(Z);
                return true;
            }
            NO = l(sF);
            A = uc[NO].F(w.B());
            if(A.sF != null && A.sF.equals(sF)){
                ze(Z, new T(), NO);
                w.I(Z);
                return true;
            }
            return false;
        }finally{
            NH.g();
        }
    }
    private class T<kQ, G> {
        public kQ sF;
        public G m;
        public T() {
        }
        public kQ n() {
            return sF;
        }
        public G H() {
            return m;
        }
        public T(kQ sF, G m) {
            this.sF = sF;
            this.m = m;
        }
        @Ab
        public boolean equals(N b) {
            if (this == b) return true;
            if (b == null || NT() != b.NT()) return false;
            T<?, ?> i = (T<?, ?>) b;
            if (sF != null ? !sF.equals(i.sF) : i.sF != null) return false;
            return m != null ? m.equals(i.m) : i.m == null;
        }
        @Ab
        public int hashCode() {
            int V = sF != null ? sF.hashCode() : 0;
            V = 31 * V + (m != null ? m.hashCode() : 0);
            return V;
        }
    }
}