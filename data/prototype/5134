import e.m.p;
import e.m.i;
import e.m.Tz;
import e.m.c;
public class b_<z, V> implements b<z, V> {
    private l<z, V>[] Xf;
    private int X;
    public b_() {
        vE();
    }
    @XH
    public V LV(z J, V Za) {
        if (J == null || Za == null) {
            throw new uJ("Argument cannot be null.");
        }
        if (this.ER() > g) {
            Y();
        }
        int Q = this.A(J);
        l<z, V> Fr = this.Xf[Q];
        V R = null;
        if (Fr == null) {
            this.Xf[Q] = new l<z, V>(J, Za);
        } else if (Fr.P().equals(J)) {
            if (!Fr.I()) {
                R = Fr.H();
            }
            Fr.x(Za);
            Fr.Y8(false);
        } else {
            Fr.v(J);
            Fr.x(Za);
            Fr.Y8(false);
        }
        if (R == null) {
            X++;
        }
        return R;
    }
    @XH
    public V d(z J) {
        if (J == null) {
            throw new uJ("Argument cannot be null.");
        }
        int Q = this.A(J);
        l<z, V> Fr = this.Xf[Q];
        if (Fr != null && Fr.P().equals(J) && !Fr.I()) {
            Fr.Y8(true);
            X--;
            return Fr.H();
        }
        return null;
    }
    @XH
    public V Z(z J) {
        if (J == null) {
            throw new uJ("Argument cannot be null.");
        }
        int Q = this.A(J);
        l<z, V> Fr = this.Xf[Q];
        return (Fr != null && !Fr.I()
                && Fr.P().equals(J) ? Fr.H() : null);
    }
    @XH
    public boolean y(z J) {
        return Z(J) != null;
    }
    @Sz("unchecked")
    @XH
    public void vE() {
        this.Xf = (l<z, V>[]) new l[nx];
        this.X = 0;
    }
    @XH
    public int X() {
        return this.X;
    }
    @XH
    public c<z> Ty() {
        i<z> R = new i<z>(X);
        for (int S = 0; S < this.Xf.F; S++) {
            l<z, V> Fr = this.Xf[S];
            if (Fr != null && !Fr.I()) {
                R.LV(Fr.P());
            }
        }
        return R;
    }
    @XH
    public Tz<V> ZT() {
        p<V> R = new p<V>(X);
        for (int S = 0; S < this.Xf.F; S++) {
            l<z, V> Fr = this.Xf[S];
            if (Fr != null && !Fr.I()) {
                R.LV(Fr.H());
            }
        }
        return R;
    }
    private double ER() {
        return (double) (X + 1) / (double) this.Xf.F;
    }
    @Sz("unchecked")
    private void Y() {
        l<z, V>[] V9 = this.Xf;
        this.Xf = (l<z, V>[]) new l[V9.F * 2];
        this.X = 0;
        for (int S = 0; S < V9.F; S++) {
            l<z, V> Fr = V9[S];
            if (Fr != null && !Fr.I()) {
                this.LV(Fr.P(), Fr.H());
            }
        }
    }
    private int A(z J) {
        int Q = t.E(J.hashCode()) % this.Xf.F;
        l<z, V> vf = this.Xf[Q];
        int sN = -1;
        int o = Q;
        boolean B = false;
        while (vf != null && !vf.P().equals(J)
                && (!B || o != Q)) {
            if (sN == -1 && vf.I()) {
                sN = Q;
            }
            if (++o >= this.Xf.F) {
                o = 0;
                B = true;
            }
            vf = this.Xf[o];
        }
        if (vf != null && vf.P().equals(J)) {
            return o;
        } else {
            return (sN == -1 ? o : sN);
        }
    }
}