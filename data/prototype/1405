import java.util.Vector;
public class HashTable<K, V>
{
	private static class HashEntry<K, V>
	{
		private K key;
		private Vector<V> value = new Vector<V>();
		private boolean isTombstone = false;
		private HashEntry(K insertKey, V insertValue)
		{
			key = insertKey;
			value.add(insertValue);
		}
		public void makeTombstone()
		{
			isTombstone = true;
		}
	}
	private final int[] SIZES = { 1019, 2027, 4079, 8123, 16267, 32503, 65011,
		130027, 260111, 520279, 1040387, 2080763, 4161539, 8323151, 16646323 };
	private int sizeIdx = 0;
	private HashEntry<K, V>[] table;
	private int numEntries = 0;
	private int numFilledSlots = 0;
	private int numProbes = 0;
	@SuppressWarnings("unchecked")
	public HashTable()
	{
		table = new HashEntry[SIZES[sizeIdx]];
	}
	@SuppressWarnings("unchecked")
	private void increaseCapacity()
	{
		HashEntry<K, V>[] oldTable = table;
		try
		{
			table = new HashEntry[SIZES[++sizeIdx]];
		}
		catch (ArrayIndexOutOfBoundsException e)
		{
			System.out.println("Too many entries in hash table.  Exiting.");
			System.exit(4);
		}
		for (int i = 0; i < oldTable.length; ++i)
		{
			if (oldTable[i] != null && !oldTable[i].isTombstone)
			{
				for (V value : oldTable[i].value)
				{
					insert(oldTable[i].key, value);
				}
			}
		}
	}
	public boolean insert(K key, V value)
	{
		int size = SIZES[sizeIdx];
		int i;
		numProbes = 0;
		if (numFilledSlots >= 0.7 * size)
		{
			increaseCapacity();
			size = SIZES[sizeIdx];
		}
		for (i = 0; i < size; ++i)
		{
			int index = probe(key, i, size);
			if (table[index] == null || table[index].isTombstone)
			{
				table[index] = new HashEntry<K, V>(key, value);
				++numEntries;
				++numFilledSlots;
				numProbes = i;
				return true;
			}
			else if (table[index].key.equals(key) && !table[index].isTombstone)
			{
				table[index].value.add(value);
				++numEntries;
				numProbes = i;
				return true;
			}
		}
		numProbes = i - 1;
		return false;
	}
	private int probe(K key, int i, int size)
	{
		return (hash(key) + ((int) (Math.pow(i, 2) + i) >> 2)) % size;
	}
	public int getNumProbes()
	{
		return numProbes;
	}
	public Vector<V> find(K key)
	{
		int size = SIZES[sizeIdx];
		for (int i = 0; i < size; ++i)
		{
			int index = probe(key, i, size);
			if (table[index] == null)
			{
				return null;
			}
			else if (table[index].key.equals(key) && !table[index].isTombstone)
			{
				return table[index].value;
			}
		}
		return null;
	}
	public boolean delete(K key)
	{
		int size = SIZES[sizeIdx];
		for (int i = 0; i < size; ++i)
		{
			int index = probe(key, i, size);
			if (table[index] == null)
			{
				return false;
			}
			else if (table[index].key.equals(key) && !table[index].isTombstone)
			{
				table[index].isTombstone = true;
				return true;
			}
		}
		return false;
	}
	private int hash(K key)
	{
		String toHash = key.toString();
		int hashValue = 0;
		for (int pos = 0; pos < toHash.length(); ++pos)
		{
			hashValue = (hashValue << 4) + toHash.charAt(pos);
			int highBits = hashValue & 0xF0000000;
			if (highBits != 0)
			{
				hashValue ^= highBits >> 24;
			}
			hashValue &= ~highBits;
		}
		return hashValue;
	}
	public void debug()
	{
		float entriesPerSlot = (float) numEntries / (float) numFilledSlots;
		String result = "Format of display is\n";
		result += "Slot number: data record\n\n";
		result += "Current table size:\t\t\t\t\t\t" + table.length + "\n";
		result += "Number of elements in table:\t\t\t" + numEntries + "\n";
		result += "Number of filled slots in table:\t\t" + numFilledSlots + "\n";
		result += "Average number of entries per slot is:\t" + entriesPerSlot + "\n";
		System.out.println(result);
		for (int i = 0; i < table.length; i++)
		{
			if (table[i] != null && !table[i].isTombstone)
			{
				result = "\n" + i + ":\t" + ((i < 100) ? "\t" : "") + "[" + table[i].key.toString() + ", ";
				for (V entry : table[i].value)
				{
					result += "(" + entry.toString() + "), ";
				}
				result = result.substring(0, result.length() - 2) + "]";
				System.out.println(result);
			}
		}
	}
}