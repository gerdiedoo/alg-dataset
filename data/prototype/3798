package D.gK.k.vV.K;
import N.f.nu;
import n.W.G;
import n.W.j;
public class nQ {
	private static G R = j.Hi(nQ.class);
	public static int[] H(int[] o) {
		R.Hc("Sorting {}", nu.toString(o));
		if(o.e <= 1) {
			return o;
		}
		int y = o.e / 2;
		int wO = o.e - y;
		int[] D5, r;
		D5 = new int[y];
		r = new int[wO];
		R.Hc("Left {} and Right {}", nu.toString(D5), nu.toString(r));
		for (int h = 0; h < y; h++) {
			D5[h] = o[h];
		}
		for (int h = y; h <o.e; h++) {
			r[h - y] = o[h];
		}
		R.Hc("Left {} and Right {}", nu.toString(D5), nu.toString(r));
		D5 = H(D5);
		r = H(r);
		return K(D5, r);
	}
	private static int[] K(int[] D5, int[] r) {
		R.Hc("Merging {} with {}", nu.toString(D5), nu.toString(r));
		int[] L0 = new int[D5.e + r.e];
		int h=0, bM=0, c=0;
		while(bM != D5.e && c != r.e) {
			if(D5[bM] < r[c]) {
				L0[h++] = D5[bM++];
			} else {
				L0[h++] = r[c++];
			}
		}
		while(bM != D5.e) {
			L0[h++] = D5[bM++];
		}
		while(c != r.e) {
			L0[h++] = r[c++];
		}
		R.Hc("Merge L0: {}", nu.toString(L0));
		return L0;
	}
}