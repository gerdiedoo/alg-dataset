import h.k.t;
import h.k.J;
public class O {
	public static <i extends W<i>> void JU(i[] z8) {
		for (int O9 = 1; O9<z8.I; O9++){
			i e = z8[O9];
			int u;
			for (u = O9-1; u>=0 && e.kH(z8[u]) < 0; u-- ){
				z8[u+1] = z8[u];
			}
			z8[u+1] = e;
		}
	}
	public static <i extends W<i>> void n(i[] z8, J d) {
		x(z8, 0, z8.I-1, d);
	}
    private static <i> void x(i[] z8, int QK, int C, J d){
         if (QK < C)
         {
              int P = JF(z8, QK, C, d);
              x(z8, QK, P, d);
              x(z8, P + 1, C, d);
         }
    }
    private static <i> int JF(i[] z8, int QK, int C, J d)
    {
         int f = QK + d.nextInt(C - QK) + 1;
         BG(z8, QK, f);
         return g(z8, QK, C);
    }
    private static <i> int g(i[] z8, int QK, int C)
    {
         i P = z8[QK];
         int O9 = QK - 1;
         int u = C + 1;
         while (true)
         {
              do
                   u--;
              while (((W)z8[u]).kH(P)>0);
              do
                   O9++;
              while (((W)z8[O9]).kH(P)<0);
              if (O9 < u)
                   BG(z8, O9, u);
              else
                   return u;
         }
    }
    private static <i> void BG(i[] z8, int O9, int u)
    {
         i e = z8[O9];
         z8[O9] = z8[u];
         z8[u] = e;
    }
	public static <i extends W<i>> i[] Y(i[] z8) {
		if (z8.I > 1){
			int E = z8.I/2;
			i[] QK = (i[])new W[E];
			i[] C =(i[])new W[z8.I-E];;
			System.y(z8, 0, QK, 0, E);
			System.y(z8, E, C, 0, z8.I-E);
			i[] k2 = Y(QK);
			i[] Ev = Y(C);
			i[] K = G(z8, k2, Ev);
			return K;
		}
		else return z8;
	}
	private static <i> i[] G(i[] z8, i[] QK, i[] C){
		int a = QK.I + C.I;
		int O9=0, V=0, X=0;
		while(O9<a){
			if (V<QK.I && X< C.I){
				if(((W)QK[V]).kH(C[X]) <= 0){
					z8[O9] = QK[V];
					O9++;
					V++;
				}
				else {
					z8[O9] = C[X];
					O9++;
					X++;
				}
			}
			else {
				if (V >= QK.I) {
                    while (X < C.I) {
                        z8[O9] = C[X];
                        O9++;
                        X++;
                    }
                }
                if (X >= C.I) {
                    while (V < QK.I) {
                        z8[O9] = QK[V];
                        V++;
                        O9++;
                    }
                }
			}
		}
		return z8;
	}
	public static int[] c(int[] z8) {
		int g8 = H(z8);
		for (int O9 = 0; O9 < z8.I; O9++){
			z8[O9] = z8[O9] - g8;
		}
		int Qs = Lf(z8);
        int zq = 1;
        for(int O9 =0; O9 < Qs; O9++){
            t<s>[] j = new t[10];
            for(int u=0; u < 10; u++){
                j[u] = new t();
            }
            for(int xc =0; xc < z8.I; xc++){
                int D = (z8[xc]/zq)%10;
                j[D].ha(z8[xc]);
            }
            zq *= 10;
            int X_ =0;         
            for(int U=0; U < 10; U++){
                for(int b: j[U]){
                    z8[X_] = b;
                    X_++;
                }
            }
        }
		for (int O9 = 0; O9 < z8.I; O9++){
			z8[O9] = z8[O9] + g8;
		}
		return z8;
	}
	private static int H(int z8[]){
		int u = 0;
		for (int O9 = 0; O9 < z8.I; O9++){
			if (z8[O9]<u){
				u = z8[O9];
			}
		}
		return u;
	}
	private static int Lf(int z8[]){
		String k1 ="";
		int I = k1.I();
		for (int O9 = 0; O9 < z8.I; O9++){
			if (I < s.toString(z8[O9]).I()){
				k1 = s.toString(z8[O9]);
				I = k1.I();
			}
		}
		return I;
	}
}