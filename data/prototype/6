package com.blogspot.mydailyjava.weaklockfree;
import java.lang.ref.Reference;
import java.lang.ref.ReferenceQueue;
import java.lang.ref.WeakReference;
import java.util.Iterator;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
public abstract class AbstractWeakConcurrentMap<K, V, L> extends ReferenceQueue<K> implements Runnable, Iterable<Map.Entry<K, V>> {
    final ConcurrentMap<WeakKey<K>, V> target;
    protected AbstractWeakConcurrentMap() {
        this(new ConcurrentHashMap<WeakKey<K>, V>());
    }
    protected AbstractWeakConcurrentMap(ConcurrentMap<WeakKey<K>, V> target) {
        this.target = target;
    }
    protected abstract L getLookupKey(K key);
    protected abstract void resetLookupKey(L lookupKey);
    public V get(K key) {
        if (key == null) throw new NullPointerException();
        V value;
        L lookupKey = getLookupKey(key);
        try {
            value = target.get(lookupKey);
        } finally {
            resetLookupKey(lookupKey);
        }
        if (value == null) {
            value = defaultValue(key);
            if (value != null) {
                V previousValue = target.putIfAbsent(new WeakKey<K>(key, this), value);
                if (previousValue != null) {
                    value = previousValue;
                }
            }
        }
        return value;
    }
    public V getIfPresent(K key) {
        if (key == null) throw new NullPointerException();
        L lookupKey = getLookupKey(key);
        try {
            return target.get(lookupKey);
        } finally {
            resetLookupKey(lookupKey);
        }
    }
    public boolean containsKey(K key) {
        if (key == null) throw new NullPointerException();
        L lookupKey = getLookupKey(key);
        try {
            return target.containsKey(lookupKey);
        } finally {
            resetLookupKey(lookupKey);
        }
    }
    public V put(K key, V value) {
        if (key == null || value == null) throw new NullPointerException();
        return target.put(new WeakKey<K>(key, this), value);
    }
    public V putIfAbsent(K key, V value) {
        if (key == null || value == null) throw new NullPointerException();
        V previous;
        L lookupKey = getLookupKey(key);
        try {
            previous = target.get(lookupKey);
        } finally {
            resetLookupKey(lookupKey);
        }
        return previous == null ? target.putIfAbsent(new WeakKey<K>(key, this), value) : previous;
    }
    public V putIfProbablyAbsent(K key, V value) {
        if (key == null || value == null) throw new NullPointerException();
        return target.putIfAbsent(new WeakKey<K>(key, this), value);
    }
    public V remove(K key) {
        if (key == null) throw new NullPointerException();
        L lookupKey = getLookupKey(key);
        try {
            return target.remove(lookupKey);
        } finally {
            resetLookupKey(lookupKey);
        }
    }
    public void clear() {
        target.clear();
    }
    protected V defaultValue(K key) {
        return null;
    }
    public void expungeStaleEntries() {
        Reference<?> reference;
        while ((reference = poll()) != null) {
            target.remove(reference);
        }
    }
    public int approximateSize() {
        return target.size();
    }
    @Override
    public void run() {
        try {
            while (!Thread.interrupted()) {
                target.remove(remove());
            }
        } catch (InterruptedException ignored) {
        }
    }
    @Override
    public Iterator<Map.Entry<K, V>> iterator() {
        return new EntryIterator(target.entrySet().iterator());
    }
    @Override
    public String toString() {
        return target.toString();
    }
    public static final class WeakKey<K> extends WeakReference<K> {
        private final int hashCode;
        WeakKey(K key, ReferenceQueue<? super K> queue) {
            super(key, queue);
            hashCode = System.identityHashCode(key);
        }
        @Override
        public int hashCode() {
            return hashCode;
        }
        @Override
        public boolean equals(Object other) {
            if (other instanceof WeakKey<?>) {
                return ((WeakKey<?>) other).get() == get();
            } else {
                return other.equals(this);
            }
        }
        @Override
        public String toString() {
            return String.valueOf(get());
        }
    }
    private class EntryIterator implements Iterator<Map.Entry<K, V>> {
        private final Iterator<Map.Entry<WeakKey<K>, V>> iterator;
        private Map.Entry<WeakKey<K>, V> nextEntry;
        private K nextKey;
        private EntryIterator(Iterator<Map.Entry<WeakKey<K>, V>> iterator) {
            this.iterator = iterator;
            findNext();
        }
        private void findNext() {
            while (iterator.hasNext()) {
                nextEntry = iterator.next();
                nextKey = nextEntry.getKey().get();
                if (nextKey != null) {
                    return;
                }
            }
            nextEntry = null;
            nextKey = null;
        }
        @Override
        public boolean hasNext() {
            return nextKey != null;
        }
        @Override
        public Map.Entry<K, V> next() {
            if (nextKey == null) {
                throw new NoSuchElementException();
            }
            try {
                return new SimpleEntry(nextKey, nextEntry);
            } finally {
                findNext();
            }
        }
        @Override
        public void remove() {
            throw new UnsupportedOperationException();
        }
    }
    private class SimpleEntry implements Map.Entry<K, V> {
        private final K key;
        final Map.Entry<WeakKey<K>, V> entry;
        private SimpleEntry(K key, Map.Entry<WeakKey<K>, V> entry) {
            this.key = key;
            this.entry = entry;
        }
        @Override
        public K getKey() {
            return key;
        }
        @Override
        public V getValue() {
            return entry.getValue();
        }
        @Override
        public V setValue(V value) {
            if (value == null) throw new NullPointerException();
            return entry.setValue(value);
        }
    }
}