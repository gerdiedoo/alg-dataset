package iJ.l2;
public class up<i, R> implements H<i, R> {
    private int q = 10;
    rT[] J0;
    public up() {
        this.J0 = new rT[q];
    }
    public up(int se) {
        this.J0 = new rT[se];
    }
    @V
    public void n(i y, R F) {
        rT<i, R> w = new rT<i, R>(y, F);
        if (y == null) {
            throw new M("Key " + y + " cannot be null.");
        }
        int D = Bl(y.hashCode());
        if (J0[D] == null) {
            J0[D] = w;
        } else {
            rT<i, R> p = J0[D];
            if (p.Cg().equals(y)) {
                p.v(F);
            } else {
                while (p.o() != null) {
                    p = p.o();
                }
                p.S(w);
            }
        }
    }
    @V
    public R h(i y) {
        if (y == null) {
            throw new M("Key " + y + " cannot be null.");
        }
        int D = Bl(y.hashCode());
        rT<i, R> p = J0[D];
        while (p != null && !y.equals(p.Cg())) {
            p = p.o();
        }
        return p != null ? p.W() : null;
    }
    private int Bl(int hashCode) {
        return hashCode % J0.I;
    }
    @V
    public boolean C(i y) {
        return false;
    }
    private static class rT<i, R> {
        private rT<i, R> Y;
        private final i y;
        private R F;
        public rT(i y, R F) {
            this.y = y;
            this.F = F;
        }
        private R W() {
            return F;
        }
        private void v(R F) {
            this.F = F;
        }
        private i Cg() {
            return y;
        }
        private rT<i, R> o() {
            return Y;
        }
        private void S(rT<i, R> Y) {
            this.Y = Y;
        }
    }
}