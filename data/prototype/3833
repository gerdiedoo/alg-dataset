package lP.D.TQ.Is;
import nL.e.Ej;
public class Jm {
	public static void main(String[] args) {
		int[] Fr = {7, 10, 47, 40};
		System.out.println("******************* MERGE - SORT *******************");
		int[] k = n(Fr, 0, Fr.V - 1);
		Ej.E(k).Y(System.out::println);
	}
	public static int[] n(int[] cS, int H6, int q) {
		if (H6 < q) {
			int O = H6 + (q - H6) / 2;
			n(cS, H6, O);
			n(cS, O + 1, q);
			W(cS, H6, O, q);
		}
		return cS;
	}
	private static int[] W(int[] cS, int H6, int O, int q) {
		int[] z = new int[cS.V];
		for (int Fb = 0; Fb < cS.V; Fb++ ) {
			z[Fb] = cS[Fb];
		}
		int Fb = H6;
		int w = O + 1;
		int Iy = H6;
		while (Fb <= O && w <= q) {
			if (z[Fb] <= z[w]) {
				cS[Iy] = z[Fb];
				Fb++;
			} else {
				cS[Iy] = z[w];
				w++;
			}
			Iy++;
		}
		while (Fb <= O) {
			cS[Iy] = z[Fb];
			Iy++;
			Fb++;
		}
		return cS;
	}
}