package c;
import T.K.Y;
import o.F;
import o.n;
public class c {
	@w("rawtypes")
	private static gz[] z0;
	private static byte[] A;
	private static char[] k;
	private static short[] r;
	private static int[] f;
	private static long[] W9;
	private static float[] Vx;
	private static double[] H;
	public static void p(byte[] U2) {
		A = new byte[U2.u];
		p(U2, 0, U2.u - 1);
		A = null;
	}
	private static void p(byte[] U2, int Ew, int Q) {
		for (int i = 1; i <= Q; i += i) {
			for (int pl = 0; pl <= Q - i; pl += (2 * i)) {
				int B = Tq.gn(pl + (2 * i) - 1, Q);
				I(U2, pl, pl + i - 1, B);
			}
		}
	}
	private static void I(byte[] U2, int Ew, int g, int Q) {
		int pl = Ew;
		int X = g + 1;
		int a = Ew;
		while (pl <= g && X <= Q) {
			if (U2[pl] <= U2[X]) {
				A[a++] = U2[pl++];
			}
			else {
				A[a++] = U2[X++];
			}
		}
		if (pl > g) {
			while (X <= Q) {
				A[a++] = U2[X++];
			}
		} else {
			while (pl <= g) {
				A[a++] = U2[pl++];
			}
		}
		System.Y4(A, Ew, U2, Ew, Q - Ew + 1);
	}
	public static void p(char[] U2) {
		k = new char[U2.u];
		p(U2, 0, U2.u - 1);
		k = null;
	}
	private static void p(char[] U2, int Ew, int Q) {
		for (int i = 1; i <= Q; i += i) {
			for (int pl = 0; pl <= Q - i; pl += (2 * i)) {
				int B = Tq.gn(pl + (2 * i) - 1, Q);
				I(U2, pl, pl + i - 1, B);
			}
		}
	}
	private static void I(char[] U2, int Ew, int g, int Q) {
		int pl = Ew;
		int X = g + 1;
		int a = Ew;
		while (pl <= g && X <= Q) {
			if (U2[pl] <= U2[X]) {
				k[a++] = U2[pl++];
			}
			else {
				k[a++] = U2[X++];
			}
		}
		if (pl > g) {
			while (X <= Q) {
				k[a++] = U2[X++];
			}
		} else {
			while (pl <= g) {
				k[a++] = U2[pl++];
			}
		}
		System.Y4(k, Ew, U2, Ew, Q - Ew + 1);
	}
	public static void p(short[] U2) {
		r = new short[U2.u];
		p(U2, 0, U2.u - 1);
		r = null;
	}
	private static void p(short[] U2, int Ew, int Q) {
		for (int i = 1; i <= Q; i += i) {
			for (int pl = 0; pl <= Q - i; pl += (2 * i)) {
				int B = Tq.gn(pl + (2 * i) - 1, Q);
				I(U2, pl, pl + i - 1, B);
			}
		}
	}
	private static void I(short[] U2, int Ew, int g, int Q) {
		int pl = Ew;
		int X = g + 1;
		int a = Ew;
		while (pl <= g && X <= Q) {
			if (U2[pl] <= U2[X]) {
				r[a++] = U2[pl++];
			}
			else {
				r[a++] = U2[X++];
			}
		}
		if (pl > g) {
			while (X <= Q) {
				r[a++] = U2[X++];
			}
		} else {
			while (pl <= g) {
				r[a++] = U2[pl++];
			}
		}
		System.Y4(r, Ew, U2, Ew, Q - Ew + 1);
	}
	public static void p(int[] U2) {
		f = new int[U2.u];
		p(U2, 0, U2.u - 1);
		f = null;
	}
	private static void p(int[] U2, int Ew, int Q) {
		for (int i = 1; i <= Q; i += i) {
			for (int pl = 0; pl <= Q - i; pl += (2 * i)) {
				int B = Tq.gn(pl + (2 * i) - 1, Q);
				I(U2, pl, pl + i - 1, B);
			}
		}
	}
	private static void I(int[] U2, int Ew, int g, int Q) {
		int pl = Ew;
		int X = g + 1;
		int a = Ew;
		while (pl <= g && X <= Q) {
			if (U2[pl] <= U2[X]) {
				f[a++] = U2[pl++];
			}
			else {
				f[a++] = U2[X++];
			}
		}
		if (pl > g) {
			while (X <= Q) {
				f[a++] = U2[X++];
			}
		} else {
			while (pl <= g) {
				f[a++] = U2[pl++];
			}
		}
		System.Y4(f, Ew, U2, Ew, Q - Ew + 1);
	}
	public static void p(long[] U2) {
		W9 = new long[U2.u];
		p(U2, 0, U2.u - 1);
		W9 = null;
	}
	private static void p(long[] U2, int Ew, int Q) {
		for (int i = 1; i <= Q; i += i) {
			for (int pl = 0; pl <= Q - i; pl += (2 * i)) {
				int B = Tq.gn(pl + (2 * i) - 1, Q);
				I(U2, pl, pl + i - 1, B);
			}
		}
	}
	private static void I(long[] U2, int Ew, int g, int Q) {
		int pl = Ew;
		int X = g + 1;
		int a = Ew;
		while (pl <= g && X <= Q) {
			if (U2[pl] <= U2[X]) {
				W9[a++] = U2[pl++];
			}
			else {
				W9[a++] = U2[X++];
			}
		}
		if (pl > g) {
			while (X <= Q) {
				W9[a++] = U2[X++];
			}
		} else {
			while (pl <= g) {
				W9[a++] = U2[pl++];
			}
		}
		System.Y4(W9, Ew, U2, Ew, Q - Ew + 1);
	}
	public static void p(float[] U2) {
		Vx = new float[U2.u];
		p(U2, 0, U2.u - 1);
		Vx = null;
	}
	private static void p(float[] U2, int Ew, int Q) {
		for (int i = 1; i <= Q; i += i) {
			for (int pl = 0; pl <= Q - i; pl += (2 * i)) {
				int B = Tq.gn(pl + (2 * i) - 1, Q);
				I(U2, pl, pl + i - 1, B);
			}
		}
	}
	private static void I(float[] U2, int Ew, int g, int Q) {
		int pl = Ew;
		int X = g + 1;
		int a = Ew;
		while (pl <= g && X <= Q) {
			if (U2[pl] <= U2[X]) {
				Vx[a++] = U2[pl++];
			}
			else {
				Vx[a++] = U2[X++];
			}
		}
		if (pl > g) {
			while (X <= Q) {
				Vx[a++] = U2[X++];
			}
		} else {
			while (pl <= g) {
				Vx[a++] = U2[pl++];
			}
		}
		System.Y4(Vx, Ew, U2, Ew, Q - Ew + 1);
	}
	public static void p(double[] U2) {
		H = new double[U2.u];
		p(U2, 0, U2.u - 1);
		H = null;
	}
	private static void p(double[] U2, int Ew, int Q) {
		for (int i = 1; i <= Q; i += i) {
			for (int pl = 0; pl <= Q - i; pl += (2 * i)) {
				int B = Tq.gn(pl + (2 * i) - 1, Q);
				I(U2, pl, pl + i - 1, B);
			}
		}
	}
	private static void I(double[] U2, int Ew, int g, int Q) {
		int pl = Ew;
		int X = g + 1;
		int a = Ew;
		while (pl <= g && X <= Q) {
			if (U2[pl] <= U2[X]) {
				H[a++] = U2[pl++];
			}
			else {
				H[a++] = U2[X++];
			}
		}
		if (pl > g) {
			while (X <= Q) {
				H[a++] = U2[X++];
			}
		} else {
			while (pl <= g) {
				H[a++] = U2[pl++];
			}
		}
		System.Y4(H, Ew, U2, Ew, Q - Ew + 1);
	}
	public static void p(j[] U2) {
		p(U2, 0, U2.u - 1);
	}
	private static void p(j[] U2, int Ew, int Q) {
		z0 = new gz[U2.u];
		for (int i = 1; i <= Q; i += i) {
			for (int pl = 0; pl <= Q - i; pl += (2 * i)) {
				int B = Tq.gn(pl + (2 * i) - 1, Q);
				I((gz[])U2, pl, pl + i - 1, B);
			}
		}
		z0 = null;
	}
	@w({ "unchecked", "rawtypes" })
	private static void I(gz[] U2, int Ew, int g, int Q) {
		int pl = Ew;
		int X = g + 1;
		int a = Ew;
		while (pl <= g && X <= Q) {
			if (U2[pl].P1(U2[X]) <= 0) {
				z0[a++] = U2[pl++];
			}
			else {
				z0[a++] =  U2[X++];
			}
		}
		if (pl > g) {
			while (X <= Q) {
				z0[a++] = U2[X++];
			}
		} else {
			while (pl <= g) {
				z0[a++] = U2[pl++];
			}
		}
		System.Y4(z0, Ew, U2, Ew, Q - Ew + 1);
	}
	public static <kA> void p(kA[] U2, Y<? super kA> Z) {
		if(Z == null) {
			p(U2, 0, U2.u - 1);
		}
		else {
			p(U2, 0, U2.u - 1, Z);
		}
	}
	private static <kA> void p(kA[] U2, int Ew, int Q, Y<? super kA> Z) {
		z0 = new gz[U2.u];
		for (int i = 1; i <= Q; i += i) {
			for (int pl = 0; pl <= Q - i; pl += (2 * i)) {
				int B = Tq.gn(pl + (2 * i) - 1, Q);
				I(U2, pl, pl + i - 1, B, Z);
			}
		}
		z0 = null;
	}
	@w({ "rawtypes" })
	private static <kA> void I(kA[] U2, int Ew, int g, int Q , Y<? super kA> Z) {
		int pl = Ew;
		int X = g + 1;
		int a = Ew;
		while (pl <= g && X <= Q) {
			if (Z.M(U2[pl], U2[X]) <= 0) {
				z0[a++] =  (gz) U2[pl++];
			}
			else {
				z0[a++] =  (gz) U2[X++];
			}
		}
		if (pl > g) {
			while (X <= Q) {
				z0[a++] = (gz) U2[X++];
			}
		} else {
			while (pl <= g) {
				z0[a++] = (gz) U2[pl++];
			}
		}
		System.Y4(z0, Ew, U2, Ew, Q - Ew + 1);
	}
	public static void p(byte[] U2, boolean Ur) {
		if(Ur) {
			n0[] s = F.C(U2);
			p(s, n.U());
			F.m(s, U2);
		}
		else {
			p(U2);
		}
	}
	public static void p(char[] U2, boolean Ur) {
		if(Ur) {
			z[] s = F.J(U2);
			p(s, n.U());
			F.v8(s, U2);
		}
		else {
			p(U2);
		}
	}
	public static void p(short[] U2, boolean Ur) {
		if(Ur) {
			x[] s = F.QC(U2);
			p(s, n.U());
			F.Uc(s, U2);
		}
		else {
			p(U2);
		}
	}
	public static void p(int[] U2, boolean Ur) {
		if(Ur) {
			cv[] s = F.y(U2);
			p(s, n.U());
			F.b(s, U2);
		}
		else {
			p(U2);
		}
	}
	public static void p(long[] U2, boolean Ur) {
		if(Ur) {
			su[] s = F.e(U2);
			p(s, n.U());
			F.N(s, U2);
		}
		else {
			p(U2);
		}
	}
	public static void p(float[] U2, boolean Ur) {
		if(Ur) {
			Au[] s = F.tk(U2);
			p(s, n.U());
			F.V(s, U2);
		}
		else {
			p(U2);
		}
	}
	public static void p(double[] U2, boolean Ur) {
		if(Ur) {
			D[] s = F.G(U2);
			p(s, n.U());
			F.d(s, U2);
		}
		else {
			p(U2);
		}
	}
}