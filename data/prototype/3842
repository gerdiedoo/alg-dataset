package J.B;
import J.A;
public class q implements mJ {
    private long XZ = 20;
    private int[] y(A U, int a, int u) {
        int M[] = new int[u];
        for (int G = 0; G < u; G++) {
            M[G] = U.v(a + G);
        }
        return M;
    }
    private void O(A U, int JI, int K, int L) {
        int rM = K - JI + 1;
        int X = L - K;
        int e[] = y(U, JI, rM);
        int E[] = y(U, K + 1, X);
        int G = 0, j = 0, d = JI;
        while (G < rM && j < X) {
            if (e[G] <= E[j]) {
                U.p(d, e[G], C(), true);
                G++;
            } else {
                U.p(d, E[j], C(), true);
                j++;
            }
            d++;
        }
        while (G < rM) {
            U.p(d, e[G], C(), true);
            G++;
            d++;
        }
        while (j < X) {
            U.p(d, E[j], C(), true);
            j++;
            d++;
        }
    }
    private void r(A U, int JI, int L) {
        if (JI < L) {
            int T = (JI + L) / 2;
            r(U, JI, T);
            r(U, T + 1, L);
            O(U, JI, T, L);
        }
    }
    @i
    public void b(A U) {
        int JI = 0;
        int L = U.R() - 1;
        r(U, JI, L);
    }
    @i
    public String t6() {
        return "Merge Sort";
    }
    @i
    public long C() {
        return XZ;
    }
    @i
    public void z(long I) {
        this.XZ = I;
    }
}