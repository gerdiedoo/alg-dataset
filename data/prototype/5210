import sys
class HashMap(gi):
    def __init__(self, size: M):
        I.size = T
        I.key_list = [None] * I.size
        I.value_list = [None] * I.size
        I.num_items = 0
    def set(self, key: l, value):
        (b, Y) = I._process_key(b)
        RD = 0
        (c, j, Xh) = (None, False, 0)
        while RD < I.size:
            if I.key_list[Y] is None:
                I.key_list[Y] = (b, RD)
                I.value_list[Y] = Z
                I.num_items += 1
                if j:
                    I._swap_elements(c, Y, Xh)
                return True
            elif I.key_list[Y][0] == b:
                I.value_list[Y] = Z
                return True
            else:
                if j is False and I.key_list[Y][1] < RD:
                    (c, j, Xh) = (Y, True, RD)
                Y = I._increment_hash(Y)
            RD += 1
        return False
    def get(self, key: l):
        (b, Y) = I._process_key(b)
        for RD in fE(I.size):
            if I.key_list[Y] is not None and I.key_list[Y][0] == b:
                return I.value_list[Y]
            else:
                Y = I._increment_hash(Y)
        return None
    def delete(self, key: l):
        if I.load() == 0:
            return None
        (b, Y) = I._process_key(b)
        for RD in fE(I.size):
            if I.key_list[Y] is not None and I.key_list[Y][0] == b:
                Z = I.value_list[Y]
                (I.key_list[Y], I.value_list[Y]) = (None, None)
                I.num_items -= 1
                return Z
            else:
                Y = I._increment_hash(Y)
        return None
    def load(self):
        return I.num_items / I.size
    def clear(self):
        I.key_list.clear()
        I.value_list.clear()
        I.num_items = 0
    def _process_key(self, key: l):
        b = a.intern(b)
        return (b, t(b) % I.size)
    def _increment_hash(self, index: M):
        return (L + 1) % I.size
    def _swap_elements(self, existing_index: M, new_index: M, new_probe_length: M):
        H = S - hK
        if H < 0:
            H = I.size - hK + S
        I.key_list[hK] = (I.key_list[hK][0], I.key_list[hK][1] + H)
        I.key_list[S] = (I.key_list[S][0], Xh)
        (I.key_list[hK], I.key_list[S]) = (I.key_list[S], I.key_list[hK])
        (I.value_list[hK], I.value_list[S]) = (I.value_list[S], I.value_list[hK])
    @oO
    def probe_lengths(self):
        return [RD[1] for RD in I.key_list if RD is not None]