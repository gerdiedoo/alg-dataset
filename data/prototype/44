package org.joyfulmonster.util.concurrent.internal;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;
import java.util.concurrent.atomic.AtomicReferenceArray;
import java.util.concurrent.locks.ReentrantLock;
class DirectoryImpl extends AtomicReference<AtomicReferenceArray<Bucket>> implements Directory {
    private final ReentrantLock lock;
    private volatile int bucketCount;
    private BucketFactory bucketFactory;
    DirectoryImpl(AtomicReferenceArray<Bucket> buckets) {
        super(buckets);
        lock = new ReentrantLock(true);
        bucketCount = buckets.length();
    }
    public void lock() {
        lock.lock();
    }
    public void unlock() {
        lock.unlock();
    }
    public int getBucketCount() {
        return bucketCount;
    }
    public Bucket getBucket(int hashCode) {
        AtomicReferenceArray<Bucket> dir = get();
        int dirSize = dir.length();
        int dirMask = dirSize - 1;
        int bucketIndex = hashCode & dirMask;
        Bucket bucket = dir.get(bucketIndex);
        return bucket;
    }
    Directory bucketFactory(BucketFactory factory) {
        bucketFactory = factory;
        return this;
    }
    public BucketFactory getBucketFactory() {
        return bucketFactory;
    }
    public int onSplit(Bucket oldBucket, Bucket[] newBuckets) {
        lock();
        try {
            this.bucketCount++;  
            AtomicReferenceArray<Bucket> bucketArray = get();
            int bucketsNumber = bucketArray.length();
            int dirMask = bucketsNumber - 1;
            int globalDepth = Integer.bitCount(dirMask);
            if (globalDepth < newBuckets[0].getLocalDepth()) {
                int newDirSize = bucketsNumber * 2;
                if (newDirSize > ConcurrentElasticHashMapImpl.MAX_BUCKET_COUNT) {
                    throw new IllegalStateException("directory size limit exceeded");
                }
                AtomicReferenceArray<Bucket> newDirectory = new AtomicReferenceArray<Bucket>(newDirSize);
                for (int i = 0; i < bucketsNumber; i++) {
                    newDirectory.set(i, bucketArray.get(i));
                    newDirectory.set(i + bucketsNumber, bucketArray.get(i));
                }
                bucketArray = newDirectory;
                bucketsNumber = newDirSize;
                set(newDirectory);
            } else {
            }
            final int step = 1 << newBuckets[0].getLocalDepth();
            for (int i = newBuckets[1].getBucketIdx(); i < bucketsNumber; i += step) {
                bucketArray.set(i, newBuckets[1]);
            }
            for (int i = newBuckets[0].getBucketIdx(); i < bucketsNumber; i += step) {
                bucketArray.set(i, newBuckets[0]);
            }
        } finally {
            unlock();
        }
        return bucketCount;
    }
    @Override
    public int onMerge(Bucket oldBucket) {
        return 0;
    }
}