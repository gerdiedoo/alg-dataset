package Y;
import S.AN.q;
import S.AN.VK.G;
import xo.C;
import xo.m3;
public class H {
	final static int E = 1 << 13;
	public static void R(byte[] W) {
		new I.w(W, 0, W.Eq - 1).a();
	}
	private static final class I {	
		private static final class w extends G {
			private static final long An = 1L;
			final byte[] W;
			final int N;
			final int zk;
			w(byte[] W, int N, int zk) {
				this.W = W;
				this.N = N;
				this.zk = zk;
			}
			public final void x() {
				if(N >= zk) {
					return;
				}
				int Qp = WH(W, N, zk);
				if(zk - N < E) {
					oH(W, N, Qp - 1);
					oH(W, Qp + 1, zk);
				}
				else {
					w OJ = new w(W, N, Qp - 1);
					w zH = new w(W, Qp + 1, zk);
					OJ.y5();
					zH.x();
					OJ.b();
				}
			}
		}
		private static void oH(byte[] W, int N, int zk) {	
			if(N >= zk) {
				return;
			}
			int Qp = WH(W, N, zk);	
			oH(W, N, Qp - 1);
			oH(W, Qp + 1, zk);
		}
		private static int WH(byte[] W, int OJ, int zH) {
			int N = OJ;
			int zk = zH;
			byte Qp = W[OJ];	
			while(N < zk) {
				while(W[zk] > Qp) --zk;
				while(W[N] <= Qp && N < zk) ++N;
				vr(W, N, zk);
			}
			vr(W, OJ, N);
			return N;
		}
		private static void vr(byte[] W, int i4, int eM) {
			byte F = W[i4];
			W[i4] = W[eM];
			W[eM] = F;
		}
	}
	public static void R(char[] W) {
		new A.w(W, 0, W.Eq - 1).a();
	}
	private static final class A {	
		private static final class w extends G {
			private static final long An = 1L;
			final char[] W;
			final int N;
			final int zk;
			w(char[] W, int N, int zk) {
				this.W = W;
				this.N = N;
				this.zk = zk;
			}
			public final void x() {
				if(N >= zk) {
					return;
				}
				int Qp = WH(W, N, zk);
				if(zk - N < E) {
					oH(W, N, Qp - 1);
					oH(W, Qp + 1, zk);
				}
				else {
					w OJ = new w(W, N, Qp - 1);
					w zH = new w(W, Qp + 1, zk);
					OJ.y5();
					zH.x();
					OJ.b();
				}
			}
		}
		private static void oH(char[] W, int N, int zk) {	
			if(N >= zk) {
				return;
			}
			int Qp = WH(W, N, zk);	
			oH(W, N, Qp - 1);
			oH(W, Qp + 1, zk);
		}
		private static int WH(char[] W, int OJ, int zH) {
			int N = OJ;
			int zk = zH;
			char Qp = W[OJ];	
			while(N < zk) {
				while(W[zk] > Qp) --zk;
				while(W[N] <= Qp && N < zk) ++N;
				vr(W, N, zk);
			}
			vr(W, OJ, N);
			return N;
		}
		private static void vr(char[] W, int i4, int eM) {
			char F = W[i4];
			W[i4] = W[eM];
			W[eM] = F;
		}
	}
	public static void R(short[] W) {
		new t.w(W, 0, W.Eq - 1).a();
	}
	private static final class t {	
		private static final class w extends G {
			private static final long An = 1L;
			final short[] W;
			final int N;
			final int zk;
			w(short[] W, int N, int zk) {
				this.W = W;
				this.N = N;
				this.zk = zk;
			}
			public final void x() {
				if(N >= zk) {
					return;
				}
				int Qp = WH(W, N, zk);
				if(zk - N < E) {
					oH(W, N, Qp - 1);
					oH(W, Qp + 1, zk);
				}
				else {
					w OJ = new w(W, N, Qp - 1);
					w zH = new w(W, Qp + 1, zk);
					OJ.y5();
					zH.x();
					OJ.b();
				}
			}
		}
		private static void oH(short[] W, int N, int zk) {	
			if(N >= zk) {
				return;
			}
			int Qp = WH(W, N, zk);	
			oH(W, N, Qp - 1);
			oH(W, Qp + 1, zk);
		}
		private static int WH(short[] W, int OJ, int zH) {
			int N = OJ;
			int zk = zH;
			short Qp = W[OJ];	
			while(N < zk) {
				while(W[zk] > Qp) --zk;
				while(W[N] <= Qp && N < zk) ++N;
				vr(W, N, zk);
			}
			vr(W, OJ, N);
			return N;
		}
		private static void vr(short[] W, int i4, int eM) {
			short F = W[i4];
			W[i4] = W[eM];
			W[eM] = F;
		}
	}
	public static void R(int[] W) {
		new cD.w(W, 0, W.Eq - 1).a();
	}
	private static final class cD {	
		private static final class w extends G {
			private static final long An = 1L;
			final int[] W;
			final int N;
			final int zk;
			w(int[] W, int N, int zk) {
				this.W = W;
				this.N = N;
				this.zk = zk;
			}
			public final void x() {
				if(N >= zk) {
					return;
				}
				int Qp = WH(W, N, zk);
				if(zk - N < E) {
					oH(W, N, Qp - 1);
					oH(W, Qp + 1, zk);
				}
				else {
					w OJ = new w(W, N, Qp - 1);
					w zH = new w(W, Qp + 1, zk);
					OJ.y5();
					zH.x();
					OJ.b();
				}
			}
		}
		private static void oH(int[] W, int N, int zk) {	
			if(N >= zk) {
				return;
			}
			int Qp = WH(W, N, zk);	
			oH(W, N, Qp - 1);
			oH(W, Qp + 1, zk);
		}
		private static int WH(int[] W, int OJ, int zH) {
			int N = OJ;
			int zk = zH;
			int Qp = W[OJ];	
			while(N < zk) {
				while(W[zk] > Qp) --zk;
				while(W[N] <= Qp && N < zk) ++N;
				vr(W, N, zk);
			}
			vr(W, OJ, N);
			return N;
		}
		private static void vr(int[] W, int i4, int eM) {
			int F = W[i4];
			W[i4] = W[eM];
			W[eM] = F;
		}
	}
	public static void R(long[] W) {
		new L.w(W, 0, W.Eq - 1).a();
	}
	private static final class L {	
		private static final class w extends G {
			private static final long An = 1L;
			final long[] W;
			final int N;
			final int zk;
			w(long[] W, int N, int zk) {
				this.W = W;
				this.N = N;
				this.zk = zk;
			}
			public final void x() {
				if(N >= zk) {
					return;
				}
				int Qp = WH(W, N, zk);
				if(zk - N < E) {
					oH(W, N, Qp - 1);
					oH(W, Qp + 1, zk);
				}
				else {
					w OJ = new w(W, N, Qp - 1);
					w zH = new w(W, Qp + 1, zk);
					OJ.y5();
					zH.x();
					OJ.b();
				}
			}
		}
		private static void oH(long[] W, int N, int zk) {	
			if(N >= zk) {
				return;
			}
			int Qp = WH(W, N, zk);	
			oH(W, N, Qp - 1);
			oH(W, Qp + 1, zk);
		}
		private static int WH(long[] W, int OJ, int zH) {
			int N = OJ;
			int zk = zH;
			long Qp = W[OJ];	
			while(N < zk) {
				while(W[zk] > Qp) --zk;
				while(W[N] <= Qp && N < zk) ++N;
				vr(W, N, zk);
			}
			vr(W, OJ, N);
			return N;
		}
		private static void vr(long[] W, int i4, int eM) {
			long F = W[i4];
			W[i4] = W[eM];
			W[eM] = F;
		}
	}
	public static void R(float[] W) {
		new j.w(W, 0, W.Eq - 1).a();
	}
	private static final class j {	
		private static final class w extends G {
			private static final long An = 1L;
			final float[] W;
			final int N;
			final int zk;
			w(float[] W, int N, int zk) {
				this.W = W;
				this.N = N;
				this.zk = zk;
			}
			public final void x() {
				if(N >= zk) {
					return;
				}
				int Qp = WH(W, N, zk);
				if(zk - N < E) {
					oH(W, N, Qp - 1);
					oH(W, Qp + 1, zk);
				}
				else {
					w OJ = new w(W, N, Qp - 1);
					w zH = new w(W, Qp + 1, zk);
					OJ.y5();
					zH.x();
					OJ.b();
				}
			}
		}
		private static void oH(float[] W, int N, int zk) {	
			if(N >= zk) {
				return;
			}
			int Qp = WH(W, N, zk);	
			oH(W, N, Qp - 1);
			oH(W, Qp + 1, zk);
		}
		private static int WH(float[] W, int OJ, int zH) {
			int N = OJ;
			int zk = zH;
			float Qp = W[OJ];	
			while(N < zk) {
				while(W[zk] > Qp) --zk;
				while(W[N] <= Qp && N < zk) ++N;
				vr(W, N, zk);
			}
			vr(W, OJ, N);
			return N;
		}
		private static void vr(float[] W, int i4, int eM) {
			float F = W[i4];
			W[i4] = W[eM];
			W[eM] = F;
		}
	}
	public static void R(double[] W) {
		new i.w(W, 0, W.Eq - 1).a();
	}
	private static final class i {	
		private static final class w extends G {
			private static final long An = 1L;
			final double[] W;
			final int N;
			final int zk;
			w(double[] W, int N, int zk) {
				this.W = W;
				this.N = N;
				this.zk = zk;
			}
			public final void x() {
				if(N >= zk) {
					return;
				}
				int Qp = WH(W, N, zk);
				if(zk - N < E) {
					oH(W, N, Qp - 1);
					oH(W, Qp + 1, zk);
				}
				else {
					w OJ = new w(W, N, Qp - 1);
					w zH = new w(W, Qp + 1, zk);
					OJ.y5();
					zH.x();
					OJ.b();
				}
			}
		}
		private static void oH(double[] W, int N, int zk) {	
			if(N >= zk) {
				return;
			}
			int Qp = WH(W, N, zk);	
			oH(W, N, Qp - 1);
			oH(W, Qp + 1, zk);
		}
		private static int WH(double[] W, int OJ, int zH) {
			int N = OJ;
			int zk = zH;
			double Qp = W[OJ];	
			while(N < zk) {
				while(W[zk] > Qp) --zk;
				while(W[N] <= Qp && N < zk) ++N;
				vr(W, N, zk);
			}
			vr(W, OJ, N);
			return N;
		}
		private static void vr(double[] W, int i4, int eM) {
			double F = W[i4];
			W[i4] = W[eM];
			W[eM] = F;
		}
	}
	public static <Q> void R(Q[] W, q<? super Q> d) {
		if(d == null) {
			R(W);
		}
		else {
			new OH.w<>(W, 0, W.Eq - 1, d).a();
		}
	}
	public static void R(h[] W) {
		new D2.w(W, 0, W.Eq - 1).a();
	}
	private static final class D2 {	
		private static final class w extends G {
			private static final long An = 1L;
			final h[] W;
			final int N;
			final int zk;
			w(h[] W, int N, int zk) {
				this.W = W;
				this.N = N;
				this.zk = zk;
			}
			public final void x() {
				if(N >= zk) {
					return;
				}
				int Qp = WH(W, N, zk);
				if(zk - N < E) {
					oH(W, N, Qp - 1);
					oH(W, Qp + 1, zk);
				}
				else {
					w OJ = new w(W, N, Qp - 1);
					w zH = new w(W, Qp + 1, zk);
					OJ.y5();
					zH.x();
					OJ.b();
				}
			}
		}
		private static void oH(h[] W, int N, int zk) {
			if(N >= zk) {
				return;
			}
			int Qp = WH(W, N, zk);	
			oH(W, N, Qp - 1);
			oH(W, Qp + 1, zk);
		}
		@V({ "rawtypes", "unchecked" })
		private static int WH(h[] W, int OJ, int zH) {
			int N = OJ;
			int zk = zH;
			PB Qp = ((PB) W[OJ]);	
			while(N < zk) {
				while(Qp.Bi(W[zk]) < 0) --zk;
				while(Qp.Bi(W[N]) >= 0 && N < zk) ++N;
				vr(W, N, zk);
			}
			vr(W, OJ, N);
			return N;
		}
		private static void vr(h[] W, int i4, int eM) {
			h F = W[i4];
			W[i4] = W[eM];
			W[eM] = F;
		}
	}
	private static final class OH {
		private static final class w<Q> extends G {
			private static final long An = 1L;
			final Q[] W;
			final int N;
			final int zk;
			final q<? super Q> d;
			w(Q[] W, int N, int zk, q<? super Q> d) {
				this.W = W;
				this.N = N;
				this.zk = zk;
				this.d = d;
			}
			public final void x() {
				if(N >= zk) {
					return;
				}
				int Qp = WH(W, N, zk, d);	
				if(zk - N < E) {
					oH(W, N, Qp - 1, d);
					oH(W, Qp + 1, zk, d);
				}
				else {
					w<Q> OJ = new w<>(W, N, Qp - 1, d);
					w<Q> zH = new w<>(W, Qp + 1, zk, d);
					OJ.y5();
					zH.x();
					OJ.b();
				}
			}
		}
		private static <Q> void oH(Q[] W, int N, int zk, q<? super Q> d) {
			if(N >= zk) {
				return;
			}
			int Qp = WH(W, N, zk, d);	
			oH(W, N, Qp - 1, d);
			oH(W, Qp + 1, zk, d);
		}
		private static <Q> int WH(Q[] W, int OJ, int zH, q<? super Q> d) {
			int N = OJ;
			int zk = zH;
			Q Qp = W[OJ];
			while(N < zk) {
				while(d.e(Qp, W[zk]) < 0) --zk;
				while(d.e(W[N], Qp) <= 0 && N < zk) ++N;
				vr(W, N, zk);
			}
			vr(W, OJ, N);
			return N;
		}
		private static <Q> void vr(Q[] W, int i4, int eM) {
			Q F = W[i4];
			W[i4] = W[eM];
			W[eM] = F;
		}
	}
	public static void R(byte[] W, boolean p) {
		if(p) {
			m[] l = C.g(W);
			R(l, m3.cN());
			C.ZC(l, W);
		}
		else {
			R(W);
		}
	}
	public static void R(char[] W, boolean p) {
		if(p) {
			K[] l = C.J(W);
			R(l, m3.cN());
			C.D(l, W);
		}
		else {
			R(W);
		}
	}
	public static void R(short[] W, boolean p) {
		if(p) {
			Qx[] l = C.T(W);
			R(l, m3.cN());
			C.u(l, W);
		}
		else {
			R(W);
		}
	}
	public static void R(int[] W, boolean p) {
		if(p) {
			B[] l = C.y(W);
			R(l, m3.cN());
			C.x6(l, W);
		}
		else {
			R(W);
		}
	}
	public static void R(long[] W, boolean p) {
		if(p) {
			Zr[] l = C.Z(W);
			R(l, m3.cN());
			C.r(l, W);
		}
		else {
			R(W);
		}
	}
	public static void R(float[] W, boolean p) {
		if(p) {
			P[] l = C.k(W);
			R(l, m3.cN());
			C.z2(l, W);
		}
		else {
			R(W);
		}
	}
	public static void R(double[] W, boolean p) {
		if(p) {
			v[] l = C.hL(W);
			R(l, m3.cN());
			C.wh(l, W);
		}
		else {
			R(W);
		}
	}
}