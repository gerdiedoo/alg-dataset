package UA;
import O.j.Z;
import xO.G;
import xO.D;
public class UA {
	@p("rawtypes")
	private static H[] u;
	private static byte[] zs;
	private static char[] d;
	private static short[] T;
	private static int[] TQ;
	private static long[] m7;
	private static float[] P;
	private static double[] pu;
	public static void R(byte[] a) {
		zs = new byte[a.Q];
		R(a, 0, a.Q - 1);
		zs = null;
	}
	private static void R(byte[] a, int x, int I) {
		for (int C = 1; C <= I; C += C) {
			for (int q = 0; q <= I - C; q += (2 * C)) {
				int UK = Ew.c(q + (2 * C) - 1, I);
				ww(a, q, q + C - 1, UK);
			}
		}
	}
	private static void ww(byte[] a, int x, int Ms, int I) {
		int q = x;
		int Zj = Ms + 1;
		int P1 = x;
		while (q <= Ms && Zj <= I) {
			if (a[q] <= a[Zj]) {
				zs[P1++] = a[q++];
			}
			else {
				zs[P1++] = a[Zj++];
			}
		}
		if (q > Ms) {
			while (Zj <= I) {
				zs[P1++] = a[Zj++];
			}
		} else {
			while (q <= Ms) {
				zs[P1++] = a[q++];
			}
		}
		System.f(zs, x, a, x, I - x + 1);
	}
	public static void R(char[] a) {
		d = new char[a.Q];
		R(a, 0, a.Q - 1);
		d = null;
	}
	private static void R(char[] a, int x, int I) {
		for (int C = 1; C <= I; C += C) {
			for (int q = 0; q <= I - C; q += (2 * C)) {
				int UK = Ew.c(q + (2 * C) - 1, I);
				ww(a, q, q + C - 1, UK);
			}
		}
	}
	private static void ww(char[] a, int x, int Ms, int I) {
		int q = x;
		int Zj = Ms + 1;
		int P1 = x;
		while (q <= Ms && Zj <= I) {
			if (a[q] <= a[Zj]) {
				d[P1++] = a[q++];
			}
			else {
				d[P1++] = a[Zj++];
			}
		}
		if (q > Ms) {
			while (Zj <= I) {
				d[P1++] = a[Zj++];
			}
		} else {
			while (q <= Ms) {
				d[P1++] = a[q++];
			}
		}
		System.f(d, x, a, x, I - x + 1);
	}
	public static void R(short[] a) {
		T = new short[a.Q];
		R(a, 0, a.Q - 1);
		T = null;
	}
	private static void R(short[] a, int x, int I) {
		for (int C = 1; C <= I; C += C) {
			for (int q = 0; q <= I - C; q += (2 * C)) {
				int UK = Ew.c(q + (2 * C) - 1, I);
				ww(a, q, q + C - 1, UK);
			}
		}
	}
	private static void ww(short[] a, int x, int Ms, int I) {
		int q = x;
		int Zj = Ms + 1;
		int P1 = x;
		while (q <= Ms && Zj <= I) {
			if (a[q] <= a[Zj]) {
				T[P1++] = a[q++];
			}
			else {
				T[P1++] = a[Zj++];
			}
		}
		if (q > Ms) {
			while (Zj <= I) {
				T[P1++] = a[Zj++];
			}
		} else {
			while (q <= Ms) {
				T[P1++] = a[q++];
			}
		}
		System.f(T, x, a, x, I - x + 1);
	}
	public static void R(int[] a) {
		TQ = new int[a.Q];
		R(a, 0, a.Q - 1);
		TQ = null;
	}
	private static void R(int[] a, int x, int I) {
		for (int C = 1; C <= I; C += C) {
			for (int q = 0; q <= I - C; q += (2 * C)) {
				int UK = Ew.c(q + (2 * C) - 1, I);
				ww(a, q, q + C - 1, UK);
			}
		}
	}
	private static void ww(int[] a, int x, int Ms, int I) {
		int q = x;
		int Zj = Ms + 1;
		int P1 = x;
		while (q <= Ms && Zj <= I) {
			if (a[q] <= a[Zj]) {
				TQ[P1++] = a[q++];
			}
			else {
				TQ[P1++] = a[Zj++];
			}
		}
		if (q > Ms) {
			while (Zj <= I) {
				TQ[P1++] = a[Zj++];
			}
		} else {
			while (q <= Ms) {
				TQ[P1++] = a[q++];
			}
		}
		System.f(TQ, x, a, x, I - x + 1);
	}
	public static void R(long[] a) {
		m7 = new long[a.Q];
		R(a, 0, a.Q - 1);
		m7 = null;
	}
	private static void R(long[] a, int x, int I) {
		for (int C = 1; C <= I; C += C) {
			for (int q = 0; q <= I - C; q += (2 * C)) {
				int UK = Ew.c(q + (2 * C) - 1, I);
				ww(a, q, q + C - 1, UK);
			}
		}
	}
	private static void ww(long[] a, int x, int Ms, int I) {
		int q = x;
		int Zj = Ms + 1;
		int P1 = x;
		while (q <= Ms && Zj <= I) {
			if (a[q] <= a[Zj]) {
				m7[P1++] = a[q++];
			}
			else {
				m7[P1++] = a[Zj++];
			}
		}
		if (q > Ms) {
			while (Zj <= I) {
				m7[P1++] = a[Zj++];
			}
		} else {
			while (q <= Ms) {
				m7[P1++] = a[q++];
			}
		}
		System.f(m7, x, a, x, I - x + 1);
	}
	public static void R(float[] a) {
		P = new float[a.Q];
		R(a, 0, a.Q - 1);
		P = null;
	}
	private static void R(float[] a, int x, int I) {
		for (int C = 1; C <= I; C += C) {
			for (int q = 0; q <= I - C; q += (2 * C)) {
				int UK = Ew.c(q + (2 * C) - 1, I);
				ww(a, q, q + C - 1, UK);
			}
		}
	}
	private static void ww(float[] a, int x, int Ms, int I) {
		int q = x;
		int Zj = Ms + 1;
		int P1 = x;
		while (q <= Ms && Zj <= I) {
			if (a[q] <= a[Zj]) {
				P[P1++] = a[q++];
			}
			else {
				P[P1++] = a[Zj++];
			}
		}
		if (q > Ms) {
			while (Zj <= I) {
				P[P1++] = a[Zj++];
			}
		} else {
			while (q <= Ms) {
				P[P1++] = a[q++];
			}
		}
		System.f(P, x, a, x, I - x + 1);
	}
	public static void R(double[] a) {
		pu = new double[a.Q];
		R(a, 0, a.Q - 1);
		pu = null;
	}
	private static void R(double[] a, int x, int I) {
		for (int C = 1; C <= I; C += C) {
			for (int q = 0; q <= I - C; q += (2 * C)) {
				int UK = Ew.c(q + (2 * C) - 1, I);
				ww(a, q, q + C - 1, UK);
			}
		}
	}
	private static void ww(double[] a, int x, int Ms, int I) {
		int q = x;
		int Zj = Ms + 1;
		int P1 = x;
		while (q <= Ms && Zj <= I) {
			if (a[q] <= a[Zj]) {
				pu[P1++] = a[q++];
			}
			else {
				pu[P1++] = a[Zj++];
			}
		}
		if (q > Ms) {
			while (Zj <= I) {
				pu[P1++] = a[Zj++];
			}
		} else {
			while (q <= Ms) {
				pu[P1++] = a[q++];
			}
		}
		System.f(pu, x, a, x, I - x + 1);
	}
	public static void R(F[] a) {
		R(a, 0, a.Q - 1);
	}
	private static void R(F[] a, int x, int I) {
		u = new H[a.Q];
		for (int C = 1; C <= I; C += C) {
			for (int q = 0; q <= I - C; q += (2 * C)) {
				int UK = Ew.c(q + (2 * C) - 1, I);
				ww((H[])a, q, q + C - 1, UK);
			}
		}
		u = null;
	}
	@p({ "unchecked", "rawtypes" })
	private static void ww(H[] a, int x, int Ms, int I) {
		int q = x;
		int Zj = Ms + 1;
		int P1 = x;
		while (q <= Ms && Zj <= I) {
			if (a[q].fI(a[Zj]) <= 0) {
				u[P1++] = a[q++];
			}
			else {
				u[P1++] =  a[Zj++];
			}
		}
		if (q > Ms) {
			while (Zj <= I) {
				u[P1++] = a[Zj++];
			}
		} else {
			while (q <= Ms) {
				u[P1++] = a[q++];
			}
		}
		System.f(u, x, a, x, I - x + 1);
	}
	public static <L> void R(L[] a, Z<? super L> K) {
		if(K == null) {
			R(a, 0, a.Q - 1);
		}
		else {
			R(a, 0, a.Q - 1, K);
		}
	}
	private static <L> void R(L[] a, int x, int I, Z<? super L> K) {
		u = new H[a.Q];
		for (int C = 1; C <= I; C += C) {
			for (int q = 0; q <= I - C; q += (2 * C)) {
				int UK = Ew.c(q + (2 * C) - 1, I);
				ww(a, q, q + C - 1, UK, K);
			}
		}
		u = null;
	}
	@p({ "rawtypes" })
	private static <L> void ww(L[] a, int x, int Ms, int I , Z<? super L> K) {
		int q = x;
		int Zj = Ms + 1;
		int P1 = x;
		while (q <= Ms && Zj <= I) {
			if (K.r(a[q], a[Zj]) <= 0) {
				u[P1++] =  (H) a[q++];
			}
			else {
				u[P1++] =  (H) a[Zj++];
			}
		}
		if (q > Ms) {
			while (Zj <= I) {
				u[P1++] = (H) a[Zj++];
			}
		} else {
			while (q <= Ms) {
				u[P1++] = (H) a[q++];
			}
		}
		System.f(u, x, a, x, I - x + 1);
	}
	public static void R(byte[] a, boolean z2) {
		if(z2) {
			m[] kt = G.A(a);
			R(kt, D.Y());
			G.e(kt, a);
		}
		else {
			R(a);
		}
	}
	public static void R(char[] a, boolean z2) {
		if(z2) {
			Cj[] kt = G.b(a);
			R(kt, D.Y());
			G.jX(kt, a);
		}
		else {
			R(a);
		}
	}
	public static void R(short[] a, boolean z2) {
		if(z2) {
			A0[] kt = G.EC(a);
			R(kt, D.Y());
			G.HF(kt, a);
		}
		else {
			R(a);
		}
	}
	public static void R(int[] a, boolean z2) {
		if(z2) {
			M[] kt = G.n(a);
			R(kt, D.Y());
			G.o(kt, a);
		}
		else {
			R(a);
		}
	}
	public static void R(long[] a, boolean z2) {
		if(z2) {
			U[] kt = G.z(a);
			R(kt, D.Y());
			G.X(kt, a);
		}
		else {
			R(a);
		}
	}
	public static void R(float[] a, boolean z2) {
		if(z2) {
			Be[] kt = G.uo(a);
			R(kt, D.Y());
			G.E(kt, a);
		}
		else {
			R(a);
		}
	}
	public static void R(double[] a, boolean z2) {
		if(z2) {
			j_[] kt = G.V(a);
			R(kt, D.Y());
			G.qL(kt, a);
		}
		else {
			R(a);
		}
	}
}