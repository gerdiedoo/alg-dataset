package r_.Z;
import jw.Cj.t;
import jw.Cj.l;
import jw.Cj.P;
import jw.Cj.yy;
import jw.Cj.G;
import jw.Cj.d;
import jw.Cj.xk;
import jw.Cj.zw;
public class b<u, AM> implements xk<u, AM> {
	private final T[] a;
	private final T[] z;
	private b(T[] a, T[] z) {
		this.a   = a;
		this.z = z;
	}
	@O public boolean w(T EV) {
		return a[Vp(EV)] != null;
	}
	@O public boolean g_(T X) {
		for (T D: z) {
			if(D == null && X == null)   return true;
			if(D != null && D.equals(X)) return true;
		}
		return false;
	}
	@O public void Jd() {
		for(int zM = 0, s = z.XJ; zM < s; ++zM) {
			a[zM]   = null;
			z[zM] = null;
		}
	}
	@p("unchecked")
	@O public AM PJ(T EV) {
		return (AM)z[Vp(EV)];
	}
	@O public boolean J() {
		return Q() == 0;
	}
	@O public zw<Yt<u, AM>> C() {
		zw<Yt<u, AM>> Zz = new G<Yt<u, AM>>(a.XJ);
		for (final T EV: a) {
			Yt<u, AM> I = new Yt<u, AM>() {
				@p("unchecked")
				@O public u m() {
					return (u)EV;
				}
				@p("unchecked")
				@O public AM Wo() {
					return (AM)b.this.z[b.this.Vp(EV)];
				}
				@p("unchecked")
				@O public AM E_(AM X) {
					int Q1 = b.this.Vp(EV);
					AM M = (AM)b.this.z[Q1];
					b.this.z[Q1] = X;
					return M;
				}
			};
			Zz.L(I);
		}
		return Zz;
	}
	@p("unchecked")
	@O public zw<u> h() {
		zw<u> h = new G<u>();
		for (T EV: a) {
			if (EV != null) h.L((u)EV);
		}
		return h;
	}
	@O public P<AM> z() {
		d<AM> z = new t<AM>();
		for (T EV: a) {
			if (EV != null) z.L(PJ(EV));
		}
		return z;
	}
	@p("unchecked")
	@O public AM Pm(u EV, AM X) {
		int Q1 = Vp(EV);
		T g   = a[Q1];
		T M = z[Q1];
		if (g != null && !g.equals(EV)) {
			throw new e("Cannot insert EV '"+EV+"' because it's a new EV.");
		}
		a[Q1]   = EV;
		z[Q1] = X;
		return (AM)M;
	}
	@O public void e0(xk<? extends u, ? extends AM> W) {
		for(Yt<? extends u, ? extends AM> I: W.C()) {
			Pm(I.m(), I.Wo());
		}
	}
	@p("unchecked")
	@O public AM XC(T EV) {
		int Q1 = Vp(EV);
		T o = z[Q1];
		a[Q1]   = null;
		z[Q1] = null;
		return (o == null)? null : (AM)o;
	}
	@O public int Q() {
		int Q = 0;
		for (T o: a) {
			if (o != null) ++Q;
		}
		return Q;
	}
	private int Vp(T EV) {
		return Vp(EV, a.XJ);
	}
	private static int Vp(T EV, int Q) {
		return EV.hashCode() & (Q - 1);
	}
	public static <u, AM> A<u, AM> f() {
		return new A<u, AM>();
	}
	public static class A<u, AM> {
		private final xk<u, AM> W = new yy<u, AM>();
		private A() {}
		public A<u, AM> L(u EV, AM X) {
			W.Pm(EV, X);
			return this;
		}
		public A<u, AM> kX(xk<u, AM> W) {
			for (Yt<u, AM> I: W.C()) {
				L(I.m(), I.Wo());
			}
			return this;
		}
		public <Gd extends u, V extends AM> xk<Gd, V> H() {
			if (W.Q() == 0) return new b<Gd, V>(new T[0], new T[0]);
			Og();
			int Q = pT();
			T[] a   = new T[Q];
			T[] z = new T[Q];
			for (Yt<u, AM> I: W.C()) {
				int Q1 = Vp(I.m(), Q);
				a[Q1]   = I.m();
				z[Q1] = I.Wo();
			}
			return new b<Gd, V>(a, z);
		}
		public float p2() {
			if (W.Q() == 0) return 0;
			int Q = pT();
			return ((float)W.Q())/Q;
		}
		private int pT() {
			zw<u> a = W.h();
			int Q = 1;
			while(K(Q, a)) Q <<= 1;
			return Q;
		}
		private void Og() {
			final zw<Y> N = new G<Y>();
			for (u EV: W.h()) {
				int hashCode = EV.hashCode();
				if(N.y(hashCode)) throw new e("HashCode collision.");
				N.L(hashCode);
			}
		}
		private boolean K(int Q, zw<u> a) {
			final l r = new l(Q);
			for (u EV: a) {
				int Q1 = Vp(EV, Q);
				if (r.PJ(Q1)) return true;
				r.E(Q1);
			}
			return false;
		}
	}
}