package J.U;
import F.Sa.g;
import J.tN.Pg;
public class Z<L extends p<L>> extends M<L> {
	@I
	@V("hiding")
	public <L extends p<L>> L[] ZU(L[] oN, Pg R) {
		return this.mu(oN, R);
	}
	@V("hiding")
	private <L extends p<L>> L[] mu(L[] oN, Pg R) {
		if (oN.O <= 1) {
			return oN;
		}
		int y = oN.O / 2;
		L[] H  = g.EP(oN, 0,         y);
		L[] Q = g.EP(oN, y, oN.O);
		H  = this.mu(H,  R);
		Q = this.mu(Q, R);
		return this.S(oN, H, Q, R);
	}
	@V("hiding")
	private <L extends p<L>> L[] S(L[] oN, L[] c, L[] P, Pg R) {
		int Gb = 0;
		int rl = 0;
		int X = 0;
		int b = c.O + P.O;
		L[] vX = g.m(oN, b);
		while (Gb < c.O && rl < P.O) {
			if        (R == Pg.BF) {   
				if (c[Gb].t(P[rl]) <= 0) {
					vX[X] = c[Gb];
					Gb++;
				} else {
					vX[X] = P[rl];
					rl++;
				}
			} else if (R == Pg.K) {  
				if (c[Gb].t(P[rl]) >= 0) {
					vX[X] = c[Gb];
					Gb++;
				} else {
					vX[X] = P[rl];
					rl++;
				}
			}
			X++;
		}
		while (Gb < c.O) {
			vX[X] = c[Gb];
			Gb++;
			X++;
		}
		while (rl < P.O) {
			vX[X] = P[rl];
			rl++;
			X++;
		}
		return vX;
	}
}