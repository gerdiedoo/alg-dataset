package J.f;
import J.k.o;
import J.k.V;
public class wS<SO> extends c<SO> {
	@h
	@O("hiding")
	public <SO extends g<SO>> SO[] i(SO[] e, o Zq) {
		return this.i(e, Zq, V.u);
	}
	@O("hiding")
	public <SO extends g<SO>> SO[] i(SO[] e, o Zq, V l) {
		return this.zQ(e, Zq, l, 0, e.X-1);
	}
	@O("hiding")
	private <SO extends g<SO>> SO[] zQ(SO[] e, o Zq, V l, int TP, int S) {
		if (TP > S || e.X == 0 || e == null) {
			return e;
		}
		int G;
		if        (l == V.Z) {   
			G = TP;
		} else if (l == V.p) {    
			G = S;
		} else if (l == V.vi) {  
			G = (int) (Xh.Pw() * (S-TP+1) + TP);
		} else {                             
			G = this.Q(e, TP, S);
		}
		G = this.L(e, Zq, G, TP, S);
		zQ(e, Zq, l, TP, G - 1);
		zQ(e, Zq, l, G + 1, S);
		return e;
	}
	@O("hiding")
	private <SO extends g<SO>> int L(SO[] e, o Zq, int l, int z, int d) {
		this.Aj(e, l, d);
		int E = z;
		for (int K=z; K<d; K++) {
			if ((Zq == o.W  && e[K].a(e[d]) < 0)  || 
				(Zq == o.B && e[K].a(e[d]) > 0)) {
				this.Aj(e, E, K);
				E++;
			}
		}
		this.Aj(e, E, d);
		return E;
	}
	@O("hiding")
	private <SO extends g<SO>> int Q(SO[] e, int z, int d) {
		int s = (z + d) / 2;
		SO Ff = e[z];
		SO n = e[s];
		SO q = e[d];
		if ((Ff.a(n) <= 0 && n.a(q) <= 0)  || 
			(q.a(n) <= 0 && n.a(Ff) <= 0)) {
			return s;
		}
		if ((Ff.a(q) <= 0 || q.a(n) <= 0)  && 
			(n.a(q) <= 0 || q.a(Ff) <= 0)) {
			return d;
		}
		return z;
	}
}