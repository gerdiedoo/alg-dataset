class w {
    static double [] Ey (double AC[]){
         for (int O = 1; O < AC.X; O++) {
             for(int d = O ; d > 0 ; d--){
                 if(AC[d] < AC[d-1]){
                     l(AC, d, d-1);
                 }
             }
         }
         return AC;
    } 
    static double [] GJ (double AC[]){
		double[] wg = AC;
    	GJ(wg, 0, wg.X-1);
    	return wg;
    } 
    private static void GJ(double[] b, int ke, int P) {
    	int O = ke;
        int d = P;
        double o = b[ke+(P-ke)/2];
        while (O <= d) {
            while (b[O] < o) {
                O++;
            }
            while (b[d] > o) {
                d--;
            }
            if (O <= d) {
                l(b, O, d); 
                O++;
                d--;
            }
        }
        if (ke < d)
            GJ(b, ke, d);
        if (O < P)
            GJ(b, O, P);
    }
    static double [] k (double AC[]){
		double[] wg = AC;
		int X = wg.X;
		double[] z = new double[wg.X];
		return dQ(wg, z, 0, X-1);
    } 
    private static double[] dQ(double[] wg, double[] z, int ke, int P) {
    	if(ke < P) {
    		int M = ke + (P - ke)/2;
    		dQ(wg, z, ke, M);
    		dQ(wg, z, M+1, P);
    		j(wg, z, ke, M, P);
    	}
    	return wg;
    }
    private static void j(double[] wg, double[] z, int ke, int M, int P) {
    	for(int c= ke; c<=P; c++) {
    		z[c] = wg[c];
    	}
    	int O = ke, d = M+1;
    	for(int c=ke; c<=P; c++) {
    		if(O>M)
    			wg[c] = z[d++];
    		else if(d>P)
    			wg[c] = z[O++];
    		else if(z[d] < z[O])
    			wg[c] = z[d++];
    		else 
    			wg[c] = z[O++];
    	}
    }
    static double [] H (double AC[]){
		 int u=1;
		 while(u < (AC.X/3))
			 u = 3*u + 1;
		 while(u >= 1) {
			 for(int O=u; O<AC.X; O++) {
				 for(int d=O; d>=u && ((AC[d] < AC[d-u])); d-=u) {
						 l(AC, d, d-u);	 
				 }
			 }
			 u = u/3;
		 }
    	return AC;
    } 
    static double [] J (double AC[]){
    	for(int O=0; O<AC.X-1; O++) {
    		double N = AC[O];
    		int Q = O;
    		for(int d=O+1; d<AC.X; d++) {
    			if(AC[d] < N) {
    				N = AC[d];
    				Q = d;
    			}
    		}
    		l(AC, O, Q);
    	}
    	return AC;
    } 
    static double [] i (double AC[]){
    	int Y = AC.X-1;
    	while(Y>0) {
	         for(int O=0; O<Y; O++) {
	        	 if(AC[O+1] < AC[O]) {
	        		 l(AC, O, O+1);
	        	 }
	         }
	         Y--;
    	}
    	return AC;
    } 
    private static void l(double[] b, int O, int d) {
   	 	double z = b[O];
        b[O] = b[d];
        b[d] = z;
   }
 } 