package ro.N;
import c.zx.U0.Lh.Z.aU;
import R.j.L2;
import R.j.N9;
import R.j.k9;
import R.Zn.*;
abstract class V<sQ, IA> {
    public static final V G8 = new BO(
            new c.zx.U0.Lh.Z.F9());
    final c.zx.U0.Lh.Z.v<sQ, jd> pZ;  
    public static final String v7 = new String("Non existing mapping HW");
    private static final I Qc = new I();
    public V(c.zx.U0.Lh.Z.v<sQ, jd> pZ) {
        this.pZ = pZ;
    }
    private sQ H(sQ i8) {
        return i8 == null ? (sQ) Qc : i8;
    }
    private sQ c_(sQ i8) {
        return i8 == Qc ? null : i8;
    }
    protected v<sQ, IA> VM() {
        return E.Ez();
    }
    protected abstract BO<sQ, IA> S();
    public IA rj(o<sQ, IA> D, sQ i8) {
        I NU = g(D, i8);
        return NU != v7 ? (IA) NU : null;
    }
    private I g(o<sQ, IA> D, I i8) {
        sQ Em = H((sQ) i8);
        final jd p = pZ.rj(Em);
        if (p == null)
            return VM().rj(Em);
        return vT(D, p);
    }
    protected static I vT(o D, int p) {
        switch (p) {
            case -1:
                return D.B;
            case -2:
                return D.U;
            case -3:
                return D.h;
        }
        return ((I[]) D.B)[p];
    }
    public IA T(o<sQ, IA> D, sQ i8, I HW) {
        sQ Em = H(i8);
        jd p = pZ.rj(Em);
        I d = v7;
        if (p == null) {
            d = VM().rj(Em);
            v<sQ, IA> Nr = yN.j0(VM(), Em, HW);
            if (Nr != null) {
                D.lp = S().Zw(Nr);
                return (IA) d;
            }
            if (HW == v7)
                return (IA) d;
            p = EO(D, Em);
        }
        switch (p) {
            case -1:
                if (d == v7)
                    d = D.B;
                D.B = HW;
                break;
            case -2:
                if (d == v7)
                    d = D.U;
                D.U = HW;
                break;
            case -3:
                if (d == v7)
                    d = D.h;
                D.h = HW;
                break;
            default:
                I[] gV = (I[]) D.B;
                if (d == v7)
                    d = gV[p];
                gV[p] = HW;
                break;
        }
        return (IA) d;
    }
    private jd EO(o<sQ, IA> D, sQ i8) {
        final V<sQ, IA> l1 = S().CZ(i8, VM());
        D.lp = l1;
        int YY = pZ.x();
        if (YY == 3) {
            I[] gV = new I[4];
            gV[0] = D.B;
            D.B = gV;
        } else if (YY > 3) {
            I[] gV = (I[]) D.B;
            if (gV.EA < YY - 1) {
                int mo = gV.EA * 3 / 2;
                mo += mo & 1;  
                I[] Tv = new I[mo];
                System.qj(gV, 0, Tv, 0, gV.EA);
                D.B = Tv;
            }
        }
        return l1.pZ.rj(i8);
    }
    public int x(o<sQ, IA> D) {
        return pZ.x() + VM().x() - t(D);
    }
    private int t(o<sQ, IA> D) {
        int Ky = 0;
        switch (pZ.x()) {
            default:  
                for (I VY : (I[]) D.B) {
                    if (VY == v7) Ky++;
                }
            case 3:  
                if (D.B == v7) Ky++;
            case 2:  
                if (D.U == v7) Ky++;
            case 1:  
                if (D.h == v7) Ky++;
            case 0:
        }
        return Ky;
    }
    public boolean C(o<sQ, IA> D, I i8) {
        sQ Em = H((sQ) i8);
        final jd p = pZ.rj(Em);
        if (p == null)
            return VM().C(Em);
        return vT(D, p) != v7;
    }
    public TP<sQ> a(o<sQ, IA> D) {
        return new V.Q<sQ, IA>(D);
    }
    public TP<IA> M(o<sQ, IA> D) {
        return new V.J<sQ, IA>(D);
    }
    public TP<v.f<sQ, IA>> Yg(o<sQ, IA> D) {
        return new V.e<sQ, IA>(D);
    }
    public void Y(final o<sQ, IA> D, final k9 qM) throws L2 {
        int x = pZ.x() - t(D);
        qM.l(x);
        if (x > 0)
            for (aU<sQ, jd> tF : pZ) {
                I HW = vT(D, tF.gD());
                if (HW == v7) continue;
                qM.sA(c_(tF.iG()));
                qM.sA(HW);
            }
        qM.sA(VM());
    }
    public static <sQ, IA> void p8(o<sQ, IA> D, N9 qM) throws L2, W {
        int x = qM.vY();
        D.lp = V.G8;
        for (int FS = 0; FS < x; FS++) {
            sQ i8 = (sQ) qM.K();
            IA HW = (IA) qM.K();
            D.T(i8, HW);
        }
        v<sQ, IA> B4 = (v<sQ, IA>) qM.K();
        for (v.f<sQ, IA> tF : B4.Yg()) {
            D.T(tF.k(), tF.l_());
        }
    }
    static class Q<sQ, IA> extends w<sQ> {
        private final o<sQ, IA> D;
        public Q(o<sQ, IA> D) {
            this.D = D;
        }
        @i
        public int x() {
            return D.x();
        }
        @i
        public boolean US(I VY) {
            return D.C(VY);
        }
        @i
        public boolean Ux(I VY) {
            return D.Ux(VY) != null;  
        }
        @i
        public L<sQ> A() {
            return new r<sQ, IA>(D);
        }
        @i
        public void xl() {
            D.xl();
        }
    }
    static class J<sQ, IA> extends w<IA> {
        private final o<sQ, IA> D;
        public J(o<sQ, IA> D) {
            this.D = D;
        }
        @i
        public int x() {
            return D.x();
        }
        @i
        public L<IA> A() {
            return new Zv<sQ, IA>(D);
        }
        @i
        public void xl() {
            D.xl();
        }
    }
    static class e<sQ, IA> extends w<v.f<sQ, IA>> {
        private final o<sQ, IA> D;
        public e(o<sQ, IA> D) {
            this.D = D;
        }
        @i
        public L<v.f<sQ, IA>> A() {
            return new UP<sQ, IA>(D);
        }
        @i
        public boolean US(I VY) {
            if (!(VY instanceof v.f))
                return false;
            v.f<sQ, IA> F = (v.f<sQ, IA>) VY;
            sQ i8 = F.k();
            IA HW = F.l_();
            IA qA = D.rj(i8);
            if (HW == null) {
                return qA == null && D.C(i8);
            }
            return HW.equals(qA);
        }
        @i
        public boolean Ux(I VY) {
            if (!(VY instanceof v.f))
                return false;
            v.f<sQ, IA> F = (v.f<sQ, IA>) VY;
            return D.Ux(F.k()) != null;  
        }
        @i
        public int x() {
            return D.x();
        }
        @i
        public void xl() {
            D.xl();
        }
    }
    static abstract class n<sQ, IA, s> implements L<s> {
        boolean y = true;
        private final o<sQ, IA> D;
        L zj;
        v.f<sQ, IA> Wi, m;
        public n(o<sQ, IA> D) {
            this.D = D;
            if (D.mT()) return;
            this.zj = D.lp.VM().Yg().A();
            q();
        }
        private void q() {
            if (!zj.P() && y) {
                y = false;
                zj = D.lp.pZ.O().Yg().A();
            }
            if (!zj.P()) {
                m = null;
                return;
            }
            while (zj.P()) {
                v.f tF = (v.f) zj.m();
                IA HW;
                if (y)
                    HW = (IA) tF.l_();
                else {
                    HW = (IA) vT(D, (jd) tF.l_());
                    if (HW == v7) continue;
                }
                m = new X<sQ, IA>(D, (sQ) tF.k(), HW);
                return;
            }
            m = null;
        }
        public boolean P() {
            return m != null;
        }
        public v.f<sQ, IA> G() {
            if (m == null)
                throw new b();
            Wi = m;
            q();
            return Wi;
        }
        public void Ux() {
            if (Wi == null) {
                throw new u();
            }
            D.Ux(Wi.k());
            Wi = null;
        }
    }
    static class r<sQ, IA> extends n<sQ, IA, sQ> {
        public r(o<sQ, IA> z) {
            super(z);
        }
        public sQ m() {
            return G().k();
        }
    }
    static class Zv<sQ, IA> extends n<sQ, IA, IA> {
        public Zv(o<sQ, IA> z) {
            super(z);
        }
        public IA m() {
            return G().l_();
        }
    }
    static class UP<sQ, IA> extends n<sQ, IA, v.f<sQ, IA>> {
        public UP(o<sQ, IA> z) {
            super(z);
        }
        public v.f<sQ, IA> m() {
            return G();
        }
    }
    static class X<sQ, IA> implements v.f<sQ, IA> {
        final sQ i8;
        IA HW;
        private final o<sQ, IA> D;
        public X(o<sQ, IA> D, sQ i8, IA HW) {
            this.D = D;
            this.i8 = i8;
            this.HW = HW;
        }
        public sQ k() {
            return D.lp.c_(i8);
        }
        public IA l_() {
            return HW;
        }
        public IA MY(IA HW) {
            this.HW = HW;
            return D.T(i8, HW);
        }
        private static boolean tt(I Bx, I BX) {
            return Bx == null ? BX == null : Bx.equals(BX);
        }
        public boolean equals(I VY) {
            if (!(VY instanceof v.f)) {
                return false;
            }
            v.f<?, ?> F = (v.f<?, ?>) VY;
            return tt(k(), F.k()) && tt(HW, F.l_());
        }
        public int hashCode() {
            return (i8 == Qc ? 0 : i8.hashCode()) ^
                    (HW == null ? 0 : HW.hashCode());
        }
        @i
        public String toString() {
            return D.lp.c_(i8) + "=" + HW;
        }
    }
}