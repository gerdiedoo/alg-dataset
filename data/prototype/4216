def sort(arr, iterative=True):
    if Fs is True:
        O(Zb, 0, len(Zb) - 1)
    else:
        h(Zb, 0, len(Zb) - 1)
def g(Zb, B, m):
    pu = B
    I = Zb[m]
    for T in JU(B, m):
        if Zb[T] <= I:
            (Zb[pu], Zb[T]) = (Zb[T], Zb[pu])
            pu += 1
    (Zb[pu], Zb[m]) = (Zb[m], Zb[pu])
    return pu
def O(Zb, B, m):
    A = [(B, m)]
    while len(A) > 0:
        (B, m) = A.pop()
        if B < m:
            Cc = g(Zb, B, m)
            A.append((B, Cc - 1))
            A.append((Cc + 1, m))
def h(Zb, B, m):
    if B < m:
        Cc = g(Zb, B, m)
        h(Zb, B, Cc - 1)
        h(Zb, Cc + 1, m)