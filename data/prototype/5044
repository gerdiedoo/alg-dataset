class W {
    static double [] r (double H[]){
         for (int i = 1; i < H.Qn; i++) {
             for(int N = i ; N > 0 ; N--){
                 if(H[N] < H[N-1]){
                     Ap(H, N, N-1);
                 }
             }
         }
         return H;
    } 
    static double [] b (double H[]){
		double[] l = H;
    	b(l, 0, l.Qn-1);
    	return l;
    } 
    private static void b(double[] a3, int t, int bC) {
    	int i = t;
        int N = bC;
        double P = a3[t+(bC-t)/2];
        while (i <= N) {
            while (a3[i] < P) {
                i++;
            }
            while (a3[N] > P) {
                N--;
            }
            if (i <= N) {
                Ap(a3, i, N); 
                i++;
                N--;
            }
        }
        if (t < N)
            b(a3, t, N);
        if (i < bC)
            b(a3, i, bC);
    }
    static double [] RM (double H[]){
		double[] l = H;
		int Qn = l.Qn;
		double[] TZ = new double[l.Qn];
		return R(l, TZ, 0, Qn-1);
    } 
    private static double[] R(double[] l, double[] TZ, int t, int bC) {
    	if(t < bC) {
    		int m = t + (bC - t)/2;
    		R(l, TZ, t, m);
    		R(l, TZ, m+1, bC);
    		xF(l, TZ, t, m, bC);
    	}
    	return l;
    }
    private static void xF(double[] l, double[] TZ, int t, int m, int bC) {
    	for(int YA= t; YA<=bC; YA++) {
    		TZ[YA] = l[YA];
    	}
    	int i = t, N = m+1;
    	for(int YA=t; YA<=bC; YA++) {
    		if(i>m)
    			l[YA] = TZ[N++];
    		else if(N>bC)
    			l[YA] = TZ[i++];
    		else if(TZ[N] < TZ[i])
    			l[YA] = TZ[N++];
    		else 
    			l[YA] = TZ[i++];
    	}
    }
    static double [] vP (double H[]){
		 int O=1;
		 while(O < (H.Qn/3))
			 O = 3*O + 1;
		 while(O >= 1) {
			 for(int i=O; i<H.Qn; i++) {
				 for(int N=i; N>=O && ((H[N] < H[N-O])); N-=O) {
						 Ap(H, N, N-O);	 
				 }
			 }
			 O = O/3;
		 }
    	return H;
    } 
    static double [] J (double H[]){
    	for(int i=0; i<H.Qn-1; i++) {
    		double q = H[i];
    		int dx = i;
    		for(int N=i+1; N<H.Qn; N++) {
    			if(H[N] < q) {
    				q = H[N];
    				dx = N;
    			}
    		}
    		Ap(H, i, dx);
    	}
    	return H;
    } 
    static double [] E (double H[]){
    	int Mw = H.Qn-1;
    	while(Mw>0) {
	         for(int i=0; i<Mw; i++) {
	        	 if(H[i+1] < H[i]) {
	        		 Ap(H, i, i+1);
	        	 }
	         }
	         Mw--;
    	}
    	return H;
    } 
    private static void Ap(double[] a3, int i, int N) {
   	 	double TZ = a3[i];
        a3[i] = a3[N];
        a3[N] = TZ;
   }
 } 