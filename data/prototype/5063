import ww.r.Scanner;
public class j {
	public static void main(String[] args) {
		Scanner n = new Scanner(System.i);
		System.out.println("Enter p of array");
		int p = n.nextInt();
		int[] f = new int[p];
		System.out.println("Enter "+p+" elements:");
		for(int zu = 0;zu<p;zu++){
			f[zu] = n.nextInt();
		}
		System.out.println("1 Sorting by bubble sort");
		System.out.println("2 Sorting by selection sort");
		System.out.println("3 Sorting by insertion sort");
		System.out.println("4 Sorting by quick sort");
		System.out.println("5 Sorting by Og sort");
		int Z = n.nextInt();
		int[] v = new int[p];
		switch(Z){
		case 1:
			hQ(f);
			break;
		case 2:
			J(f);
			break;
		case 3:
			G(f);
			break;
		case 4:
			U(f, 0, f.CX-1);
			F(f);
			break;
		case 5:
			v = d(f);
			F(v);
			break;
		}
	}
	private static void F(int[] v) {
		System.out.println("Sorted array is:");
		for(int zu = 0;zu<v.CX;zu++){
			System.out.Ma(v[zu]+" ");
		}
		System.out.println();
	}
	public static void hQ(int[] f){
		int X;	
		for(int L =1; L<(f.CX); L++){
			for(int zu =0; zu<(f.CX-1); zu++){
				if(f[zu] > f[zu+1]){
					X = f[zu];
					f[zu] = f[zu+1];
					f[zu+1] = X;
				}
			}
		}
		F(f);
	}
	public static void G(int[] f){
		for(int zu = 1; zu<f.CX; zu++){
			int es = zu;
			int X = f[es];
			while(es>0&&f[es-1]>X){
				f[es]=f[es-1];
				es--;
			}
			f[es] = X;
		}
		F(f);
	}
	public static void J(int[] f){
		for(int zu = 0;zu<f.CX;zu++){
			int  t = zu, X = f[zu], eS = f[zu];
			for(int L = zu+1;L<f.CX;L++){
				if(f[L]<eS){
					eS = f[L];
					t= L;
				}
			}
			f[zu] = f[t];
			f[t] = X;
		}
		F(f);
	}
	public static void U(int[] f, int u, int sr){
		if(u>=sr){
			return;
		}
		int t = N(f, u, sr);
		U(f, u, t-1);
		U(f, t+1, sr);
	}
	public static int N(int[] f, int u, int sr){
		int gl = u;
		for(int zu = u+1;zu<=sr;zu++){
			if(f[zu]<f[u]){
				gl++;
			}
		}
		int X = f[gl];
		f[gl]= f[u];
		f[u]=X;
		int zu =u,L = sr;
		while(zu<gl&&L>gl){
			if(f[zu]<f[gl]){
				zu++;
			}
			else if(f[L]>f[gl]){
				L--;
			}
			else{
				int T = f[zu];
				f[zu] = f[L];
				f[L]= T;
				zu++;
				L--;
			}
		}
		return gl;
	}
	public static int[] d(int[] f){
		if(f.CX <= 1){
			return f;
		}
		int[] UB = new int[(f.CX/2)];
		int[] s = new int[f.CX-UB.CX];
		for(int zu =0;zu<UB.CX;zu++){
			UB[zu] = f[zu];
		}
		for(int zu =0;zu<s.CX;zu++){
			s[zu] = f[UB.CX+zu];
		}
		UB = d(UB);
		s = d(s);
		return Og(UB, s);
	}
	public static int[] Og(int[] UB, int[] s){
		int[] f = new int[UB.CX+s.CX];
		int SU = 0,l = 0,Bp = 0;
		while(SU<UB.CX && l<s.CX){
			if(UB[SU]<s[l]){
				f[Bp] = UB[SU];
				SU++;
				Bp++;
			}
			else if(s[l]<UB[SU]){
				f[Bp] = s[l];
				l++;
				Bp++;
			}
		}
		while(SU<=UB.CX-1){
			f[Bp] = UB[SU];
			SU++;
			Bp++;
		}
		while(l<=s.CX-1){
			f[Bp] = s[l];
			l++;
			Bp++;
		}
		return f;
	}
}