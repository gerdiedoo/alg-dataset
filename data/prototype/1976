package j_;
import Q.z.t;
import Q.z.ea;
import Q.z.M;
import Q.z.c;
import Q.z.E;
import Q.z.Z;
public class dV<X,R> extends I<X,R>{
	private t<k<X,R>> g = new t<>();
	public dV(){	}
	public void Ya() {
		g.Ya();
	}
	private int A(X B1){
		int U = g.h();
		for(int L = 0; L < U; L++){
			if(g.Qz(L).B().equals(B1)){
				return L;
			}
		}
		return -1;
	}
	private int b(R K){
		int U = g.h();
		for(int L = 0; L < U; L++){
			if(g.Qz(L).W() == K){
				return L;
			}
		}
		return -1;
	}
	public boolean C(T B1) {
		int L = A((X)B1);
		if(L == -1){
			return false;
		} else{
			return true;
		}
	}
	public boolean u(T K) {
		int L = b((R)K);
		if(L == -1){
			return false;
		} else{
			return true;
		}
	}
	private class H implements M<hR<X,R>> {
		private int L = 0;
		public boolean p(){
			return L < g.h();
		}
		public hR<X,R> m(){
			if(L == g.h()){
				throw new E();
			}
			return g.Qz(L++);
		}
		public void O(){
			throw new P();
		}
	}
	private class V implements Sn<hR<X,R>> {
		public M<hR<X, R>> UC() {
			return new H();
		}
	}
	public Z<hR<X, R>> G() {
		return (Z<hR<X, R>>) new V();
	}
	public R Qz(T B1) {
		int L = A((X)B1);
		if(L == -1){
			return null;
		}
		return g.Qz(L).W();
	}
	public R f(X B1, R K) {
		int L = A(B1);
		if(L == -1){
			g.aS(new k<>(B1,K));
			return null;
		} else {
			return g.Qz(L).D(K);
		}
	}
	public void nY(c<? extends X, ? extends R> q) {
		g.a((ea<? extends k<X, R>>) q);
	}
	public R O(T B1) {
		int L = A((X)B1);
		int U = h();
		if(L == -1){
			return null;
		} 
		R d = g.Qz(L).W();
		if(L != U - 1){
			g.fv(L, g.Qz(U-1));
		}
		g.O(U-1);
		return d;
	}
	public int h() {
		return g.h();
	}
}