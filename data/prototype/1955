package zO.m;
import K.kK.E;
import K.kK.o;
import K.kK.y;
import K.kK.c;
import K.kK.L;
import K.kK.Af;
import K.kK.f;
import K.kK.q;
public class P<eo, nR> implements f<eo, nR> {
	private final r[] p;
	private final r[] D0;
	private P(r[] p, r[] D0) {
		this.p   = p;
		this.D0 = D0;
	}
	@hi public boolean C(r MD) {
		return p[S(MD)] != null;
	}
	@hi public boolean kU(r N) {
		for (r x: D0) {
			if(x == null && N == null)   return true;
			if(x != null && x.equals(N)) return true;
		}
		return false;
	}
	@hi public void W() {
		for(int h = 0, b = D0.Iv; h < b; ++h) {
			p[h]   = null;
			D0[h] = null;
		}
	}
	@SW("unchecked")
	@hi public nR e(r MD) {
		return (nR)D0[S(MD)];
	}
	@hi public boolean J() {
		return gl() == 0;
	}
	@hi public q<bL<eo, nR>> Q() {
		q<bL<eo, nR>> R = new L<bL<eo, nR>>(p.Iv);
		for (final r MD: p) {
			bL<eo, nR> i = new bL<eo, nR>() {
				@SW("unchecked")
				@hi public eo I9() {
					return (eo)MD;
				}
				@SW("unchecked")
				@hi public nR t() {
					return (nR)P.this.D0[P.this.S(MD)];
				}
				@SW("unchecked")
				@hi public nR Xs(nR N) {
					int F = P.this.S(MD);
					nR bR = (nR)P.this.D0[F];
					P.this.D0[F] = N;
					return bR;
				}
			};
			R.u(i);
		}
		return R;
	}
	@SW("unchecked")
	@hi public q<eo> j() {
		q<eo> j = new L<eo>();
		for (r MD: p) {
			if (MD != null) j.u((eo)MD);
		}
		return j;
	}
	@hi public y<nR> D0() {
		Af<nR> D0 = new E<nR>();
		for (r MD: p) {
			if (MD != null) D0.u(e(MD));
		}
		return D0;
	}
	@SW("unchecked")
	@hi public nR U(eo MD, nR N) {
		int F = S(MD);
		r O   = p[F];
		r bR = D0[F];
		if (O != null && !O.equals(MD)) {
			throw new qE("Cannot insert MD '"+MD+"' because it's a new MD.");
		}
		p[F]   = MD;
		D0[F] = N;
		return (nR)bR;
	}
	@hi public void s(f<? extends eo, ? extends nR> a) {
		for(bL<? extends eo, ? extends nR> i: a.Q()) {
			U(i.I9(), i.t());
		}
	}
	@SW("unchecked")
	@hi public nR sw(r MD) {
		int F = S(MD);
		r iB = D0[F];
		p[F]   = null;
		D0[F] = null;
		return (iB == null)? null : (nR)iB;
	}
	@hi public int gl() {
		int gl = 0;
		for (r iB: p) {
			if (iB != null) ++gl;
		}
		return gl;
	}
	private int S(r MD) {
		return S(MD, p.Iv);
	}
	private static int S(r MD, int gl) {
		return MD.hashCode() & (gl - 1);
	}
	public static <eo, nR> I<eo, nR> n() {
		return new I<eo, nR>();
	}
	public static class I<eo, nR> {
		private final f<eo, nR> a = new c<eo, nR>();
		private I() {}
		public I<eo, nR> u(eo MD, nR N) {
			a.U(MD, N);
			return this;
		}
		public I<eo, nR> H(f<eo, nR> a) {
			for (bL<eo, nR> i: a.Q()) {
				u(i.I9(), i.t());
			}
			return this;
		}
		public <QY extends eo, G extends nR> f<QY, G> V() {
			if (a.gl() == 0) return new P<QY, G>(new r[0], new r[0]);
			sq();
			int gl = kl();
			r[] p   = new r[gl];
			r[] D0 = new r[gl];
			for (bL<eo, nR> i: a.Q()) {
				int F = S(i.I9(), gl);
				p[F]   = i.I9();
				D0[F] = i.t();
			}
			return new P<QY, G>(p, D0);
		}
		public float g() {
			if (a.gl() == 0) return 0;
			int gl = kl();
			return ((float)a.gl())/gl;
		}
		private int kl() {
			q<eo> p = a.j();
			int gl = 1;
			while(Z(gl, p)) gl <<= 1;
			return gl;
		}
		private void sq() {
			final q<WQ> k = new L<WQ>();
			for (eo MD: a.j()) {
				int hashCode = MD.hashCode();
				if(k.FL(hashCode)) throw new qE("HashCode collision.");
				k.u(hashCode);
			}
		}
		private boolean Z(int gl, q<eo> p) {
			final o M = new o(gl);
			for (eo MD: p) {
				int F = S(MD, gl);
				if (M.e(F)) return true;
				M.A(F);
			}
			return false;
		}
	}
}