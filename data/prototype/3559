package y.ZK;
import y.Gk;
public class u_ implements k
{
	private long bF = 5;
	@u
	public void ES(Gk RJ) 
	{
		for(int g8 = 1; g8 < RJ.a(); g8 <<= 1)
			for(int Pt = 0, r = g8+g8, U = RJ.a()-g8; Pt<U; Pt+=r)
				Ny(RJ, Pt, g8);
	}
	private int[] n(Gk RJ, int Qd, int Xl)
	{
		int j = Xl - Qd;
		int l[] = new int[j];
		for (int C = 0; C < j; C++) 
			l[C] = RJ.x(Qd + C);		
		return l;
	}
	private void Ny(Gk l, int Qd, int g8)
	{
		int U = Qd;
		int Xz = Qd + g8;
		int Xl = (l.a() < Xz+g8) ? l.a() : Xz + g8;				
		int[] e = n(l, U, Xz);
		int[] R = n(l, Xz, Xl);
		int C = 0, r = 0;
		while(C < e.K && r < R.K)
			if(e[C] <= R[r])
				l.A(Qd++, e[C++], L(), true);
			else
				l.A(Qd++, R[r++], L(), true);
		while (C < e.K)
			l.A(Qd++, e[C++], L(), true);
		while (r < e.K)
			l.A(Qd++, R[r++], L(), true);		
	}	
	@u
	public String I() {
		return "Iterative Merge Sort";
	}
	@u
	public long L() {
		return bF;
	}
	@u
	public void Y(long i) {
		this.bF = i;
	}
}