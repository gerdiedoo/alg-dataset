public class v<HJ extends R<? super HJ>> implements
        DX<HJ> {
    private hm<HJ> Zx;
    private hm<HJ> n;
    private int SI;
    @w
    public void o(HJ pW) {
        if (pW == null) {
            throw new kr.t.VA("Input pW is null.");
        }
        Zx = new hm<HJ>(pW, Zx);
        if (SI == 0) {
            n = Zx;
        }
        ++SI;
    }
    @w
    public void q(HJ pW, int V) {
        if (pW == null) {
            throw new kr.t.VA("Input pW is null.");
        }
        if (V < 0 || V > SI) {
            throw new kr.t.W(
                    "Input V is out of bounds.");
        }
        if (V == 0) {
            o(pW);
        } else if (V == SI) {
            Tn(pW);
        } else {
            hm<HJ> x = Zx;
            for (int hH = 0; hH < V - 1; ++hH) {
                x = x.mB();
            }
            x.T(new hm<HJ>(pW, x.mB()));
            ++SI;
        }
    }
    @w
    public void Tn(HJ pW) {
        if (pW == null) {
            throw new kr.t.VA("Input pW is null.");
        }
        if (SI == 0) {
            o(pW);
        } else {
            n.T(new hm<HJ>(pW));
            n = n.mB();
            ++SI;
        }
    }
    @w
    public HJ YT() {
        if (SI == 0) {
            return null;
        } else {
            HJ eJ = Zx.oR();
            Zx = Zx.mB();
            if (SI == 1) {
                n = null;
            }
            --SI;
            return eJ;
        }
    }
    @w
    public HJ iT(int V) {
        if (V < 0 || V >= SI) {
            throw new kr.t.W(
                    "Input V is out of bounds.");
        }
        if (V == 0) {
            return YT();
        } else if (V == SI - 1) {
            return mP();
        } else {
            hm<HJ> x = Zx;
            HJ eJ;
            for (int hH = 0; hH < V - 1; ++hH) {
                x = x.mB();
            }
            eJ = x.mB().oR();
            x.T(x.mB().mB());
            --SI;
            return eJ;
        }
    }
    @w
    public HJ mP() {
        if (SI == 0) {
            return null;
        } else if (SI == 1) {
            return YT();
        } else {
            HJ eJ = n.oR();
            hm<HJ> x = Zx;
            for (int hH = 1; hH < SI - 1; ++hH) {
                x = x.mB();
            }
            x.T(null);
            n = x;
            --SI;
            return eJ;
        }
    }
    @w
    public HJ Z(int V) {
        if (V < 0 || V >= SI) {
            throw new kr.t.W(
                    "Input V is out of bounds.");
        }
        if (V == 0) {
            return Zx.oR();
        } else if (V == SI - 1) {
            return n.oR();
        } else {
            hm<HJ> x = Zx;
            for (int hH = 0; hH < V; ++hH) {
                x = x.mB();
            }
            return x.oR();
        }
    }
    @w
    public HJ p() {
        if (SI == 0) {
            return null;
        }
        HJ eJ = Zx.oR();
        hm<HJ> x = Zx;
        while (x != null) {
            if (eJ.QM(x.oR()) < 0) {
                eJ = x.oR();
            }
            x = x.mB();
        }
        return eJ;
    }
    @w
    public tt[] l() {
        tt[] h = new tt[SI];
        hm<HJ> x = Zx;
        for (int hH = 0; hH < SI; ++hH) {
            h[hH] = x.oR();
            x = x.mB();
        }
        return h;
    }
    @w
    public int SI() {
        return SI;
    }
    @w
    public boolean J() {
        return SI == 0;
    }
    @w
    public void D() {
        Zx = null;
        n = null;
        SI = 0;
    }
    @w
    public hm<HJ> B() {
        return Zx;
    }
    @w
    public hm<HJ> E() {
        return n;
    }
}