def insertsort(A):
    _len = len(A)
    if _len <= 1:
        return A
    for i in xrange(1, _len):
        j = i
        while A[j] < A[j-1] and j > 0:
            A[j], A[j-1] = A[j-1], A[j]
            j -= 1
    return A
def selectsort(A):
    for i in xrange(len(A)):
        minIdx = i
        for j in xrange(i+1, len(A)):
            if A[j] < A[minIdx]:
                minIdx = j
        A[i], A[minIdx] = A[minIdx], A[i]
def mergesort(A):
    def divide(A, l, r):
        print l, r
        if (l >= r):
            return [A[r]]
        m = (l + r) / 2
        L = divide(A, l, m)
        R = divide(A, m+1, r)
        return merge_(L, R)
    def merge_(L, R):
        lenL, lenR = len(L), len(R)
        i, j = 0, 0
        r = []
        while i < lenL and j < lenR:
            if L[i] < R[j]:
                r.append(L[i])
                i += 1
            else:
                r.append(R[j])
                j += 1
        while i < lenL:
            r.append(L[i])
            i += 1
        while j < lenR:
            r.append(R[j])
            j += 1
        return r
    return divide(A, 0, len(A)-1)
if __name__ == '__main__':
    A = [1,3,35,5,4, 6]
    B = [6,6,6,6,6,6,6,6,6,6]
    res = mergesort(B)
    print res