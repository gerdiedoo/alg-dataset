package U.m;
import u.q.Y;
public class Oh {
	private Oh() {
	}
	public static void R(W[] FL) {
		if(FL == null)
			throw new O2();
		W[] g = new W[FL.L];
		R(FL, g, 0, FL.L - 1);
	}
	public static void R(r[] FL, Y U) {
		if(FL == null)
			throw new O2();
		W[] g = new W[FL.L];
		R(FL, g, U, 0, FL.L - 1);
	}
	private static void R(W[] a, W[] g, int M, int G) {
		if (G <= M)
			return;
		int V = M + (G - M) / 2;
		R(a, g, M, V);
		R(a, g, V + 1, G);
		Bj(a, g, M, V, G);
	}
	private static void R(r[] a, r[] g, Y U, int M,
			int G) {
		if (G <= M)
			return;
		int V = M + (G - M) / 2;
		R(a, g, U, M, V);
		R(a, g, U, V + 1, G);
		Bj(a, g, U, M, V, G);
	}
	private static void Bj(W[] a, W[] g, int M,
			int V, int G) {
		for (int N = M; N <= G; N++) {
			g[N] = a[N];
		}
		int vn = M, K = V + 1;
		for (int N = M; N <= G; N++) {
			if (vn > V)
				a[N] = g[K++];
			else if (K > G)
				a[N] = g[vn++];
			else if (x(g[K], g[vn]))
				a[N] = g[K++];
			else
				a[N] = g[vn++];
		}
	}
	private static void Bj(r[] a, r[] g, Y U, int M,
			int V, int G) {
		for (int N = M; N <= G; N++) {
			g[N] = a[N];
		}
		int vn = M, K = V + 1;
		for (int N = M; N <= G; N++) {
			if (vn > V)
				a[N] = g[K++];
			else if (K > G)
				a[N] = g[vn++];
			else if (x(U, g[K], g[vn]))
				a[N] = g[K++];
			else
				a[N] = g[vn++];
		}
	}
	private static boolean x(W v, W eQ) {
		return v.D(eQ) < 0;
	}
	private static boolean x(Y V9, r v, r eQ) {
		return V9.c(v, eQ) < 0;
	}
	private static void sd(r[] a, int vn, int K) {
		r sy = a[vn];
		a[vn] = a[K];
		a[K] = sy;
	}
	public static void e(W[] FL) {
		int s = FL.L;
		for (int vn = 0; vn < s; vn++) {
			System.out.oz(FL[vn] + ",");
		}
	}
}