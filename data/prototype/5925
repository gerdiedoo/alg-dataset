import u.q.V;
import u.q.xI;
import u.q.vR;
import u.q.X;
import u.q.Vo;
public class d {
    public static <gM> void T(gM[] il, xI<gM> E6) {
        if (il == null) {
            throw new f("Input array can not be null.");
        }
        if (E6 == null) {
            throw new f("Input E6 can not "
                    + "be null.");
        }
        int J;
        gM B;
        for (int HA = 1; HA < il.eT; HA++) {
            J = HA;
            while (J > 0
                    && E6.AX(il[J - 1],
                    il[J]) > 0) {
                B = il[J - 1];
                il[J - 1] = il[J];
                il[J] = B;
                --J;
            }
        }
    }
    public static <gM> gM HM(int z, gM[] il, xI<gM> E6,
                                     Vo rG) {
        if (il == null) {
            throw new f("Input array can not be null.");
        }
        if (E6 == null) {
            throw new f("xI can not be null.");
        }
        if (rG == null) {
            throw new f("Vo can not be null.");
        }
        if (z < 1 || z > il.eT) {
            throw new f("K is out of the array range.");
        }
        return C(z, il, E6, rG, 0,
                il.eT - 1);
    }
    private static <gM> gM C(int z,
                                         gM[] il, xI<gM> E6,
                                         Vo rG, int dT,
                                         int WH) {
        if (dT == WH) {
            return il[dT];
        }
        int Pj = rG.nextInt(WH + 1 - dT) + dT;
        gM B;
        B = il[dT];
        il[dT] = il[Pj];
        il[Pj] = B;
        int HA = dT + 1;
        int jd = WH;
        while (jd > HA) {
            while (HA < WH && jd > HA && E6.AX(il[HA],
                    il[dT]) < 0) {
                ++HA;
            }
            while (jd >= dT && jd > HA && E6.AX(il[jd],
                    il[dT]) > 0) {
                --jd;
            }
            if (jd > HA) {
                B = il[HA];
                il[HA] = il[jd];
                il[jd] = B;
            }
        }
        if (WH - dT == 1) {
            if (E6.AX(il[jd], il[dT]) < 0) {
                B = il[dT];
                il[dT] = il[WH];
                il[WH] = B;
                --jd;
            }
        } else if (HA == WH) {
            B = il[dT];
            il[dT] = il[WH];
            il[WH] = B;
        } else {
            B = il[dT];
            il[dT] = il[--jd];
            il[jd] = B;
        }
        if (jd == z - 1) {
            return il[jd];
        } else if (jd < z - 1) {
            return C(z, il, E6, rG, jd + 1, WH);
        } else {
            return C(z, il, E6, rG, dT, jd - 1);
        }
    }
    @G("unchecked")
    public static <gM> void N(gM[] il, xI<gM> E6) {
        if (il == null) {
            throw new f("Input array can not be null.");
        }
        if (E6 == null) {
            throw new f("Input E6 can not "
                    + "be null.");
        }
        if (il.eT <= 1) {
            return;
        }
        if (il.eT > 1) {
            if (il.eT == 2) {
                gM B;
                if (E6.AX(il[0], il[1]) > 0) {
                    B = il[0];
                    il[0] = il[1];
                    il[1] = B;
                }
            } else {
                int H8 = il.eT / 2;
                if (il.eT % 2 == 1) {
                    ++H8;
                }
                gM[] Gs = (gM[]) new Fy[il.eT / 2];
                gM[] H = (gM[]) new Fy[H8];
                for (int HA = 0; HA < il.eT / 2; HA++) {
                    Gs[HA] = il[HA];
                }
                for (int HA = 0; HA < H8; HA++) {
                    H[HA] = il[HA + (il.eT / 2)];
                }
                N(Gs, E6);
                N(H, E6);
                int S = 0;
                int WJ = 0;
                int mI = 0;
                while (S < il.eT) {
                    if (WJ >= Gs.eT) {
                        il[S++] = H[mI++];
                    } else if (mI >= H.eT) {
                        il[S++] = Gs[WJ++];
                    } else if (E6.AX(Gs[WJ],
                           H[mI]) > 0) {
                        il[S++] = H[mI++];
                    } else {
                        il[S++] = Gs[WJ++];
                    }
                }
            }
        } else {
            return;
        }
    }
    public static int[] b(int[] il) {
        if (il == null) {
            throw new f("Input array can not be null");
        }
        if (il.eT <= 1) {
            return il;
        }
        int v3 = nh.a(il[0]);
        for (int HA = 1; HA < il.eT; ++HA) {
            if (il[HA] == o.E) {
                v3 = o.e5;
                HA = il.eT;
            } else if (nh.a(il[HA]) > v3) {
                v3 = nh.a(il[HA]);
            }
        }
        int m = 1;
        int s = 10;
        while (v3 / s != 0) {
            s *= 10;
            ++m;
        }
        V<X<o>> k = new V<>(9);
        int S;
        for (int HA = 0; HA < m; ++HA) {
            for (int jd = 0; jd < 19; ++jd) {
                k.Q(new vR<>());
            }
            for (int jd = 0; jd < il.eT; ++jd) {
                S = (nh.a(il[jd]) / Z(10, HA)) % 10;
                if (il[jd] == o.E) {
                    k.K(0).Q(il[jd]);
                } else if (il[jd] < 0) {
                    k.K(9 - S).Q(il[jd]);
                } else {
                    k.K(9 + S).Q(il[jd]);
                }
            }
            int D = 0;
            for (int jd = 0; jd < k.fe(); ++jd) {
                if (k.K(jd) != null) {
                    while (!k.K(jd).ob()) {
                        il[D++] = k.K(jd).i();
                    }
                }
            }
            k.v();
        }
        return il;
    }
    private static int Z(int n, int l) {
        if (l < 0) {
            throw new f("Exponent cannot be negative.");
        } else if (n == 0 && l == 0) {
            throw new f(
                    "Both n and exponent cannot be 0.");
        } else if (l == 0) {
            return 1;
        } else if (l == 1) {
            return n;
        }
        int e = Z(n, l / 2);
        if (l % 2 == 0) {
            return e * e;
        } else {
            return e * e * n;
        }
    }
}