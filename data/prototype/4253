package ru.U;
import ru.c.b;
import ru.c.p;
public class n<wP> extends YA<wP> {
	@h
	@I("hiding")
	public <wP extends w<wP>> wP[] nF(wP[] r, b V) {
		return this.nF(r, V, p.F);
	}
	@I("hiding")
	public <wP extends w<wP>> wP[] nF(wP[] r, b V, p o) {
		return this.oE(r, V, o, 0, r.LR-1);
	}
	@I("hiding")
	private <wP extends w<wP>> wP[] oE(wP[] r, b V, p o, int d, int ir) {
		if (d > ir || r.LR == 0 || r == null) {
			return r;
		}
		int g;
		if        (o == p.N) {   
			g = d;
		} else if (o == p.t) {    
			g = ir;
		} else if (o == p.T4) {  
			g = (int) (NB.D() * (ir-d+1) + d);
		} else {                             
			g = this.Q(r, d, ir);
		}
		g = this.S(r, V, g, d, ir);
		oE(r, V, o, d, g - 1);
		oE(r, V, o, g + 1, ir);
		return r;
	}
	@I("hiding")
	private <wP extends w<wP>> int S(wP[] r, b V, int o, int K, int c1) {
		this.ab(r, o, c1);
		int W = K;
		for (int j=K; j<c1; j++) {
			if ((V == b.x  && r[j].ud(r[c1]) < 0)  || 
				(V == b.iJ && r[j].ud(r[c1]) > 0)) {
				this.ab(r, W, j);
				W++;
			}
		}
		this.ab(r, W, c1);
		return W;
	}
	@I("hiding")
	private <wP extends w<wP>> int Q(wP[] r, int K, int c1) {
		int J = (K + c1) / 2;
		wP A = r[K];
		wP s = r[J];
		wP z = r[c1];
		if ((A.ud(s) <= 0 && s.ud(z) <= 0)  || 
			(z.ud(s) <= 0 && s.ud(A) <= 0)) {
			return J;
		}
		if ((A.ud(z) <= 0 || z.ud(s) <= 0)  && 
			(s.ud(z) <= 0 || z.ud(A) <= 0)) {
			return c1;
		}
		return K;
	}
}