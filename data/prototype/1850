package NX.P.Z.b.G;
import u.Z.b.U.EG;
import u.Z.b.U.D;
public class Fv<X, g> implements M8 {
    private static final String N = "The J or rr can not be null.";
    public static final int o = 8092;  
    public static final int UR = 8;
    public static final float qt = 0.75f;
    public static final int z = 1 << 30;
    public static final int yC = 2;
    public static final int SV = z / yC;
    public static final float gx = 0.95f;
    private final Is M;
    private final EG x;
    private final EG A;
    public Fv() {
        this(o, UR, qt);
    }
    public Fv(int j, int k, float lv) {
        x = new EG(0);
        A = new EG(0);
        k = en(k);
        lv = (lv < gx) ? lv : gx;
        M = C.V(k, j, lv, A, x);
    }
    public g MY(X J, g rr) {
        if (J == null || rr == null) {
            throw new c(N);
        }
        return MY(J, rr, true);
    }
    public g tK(X J, g rr) {
        if (J == null || rr == null) {
            throw new c(N);
        }
        return MY(J, rr, false);
    }
    private g MY(X J, g rr, boolean S) {
        int hashCode = Y.Gy().R(J.hashCode());
        while (true) {
            m<X, g> vn = M.K(hashCode);
            vn.VG();
            if (vn.rd()) {
                vn.w();
                continue;
            }
            else {
                try {
                    g E = null;
                    boolean h0;
                    if (vn.a()) {
                        try {
                            E = (g) vn.MY(J, rr, hashCode, S);
                            h0 = true;
                        } catch (rn H) {
                            h0 = false;
                        }
                    } else {
                        h0 = false;
                    }
                    if (!h0) {
                        E = vn.Bv(J, rr, hashCode, S);
                    }
                    return E;
                } finally {
                    vn.w();
                }
            }
        }
    }
    public boolean O(X J, g rr) {
        if (J == null || rr == null) {
            throw new c(N);
        }
        int OD = Y.Gy().R(J.hashCode());
        while (true) {
            m vn = M.K(OD);
            vn.VG();
            try {
                if (!vn.rd()) {
                    return vn.O(J, OD, rr) != null;
                }
            } finally {
                vn.w();
            }
        }
    }
    public g replace(X J, g rr) {
        if (J == null || rr == null) {
            throw new c(N);
        }
        int OD = Y.Gy().R(J.hashCode());
        while (true) {
            m vn = M.K(OD);
            vn.VG();
            try {
                if (!vn.rd()) {
                    return (g) vn.replace(J, OD, null, rr);
                }
            } finally {
                vn.w();
            }
        }
    }
    public boolean replace(X J, g B, g JL) {
        if (J == null || B == null || JL == null) {
            throw new c(N);
        }
        int OD = Y.Gy().R(J.hashCode());
        while (true) {
            m vn = M.K(OD);
            vn.VG();
            try {
                if (!vn.rd()) {
                    return vn.replace(J, OD, B, JL) != null;
                }
            } finally {
                vn.w();
            }
        }
    }
    public g d(X J) {
        if (J == null) {
            throw new c(N);
        }
        int hashCode = Y.Gy().R(J.hashCode());
        m<X, g> vn = M.K(hashCode);
        return vn.d(J, hashCode);
    }
    public g O(X J) {
        if (J == null) {
            throw new c(N);
        }
        int OD = Y.Gy().R(J.hashCode());
        while (true) {
            m<X, g> vn = M.K(OD);
            vn.VG();
            try {
                if (!vn.rd()) {
                    return (g) vn.O(J, OD, null);
                }
            } finally {
                vn.w();
            }
        }
    }
    public int h() {
        return A.d();
    }
    public int p() {
        return x.d();
    }
    public int DP() {
        return M.DP();
    }
    @Q
    public int v() {
        D<m> u1 = M.d();
        int l = f.q;
        int cm = f.cY;
        for (int r0=0; r0<u1.bO(); r0++) {
            m vn = u1.d(r0);
            if (vn instanceof y) {
                int G1 = ((y)vn).Me();
                if (G1 < l) {
                    l = G1;
                }
                if (G1 > cm) {
                    cm = G1;
                }
            }
        }
        return cm-l;
    }
    private int en (int r0) {
        int T = 1;
        while (T < r0) {
            T = T << 1;
        }
        return T;
    }
}