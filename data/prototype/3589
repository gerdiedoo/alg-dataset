package XR.k;
import Q.dL.f;
public class br {
	private br() {
	}
	public static void w1(R[] y) {
		if(y == null)
			throw new L();
		R[] jQ = new R[y.i];
		w1(y, jQ, 0, y.i - 1);
	}
	public static void w1(T[] y, f XR) {
		if(y == null)
			throw new L();
		R[] jQ = new R[y.i];
		w1(y, jQ, XR, 0, y.i - 1);
	}
	private static void w1(R[] E, R[] jQ, int z, int I) {
		if (I <= z)
			return;
		int w = z + (I - z) / 2;
		w1(E, jQ, z, w);
		w1(E, jQ, w + 1, I);
		C(E, jQ, z, w, I);
	}
	private static void w1(T[] E, T[] jQ, f XR, int z,
			int I) {
		if (I <= z)
			return;
		int w = z + (I - z) / 2;
		w1(E, jQ, XR, z, w);
		w1(E, jQ, XR, w + 1, I);
		C(E, jQ, XR, z, w, I);
	}
	private static void C(R[] E, R[] jQ, int z,
			int w, int I) {
		for (int r2 = z; r2 <= I; r2++) {
			jQ[r2] = E[r2];
		}
		int g = z, F = w + 1;
		for (int r2 = z; r2 <= I; r2++) {
			if (g > w)
				E[r2] = jQ[F++];
			else if (F > I)
				E[r2] = jQ[g++];
			else if (W(jQ[F], jQ[g]))
				E[r2] = jQ[F++];
			else
				E[r2] = jQ[g++];
		}
	}
	private static void C(T[] E, T[] jQ, f XR, int z,
			int w, int I) {
		for (int r2 = z; r2 <= I; r2++) {
			jQ[r2] = E[r2];
		}
		int g = z, F = w + 1;
		for (int r2 = z; r2 <= I; r2++) {
			if (g > w)
				E[r2] = jQ[F++];
			else if (F > I)
				E[r2] = jQ[g++];
			else if (W(XR, jQ[F], jQ[g]))
				E[r2] = jQ[F++];
			else
				E[r2] = jQ[g++];
		}
	}
	private static boolean W(R ON, R p) {
		return ON.x(p) < 0;
	}
	private static boolean W(f vR, T ON, T p) {
		return vR.fq(ON, p) < 0;
	}
	private static void V(T[] E, int g, int F) {
		T qU = E[g];
		E[g] = E[F];
		E[F] = qU;
	}
	public static void X(R[] y) {
		int o = y.i;
		for (int g = 0; g < o; g++) {
			System.out.H(y[g] + ",");
		}
	}
}