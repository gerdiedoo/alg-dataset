package m.p5.Fv;
import F.q.YT;
import F.q.s;
import F.q.M;
import F.q.Ky;
public class X<H> implements YT<H>
{
	private SJ<H> kz;
	private int Jl;
	public X() {
		kz = new SJ<H>(null, null, null);
		kz.Y = kz;
		kz.x = kz;
		Jl = 0;
	}
	public int Jl() {
		return Jl;
	}
	public boolean y() {
		return Jl == 0 ? true : false;
	}
	public boolean O(H xX) {
		SJ<H> n = kz;
		SJ<H> v = new SJ<H>(xX, n, n.x);
		n.x.Y = v;
		n.x = v;
		Jl++;
		return true;
	}
	public void O(int C, H xX) {
		SJ<H> n = kz;
		if (C == Jl) {
			n = kz;
		} else if (C >= 0 && C < Jl/2) {
			for (int sQ = 0; sQ <= C; sQ++)
				n = n.Y;
		} else if (C < Jl && C >= Jl/2) {
			for (int sQ = Jl; sQ > C; sQ--)
				n = n.x;
		} else {
			throw new tZ(
				"Index: " + C + ", Size: " + Jl);
		}
		SJ<H> v = new SJ<H>(xX, n, n.x);
		n.x.Y = v;
		n.x = v;
		Jl++;
	}
	public H r(int C) {
		SJ<H> n = kz;
		if (C >= 0 && C < Jl/2) {
			for (int sQ = 0; sQ <= C; sQ++)
				n = n.Y;
		} else if (C < Jl && C >= Jl/2) {
			for (int sQ = Jl; sQ > C; sQ--)
				n = n.x;
		} else {
			throw new tZ(
				"Index: " + C + ", Size: " + Jl);
		}
		return n.hy;
	}
	public H E(int C, H xX) {
		SJ<H> n = kz;
		if (C >= 0 && C < Jl/2) {
			for (int sQ = 0; sQ <= C; sQ++)
				n = n.Y;
		} else if (C < Jl && C >= Jl/2) {
			for (int sQ = Jl; sQ > C; sQ--)
				n = n.x;
		} else {
			throw new tZ(
				"Index: " + C + ", Size: " + Jl);
		}
		H N = n.hy;
		n.hy = xX;
		return N;
	}
	public H L(int C) {
		SJ<H> n = kz;
		if (C >= 0 && C < Jl/2) {
			for (int sQ = 0; sQ <= C; sQ++)
				n = n.Y;
		} else if (C < Jl && C >= Jl/2) {
			for (int sQ = Jl; sQ > C; sQ--)
				n = n.x;
		} else {
			throw new tZ(
				"Index: " + C + ", Size: " + Jl);
		}
		n.Y.x = n.x;
		n.x.Y = n.Y;
		Jl--;
		return n.hy;
	}
	public boolean L(wA NT) {
		SJ<H> n = kz;
		for (int sQ = 0; sQ < Jl; sQ++) {
			n = n.Y;
			if ((NT != null && NT.equals(n.hy)) ||
					(NT == null && n.hy == null)) {
				n.Y.x = n.x;
				n.x.Y = n.Y;
				Jl--;
				return true;
			}
		}
		return false;
	}
	public void E_() {
		SJ<H> n = kz;
		while (Jl > 0) {
			n.Y.x = n.x;
			n.x.Y = n.Y;
			Jl--;
		}
	}
	public int indexOf(wA NT) {
		SJ<H> n = kz;
		for (int sQ = 0; sQ < Jl; sQ++) {
			n = n.Y;
			if ((NT != null && NT.equals(n.hy)) ||
					(NT == null && n.hy == null))
				return sQ;
		}
		return -1;
	}
	public int zB(wA NT) {
		SJ<H> n = kz;
		for (int sQ = 0; sQ < Jl; sQ++) {
			n = n.x;
			if ((NT != null && NT.equals(n.hy)) ||
					(NT == null && n.hy == null))
				return Jl - 1 - sQ;
		}
		return -1;
	}
	public boolean b(wA NT) {
		return indexOf(NT) != -1 ? true : false;
	}
	public M<H> p() {
		return new Z(0);
	}
	public Ky<H> f() {
		return new Z(0);
	}
	public Ky<H> f(int C) {
		return new Z(C);
	}
	private class Z implements Ky<H> {
		private SJ<H> S;
		private SJ<H> T;
		private int D;
		Z(int C) {
			S = kz;
			T = kz;
			if (C >= 0 && C < Jl/2) {
				for (int sQ = 0; sQ <= C; sQ++)
					T = T.Y;
			} else if (C <= Jl && C >= Jl/2) {
				for (int sQ = Jl; sQ >= C; sQ--)
					T = T.x;
			} else {
				throw new tZ(
					"Index: " + C + ", Size: " + Jl);
			}
			D = C;
		}
		public boolean oa() {
			return D == Jl ? false : true;
		}
		public H Y() {
			S = T;
			T = T.Y;
			D++;
			return S.hy;
		}
		public int D() {
			return D;
		}
		public boolean w() {
			return D == 0 ? false : true;
		}
		public H a() {
			S = T;
			T = T.x;
			D--;
			return S.hy;
		}
		public int d() {
			return D;
		}
		public void E(H xX) {
			S.hy = xX;
		}
		public void O(H xX) {
			SJ<H> n = T;
			SJ<H> v = new SJ<H>(xX, n, n.x);
			n.x.Y = v;
			n.x = v;
			D++;
			Jl++;
		}
		public void L() {
			SJ<H> n = T;
			n.x.x.Y = n;
			n.x = n.x.x;
			D--;
			Jl--;
		}
	}
	public wA[] KQ() {
		wA[] NT = new wA[Jl];
		SJ<H> n = kz;
		for (int sQ = 0; sQ < Jl; sQ++) {
			n = n.Y;
			NT[sQ] = n.hy;
		}
		return NT;
	} 
	public <G> G[] KQ(G[] ni) {
		if (ni.l1 < Jl)
			ni = (G[])F.t.iW.Jn.l(
				ni.c3().k(), Jl);
		SJ<H> n = kz;
		for (int sQ = 0; sQ < Jl; sQ++) {
			n = n.Y;
			ni[sQ] = (G)n.hy;
		}
		return ni;
	}
	public boolean x7(s<? extends wA> bG) {
		M<? extends wA> sQ = bG.p();
		while (sQ.oa())
			if (!b(sQ.Y()))
				return false;
		return true;
	}
	public boolean i3(s<? extends H> bG) {
		SJ<H> n = kz;
		M<? extends H> sQ = bG.p();
		while (sQ.oa()) {
			SJ<H> v =
				new SJ<H>((H)sQ.Y(), n, n.x);
			n.x.Y = v;
			n.x = v;
			Jl++;
		}
		return true;
	}
	public boolean i3(int C, s<? extends H> bG) {
		SJ<H> n = kz;
		if (C == Jl) {
			n = kz;
		} else if (C >= 0 && C < Jl/2) {
			for (int sQ = 0; sQ <= C; sQ++)
				n = n.Y;
		} else if (C < Jl && C >= Jl/2) {
			for (int sQ = Jl; sQ > C; sQ--)
				n = n.x;
		} else {
			throw new tZ(
				"Index: " + C + ", Size: " + Jl);
		}
		M<? extends H> sQ = bG.p();
		while (sQ.oa()) {
			SJ<H> v =
				new SJ<H>((H)sQ.Y(), n, n.x);
			n.x.Y = v;
			n.x = v;
			Jl++;
		}
		return true;
	}	
	public boolean Lb(s<?> bG) {
		SJ<H> n = kz;
		for (int sQ = 0, Gl = Jl; sQ < Gl; sQ++) {
			n = n.Y;
			if (bG.b(n.hy)) {
				n.Y.x = n.x;
				n.x.Y = n.Y;
				Jl--;
			}
		}
		return true;
	}
	public boolean V(s<?> bG) {
		SJ<H> n = kz;
		for (int sQ = 0, Gl = Jl; sQ < Gl; sQ++) {
			n = n.Y;
			if (!bG.b(n.hy)) {
				n.Y.x = n.x;
				n.x.Y = n.Y;
				Jl--;
			}
		}
		return true;
	}
	public YT<H> vo(int U, int A) {
		throw new MQ();
	}
	public boolean equals(wA NT) {
		if (NT == this)
			return true;
		if (!(NT instanceof YT))
			return false;
		M<H> sQ = p();
		M<?> j = ((YT<?>) NT).p();
		while (sQ.oa() && j.oa()) {
			H hy = sQ.Y();
			wA tA = j.Y();
			if (!(tA != null && tA.equals(hy)) ||
					(tA == null && hy == null))
				return false;
		}
		return !(sQ.oa() || j.oa());
	}
	public int hashCode() {
		int W = 1;
		M<H> sQ = p();
		while (sQ.oa()) {
			H hy = sQ.Y();
			W = 31*W + (hy == null ? 0 : hy.hashCode());
		}
		return W;
	}
	private static class SJ<H> {
		H hy;
		SJ<H> Y;
		SJ<H> x;
		SJ(H xX, SJ<H> n, SJ<H> R) {
			hy = xX;
			Y = n;
			x = R;
		}
	}
}