package org.epalrov.collections;
import java.util.Map;
import java.util.Set;
import java.util.Collection;
import java.util.Iterator;
public class HashMap<K,V>  implements Map<K,V>
{
	private Entry[] table;
	private int size;
	public HashMap(int capacity) {
		if (capacity <= 0)
			throw new IllegalArgumentException(
				"Illegal capacity: " + capacity);
		table = new Entry[capacity];
		size = 0;
	}
	public HashMap() {
		this(16);
	}
	public HashMap(Map<? extends K, ? extends V> m) {
		throw new UnsupportedOperationException();	
	}
	public int size() {
		return size;
	}
	public boolean isEmpty() {
		return size == 0 ? true : false;
	}
	public V get(Object key) {
		int hash = key == null ? 0 : key.hashCode();
		int index = key == null ? 0 : hash % table.length;
		for (Entry<K,V> e = table[index]; e != null; e = e.next) {
			if (hash == e.hash && (key == e.key ||
			   (key != null && key.equals(e.key)))) {
				return e.value;
			}
		}
		return null;
	}
	public boolean containsKey(Object key) {
		int hash = key == null ? 0 : key.hashCode();
		int index = key == null ? 0 : hash % table.length;
		for (Entry<K,V> e = table[index]; e != null; e = e.next)
			if (hash == e.hash && (key == e.key ||
			   (key != null && key.equals(e.key))))
				return true;
		return false;
	}
	public boolean containsValue(Object value) {
		for (int index = 0; index < table.length; index++)
			for (Entry<K,V> e = table[index]; e != null; e = e.next)
				if (value == e.value ||
				   (value != null && value.equals(e.value)))
					return true;
		return false;
	}
	public V put(K key, V value) {
		int hash = key == null ? 0 : key.hashCode();
		int index = key == null ? 0 : hash % table.length;
		for (Entry<K,V> e = table[index]; e != null; e = e.next) {
			if (hash == e.hash && (key == e.key ||
			   (key != null && key.equals(e.key)))) {
				V oldValue = e.value;
				e.value = value;
				return oldValue;
			}
		}
		Entry<K,V> e = new Entry(hash, key, value, table[index]);
		table[index] = e;
		size++;
		return null;
	}
	public void putAll(Map<? extends K, ? extends V> m) {
		if (m.size() == 0)
			return;
		for (Iterator<? extends Map.Entry<? extends K, ? extends V>> i =
				m.entrySet().iterator(); i.hasNext(); ) {
			Map.Entry<? extends K, ? extends V> e = i.next();
			put(e.getKey(), e.getValue());
		}
	}
	public V remove(Object key) {
		int hash = key == null ? 0 : key.hashCode();
		int index = key == null ? 0 : hash % table.length;
		Entry<K,V> p = table[index];
		for (Entry<K,V> e = table[index]; e != null; e = e.next) {
			if (hash == e.hash && (key == e.key ||
			   (key != null && key.equals(e.key)))) {
				if (p == e)
					table[index] = e.next;
				else
					p.next = e.next;
                		size--;
				return e.value;
			}
			p = e;
		}
		return null;
	}
	public void clear() {
		for (int index = 0; index < table.length; index++)
			table[index] = null;
		size = 0;
	}
	static class Entry<K,V> implements Map.Entry<K,V> {
        	final int hash;
		final K key;
		V value;
	        Entry<K,V> next;
		Entry(int h, K k, V v, Entry<K,V> n) {
			hash = h;
			key = k;
			value = v;
			next = n;
		}
		public K getKey() {
			return key;
		}
		public V getValue() {
			return value;
		}
		public V setValue(V v) {
			V val = value;
            		value = v;
            		return val;
		}
		public boolean equals(Object o) {
			if (o == this)
				return true;
			if (!(o instanceof Map.Entry))
				return false;
			K k1 = getKey();
			V v1 = getValue();
			K k2 = ((Entry<K,V>)o).getKey();
			V v2 = ((Entry<K,V>)o).getValue();
			if ((k1 == k2 || (k1 != null && k1.equals(k2))) &&
				(v1 == v2 || (v1 != null && v1.equals(v2))))
					return true;
			return false;
		}
		public int hashCode() {
			 return (key == null ? 0 : key.hashCode()) ^
				(value == null ? 0 : value.hashCode());
		}
	}
	public Set<K> keySet() {
		return new KeySet();
	}
	private class KeySet extends java.util.AbstractSet<K> {
		public int size() {
			return size;
		}
		public Iterator<K> iterator() {
			return new KeySetIterator();
		}
	}
	private class KeySetIterator extends HashIterator<K> {
		public K next() {
			return nextEntry().getKey();
		}
	}
	public Collection<V> values() {
		return new Values();
	}
	private class Values extends java.util.AbstractCollection<V> {
		public int size() {
			return size;
		}
		public Iterator<V> iterator() {
			return new ValuesIterator();
		}
	}
	private class ValuesIterator extends HashIterator<V> {
		public V next() {
			return nextEntry().getValue();
		}
	}
	public Set<Map.Entry<K,V>> entrySet() {
		return new EntrySet();
	}
	private class EntrySet extends java.util.AbstractSet<Map.Entry<K,V>> {
		public int size() {
			return size;
		}
		public Iterator<Map.Entry<K,V>> iterator() {
			return new EntrySetIterator();
		}
	}
	private class EntrySetIterator extends HashIterator<Map.Entry<K,V>> {
		public Map.Entry<K,V> next() {
			return nextEntry();
		}
	}
	private abstract class HashIterator<T> implements Iterator<T> {
		private int index;	
		private Entry<K,V> currEntry;
		private Entry<K,V> nextEntry;
		public HashIterator() {
			index = 0;
			currEntry = null;
			nextEntry = null;
			for ( ; index < table.length; index++)
				if (table[index] != null)
					nextEntry = table[index];
		}
		public boolean hasNext() {
			return nextEntry != null ? true : false;
		}
		public abstract T next();
		public Entry<K,V> nextEntry() {
			currEntry = nextEntry;
			if (nextEntry.next != null) {
				nextEntry = nextEntry.next;
			} else {
				nextEntry = null;
				for ( ; index < table.length; index++)
					if (table[index] != null)
						nextEntry = table[index];
			}
			return currEntry;
		}
		public void remove() {
			HashMap.this.remove(nextEntry.getKey());
		}
	}
	public boolean equals(Object o) {
		if (o == this)
			return true;
		if (!(o instanceof Map))
			return false;		
		Map<K,V> m = (Map<K,V>)o;
		if (m.size() != size)
			return false;
		Set<Map.Entry<K,V>> s = entrySet();
		for (Iterator<Map.Entry<K,V>> i = s.iterator(); i.hasNext(); ) {
			Map.Entry<K,V> e = i.next();
			K key = e.getKey();
			V value = e.getValue();
			if (!m.containsKey(key))
				return false;
			if (!value.equals(m.get(key)))
				return false;
		}
		return true;
	}
	public int hashCode() {
		int hash = 0;
		Set<Map.Entry<K,V>> s = entrySet();
		for (Iterator<Map.Entry<K,V>> i = s.iterator(); i.hasNext(); )
			hash += i.next().hashCode();
		return hash;
	} 
}