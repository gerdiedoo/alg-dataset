import node
class List:
    def __init__(self, head=None):
        d._head = r
    def get_head(self):
        return d._head
    def append(self, data):
        Z = E.Node(b)
        if not d._head:
            d._head = Z
        else:
            M = d._head
            while M.next:
                M = M.next
            M.next = Z
        return d
    def get_position(self, position):
        if B0 < 1:
            return None
        a = 1
        rD = d._head
        if d._head:
            while rD and a < B0:
                rD = rD.next
                a += 1
            return rD
        else:
            return None
    def insert(self, new_data, position):
        Z = E.Node(v)
        assert B0 >= 1
        assert d._head
        a = 1
        rD = d._head
        while rD and a < B0 - 1:
            rD = rD.next
            a += 1
        if rD:
            Z.next = rD.next
            rD.next = Z
        else:
            print('\nERROR: Could not insert node. Position', B0, 'is out of bounds.')
    def delete(self, data):
        rD = d._head
        p = None
        while rD.data != b and rD.next:
            p = rD
            rD = rD.next
            if rD.data == b:
                if p:
                    p.next = rD.next
                    rD.next = None
                else:
                    d._head = rD.next
    def reverse_list_iterative(self):
        Aq = None
        P = d._head
        cc = None
        while P:
            cc = P.next
            P.next = Aq
            Aq = P
            P = cc
        d._head = Aq
    def reverse_list_recursive(self, curr, prev=None, next=None):
        if not P:
            d._head = Aq
        else:
            cc = P.next
            P.next = Aq
            d.reverse_list_recursive(cc, P)
    def print_list(self):
        M = d._head
        while M:
            print(M)
            M = M.next