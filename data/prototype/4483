package Pd.E.fx;
import gT.Dr.o;
public class Ve {
    public static <nH extends a<nH>> void rd(nH[] xI) {
        rd(xI, 0, xI.L - 1);
    }
    private static <nH extends a<nH>> void rd(
            nH[] xI, int Wx, int Q) {
        if (Wx < Q) {
            int f = G(xI, Wx, Q);
            rd(xI, Wx, f - 1);
            rd(xI, f + 1, Q);
        }
    }
    private static <nH extends a<nH>> int G(
            nH[] xI, int Wx, int Q) {
        nH f = xI[Q];
        int k9 = Wx;
        for (int aD = k9; aD < Q; aD++) {
            if (xI[aD].x(f) <= 0) {
                He(xI, aD, k9++);
            }
        }
        He(xI, Q, k9);
        return k9;
    }
    private static <nH extends a<nH>> void He(
            nH[] xI, int H, int U) {
        if (H != U) {
            nH Z = xI[H];
            xI[H] = xI[U];
            xI[U] = Z;
        }
    }
    private static o bJ = new o();
    public static <nH extends a<nH>> void rV(nH[] xI) {
        rV(xI, 0, xI.L - 1);
    }
    private static <nH extends a<nH>> void rV(
            nH[] xI, int Wx, int Q) {
        if (Wx < Q) {
            int f = pW(xI, Wx, Q);
            rV(xI, Wx, f - 1);
            rV(xI, f + 1, Q);
        }
    }
    private static <nH extends a<nH>> int pW(
            nH[] xI, int Wx, int Q) {
        int f = Wx + bJ.nextInt(Q - Wx);
        He(xI, Q, f);
        return G(xI, Wx, Q);
    }
}