package com.epublica.java;
import java.util.AbstractMap;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.LinkedHashSet;
import java.util.Map;
import java.util.Set;
import java.util.WeakHashMap;
import java.lang.ref.ReferenceQueue;
import java.lang.ref.WeakReference;
public class WeakValueHashMap<K,V> extends AbstractMap<K,V> {
	private HashMap<K, WeakValue<V>> references;
	private ReferenceQueue<V> gcQueue;
	public WeakValueHashMap(int capacity) {
		references = new HashMap<K, WeakValue<V>>(capacity);
		gcQueue = new ReferenceQueue<V>();
	}
	public WeakValueHashMap() {
		this(1);
	}
	public WeakValueHashMap(Map<? extends K, ? extends V> map) {
		this(map.size());
		for (Map.Entry<? extends K, ? extends V> entry : map.entrySet() ) {
			put(entry.getKey(), entry.getValue());
		}
	}
	@Override
	public V put(K key, V value) {
		processQueue();
		WeakValue<V> valueRef = new WeakValue<V>(key, value, gcQueue);
		return getReferenceValue(references.put(key, valueRef));
	};
	@Override
	public V get(Object key) {
		processQueue();
		return getReferenceValue(references.get(key));
	}
	@Override
	public V remove(Object key) {
		return getReferenceValue(references.get(key));
	}
	@Override
	public void clear() {
		references.clear();
	}
	@Override
	public boolean containsKey(Object key) {
		processQueue();
		return references.containsKey(key);
	}
	@Override
	public boolean containsValue(Object value) {
		processQueue();
		for (Map.Entry<K, WeakValue<V>> entry : references.entrySet()) {
			if (value == getReferenceValue(entry.getValue())) {
				return true;
			}
		}
		return false;
	}
	@Override
	public Set<K> keySet() {
		processQueue();
		return references.keySet();
	}
	@Override
	public int size() {
		processQueue();
		return references.size();
	}
	@Override
	public Set<Map.Entry<K,V>> entrySet() {
		processQueue();
		Set<Map.Entry<K,V>> entries = new LinkedHashSet<Map.Entry<K,V>>();
		for (Map.Entry<K,WeakValue<V>> entry : references.entrySet()) {
			entries.add(new AbstractMap.SimpleEntry<K,V>(entry.getKey(), getReferenceValue(entry.getValue())));
		}
		return entries;
	}
	public Collection<V> values() {
		processQueue();
		Collection<V> values = new ArrayList<V>();
		for (WeakValue<V> valueRef : references.values()) {
			values.add(getReferenceValue(valueRef));
		}
		return values;
	}
	private V getReferenceValue(WeakValue<V> valueRef) {
		return valueRef == null ? null : valueRef.get();
	}
	@SuppressWarnings("unchecked")
	private void processQueue() {
		WeakValue<V> valueRef;
		while ( (valueRef = (WeakValue<V>) gcQueue.poll()) != null ) {
			references.remove(valueRef.getKey());
		}
	}
	private class WeakValue<T> extends WeakReference<T> {
		private final K key;
		private WeakValue(K key, T value, ReferenceQueue<T> queue) {
			super(value, queue);
			this.key = key;
		}
		private K getKey() {
			return key;
		}
	}
}