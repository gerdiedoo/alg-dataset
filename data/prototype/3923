package d;
import I.L.N;
import Kc.g;
import Kc.f;
public class d {
	@mC("rawtypes")
	private static z4[] S;
	private static byte[] E;
	private static char[] DR;
	private static short[] O;
	private static int[] k;
	private static long[] b;
	private static float[] J;
	private static double[] W;
	public static void H(byte[] Ux) {
		E = new byte[Ux.l1];
		H(Ux, 0, Ux.l1 - 1);
		E = null;
	}
	private static void H(byte[] Ux, int zj, int A) {
		for (int w = 1; w <= A; w += w) {
			for (int z = 0; z <= A - w; z += (2 * w)) {
				int Ng = WM.B(z + (2 * w) - 1, A);
				V(Ux, z, z + w - 1, Ng);
			}
		}
	}
	private static void V(byte[] Ux, int zj, int L7, int A) {
		int z = zj;
		int Mk = L7 + 1;
		int mS = zj;
		while (z <= L7 && Mk <= A) {
			if (Ux[z] <= Ux[Mk]) {
				E[mS++] = Ux[z++];
			}
			else {
				E[mS++] = Ux[Mk++];
			}
		}
		if (z > L7) {
			while (Mk <= A) {
				E[mS++] = Ux[Mk++];
			}
		} else {
			while (z <= L7) {
				E[mS++] = Ux[z++];
			}
		}
		System.Rz(E, zj, Ux, zj, A - zj + 1);
	}
	public static void H(char[] Ux) {
		DR = new char[Ux.l1];
		H(Ux, 0, Ux.l1 - 1);
		DR = null;
	}
	private static void H(char[] Ux, int zj, int A) {
		for (int w = 1; w <= A; w += w) {
			for (int z = 0; z <= A - w; z += (2 * w)) {
				int Ng = WM.B(z + (2 * w) - 1, A);
				V(Ux, z, z + w - 1, Ng);
			}
		}
	}
	private static void V(char[] Ux, int zj, int L7, int A) {
		int z = zj;
		int Mk = L7 + 1;
		int mS = zj;
		while (z <= L7 && Mk <= A) {
			if (Ux[z] <= Ux[Mk]) {
				DR[mS++] = Ux[z++];
			}
			else {
				DR[mS++] = Ux[Mk++];
			}
		}
		if (z > L7) {
			while (Mk <= A) {
				DR[mS++] = Ux[Mk++];
			}
		} else {
			while (z <= L7) {
				DR[mS++] = Ux[z++];
			}
		}
		System.Rz(DR, zj, Ux, zj, A - zj + 1);
	}
	public static void H(short[] Ux) {
		O = new short[Ux.l1];
		H(Ux, 0, Ux.l1 - 1);
		O = null;
	}
	private static void H(short[] Ux, int zj, int A) {
		for (int w = 1; w <= A; w += w) {
			for (int z = 0; z <= A - w; z += (2 * w)) {
				int Ng = WM.B(z + (2 * w) - 1, A);
				V(Ux, z, z + w - 1, Ng);
			}
		}
	}
	private static void V(short[] Ux, int zj, int L7, int A) {
		int z = zj;
		int Mk = L7 + 1;
		int mS = zj;
		while (z <= L7 && Mk <= A) {
			if (Ux[z] <= Ux[Mk]) {
				O[mS++] = Ux[z++];
			}
			else {
				O[mS++] = Ux[Mk++];
			}
		}
		if (z > L7) {
			while (Mk <= A) {
				O[mS++] = Ux[Mk++];
			}
		} else {
			while (z <= L7) {
				O[mS++] = Ux[z++];
			}
		}
		System.Rz(O, zj, Ux, zj, A - zj + 1);
	}
	public static void H(int[] Ux) {
		k = new int[Ux.l1];
		H(Ux, 0, Ux.l1 - 1);
		k = null;
	}
	private static void H(int[] Ux, int zj, int A) {
		for (int w = 1; w <= A; w += w) {
			for (int z = 0; z <= A - w; z += (2 * w)) {
				int Ng = WM.B(z + (2 * w) - 1, A);
				V(Ux, z, z + w - 1, Ng);
			}
		}
	}
	private static void V(int[] Ux, int zj, int L7, int A) {
		int z = zj;
		int Mk = L7 + 1;
		int mS = zj;
		while (z <= L7 && Mk <= A) {
			if (Ux[z] <= Ux[Mk]) {
				k[mS++] = Ux[z++];
			}
			else {
				k[mS++] = Ux[Mk++];
			}
		}
		if (z > L7) {
			while (Mk <= A) {
				k[mS++] = Ux[Mk++];
			}
		} else {
			while (z <= L7) {
				k[mS++] = Ux[z++];
			}
		}
		System.Rz(k, zj, Ux, zj, A - zj + 1);
	}
	public static void H(long[] Ux) {
		b = new long[Ux.l1];
		H(Ux, 0, Ux.l1 - 1);
		b = null;
	}
	private static void H(long[] Ux, int zj, int A) {
		for (int w = 1; w <= A; w += w) {
			for (int z = 0; z <= A - w; z += (2 * w)) {
				int Ng = WM.B(z + (2 * w) - 1, A);
				V(Ux, z, z + w - 1, Ng);
			}
		}
	}
	private static void V(long[] Ux, int zj, int L7, int A) {
		int z = zj;
		int Mk = L7 + 1;
		int mS = zj;
		while (z <= L7 && Mk <= A) {
			if (Ux[z] <= Ux[Mk]) {
				b[mS++] = Ux[z++];
			}
			else {
				b[mS++] = Ux[Mk++];
			}
		}
		if (z > L7) {
			while (Mk <= A) {
				b[mS++] = Ux[Mk++];
			}
		} else {
			while (z <= L7) {
				b[mS++] = Ux[z++];
			}
		}
		System.Rz(b, zj, Ux, zj, A - zj + 1);
	}
	public static void H(float[] Ux) {
		J = new float[Ux.l1];
		H(Ux, 0, Ux.l1 - 1);
		J = null;
	}
	private static void H(float[] Ux, int zj, int A) {
		for (int w = 1; w <= A; w += w) {
			for (int z = 0; z <= A - w; z += (2 * w)) {
				int Ng = WM.B(z + (2 * w) - 1, A);
				V(Ux, z, z + w - 1, Ng);
			}
		}
	}
	private static void V(float[] Ux, int zj, int L7, int A) {
		int z = zj;
		int Mk = L7 + 1;
		int mS = zj;
		while (z <= L7 && Mk <= A) {
			if (Ux[z] <= Ux[Mk]) {
				J[mS++] = Ux[z++];
			}
			else {
				J[mS++] = Ux[Mk++];
			}
		}
		if (z > L7) {
			while (Mk <= A) {
				J[mS++] = Ux[Mk++];
			}
		} else {
			while (z <= L7) {
				J[mS++] = Ux[z++];
			}
		}
		System.Rz(J, zj, Ux, zj, A - zj + 1);
	}
	public static void H(double[] Ux) {
		W = new double[Ux.l1];
		H(Ux, 0, Ux.l1 - 1);
		W = null;
	}
	private static void H(double[] Ux, int zj, int A) {
		for (int w = 1; w <= A; w += w) {
			for (int z = 0; z <= A - w; z += (2 * w)) {
				int Ng = WM.B(z + (2 * w) - 1, A);
				V(Ux, z, z + w - 1, Ng);
			}
		}
	}
	private static void V(double[] Ux, int zj, int L7, int A) {
		int z = zj;
		int Mk = L7 + 1;
		int mS = zj;
		while (z <= L7 && Mk <= A) {
			if (Ux[z] <= Ux[Mk]) {
				W[mS++] = Ux[z++];
			}
			else {
				W[mS++] = Ux[Mk++];
			}
		}
		if (z > L7) {
			while (Mk <= A) {
				W[mS++] = Ux[Mk++];
			}
		} else {
			while (z <= L7) {
				W[mS++] = Ux[z++];
			}
		}
		System.Rz(W, zj, Ux, zj, A - zj + 1);
	}
	public static void H(pa[] Ux) {
		H(Ux, 0, Ux.l1 - 1);
	}
	private static void H(pa[] Ux, int zj, int A) {
		S = new z4[Ux.l1];
		for (int w = 1; w <= A; w += w) {
			for (int z = 0; z <= A - w; z += (2 * w)) {
				int Ng = WM.B(z + (2 * w) - 1, A);
				V((z4[])Ux, z, z + w - 1, Ng);
			}
		}
		S = null;
	}
	@mC({ "unchecked", "rawtypes" })
	private static void V(z4[] Ux, int zj, int L7, int A) {
		int z = zj;
		int Mk = L7 + 1;
		int mS = zj;
		while (z <= L7 && Mk <= A) {
			if (Ux[z].mw(Ux[Mk]) <= 0) {
				S[mS++] = Ux[z++];
			}
			else {
				S[mS++] =  Ux[Mk++];
			}
		}
		if (z > L7) {
			while (Mk <= A) {
				S[mS++] = Ux[Mk++];
			}
		} else {
			while (z <= L7) {
				S[mS++] = Ux[z++];
			}
		}
		System.Rz(S, zj, Ux, zj, A - zj + 1);
	}
	public static <C> void H(C[] Ux, N<? super C> j) {
		if(j == null) {
			H(Ux, 0, Ux.l1 - 1);
		}
		else {
			H(Ux, 0, Ux.l1 - 1, j);
		}
	}
	private static <C> void H(C[] Ux, int zj, int A, N<? super C> j) {
		S = new z4[Ux.l1];
		for (int w = 1; w <= A; w += w) {
			for (int z = 0; z <= A - w; z += (2 * w)) {
				int Ng = WM.B(z + (2 * w) - 1, A);
				V(Ux, z, z + w - 1, Ng, j);
			}
		}
		S = null;
	}
	@mC({ "rawtypes" })
	private static <C> void V(C[] Ux, int zj, int L7, int A , N<? super C> j) {
		int z = zj;
		int Mk = L7 + 1;
		int mS = zj;
		while (z <= L7 && Mk <= A) {
			if (j.oN(Ux[z], Ux[Mk]) <= 0) {
				S[mS++] =  (z4) Ux[z++];
			}
			else {
				S[mS++] =  (z4) Ux[Mk++];
			}
		}
		if (z > L7) {
			while (Mk <= A) {
				S[mS++] = (z4) Ux[Mk++];
			}
		} else {
			while (z <= L7) {
				S[mS++] = (z4) Ux[z++];
			}
		}
		System.Rz(S, zj, Ux, zj, A - zj + 1);
	}
	public static void H(byte[] Ux, boolean a) {
		if(a) {
			M[] Y = g.uH(Ux);
			H(Y, f.c());
			g.r(Y, Ux);
		}
		else {
			H(Ux);
		}
	}
	public static void H(char[] Ux, boolean a) {
		if(a) {
			T[] Y = g.oQ(Ux);
			H(Y, f.c());
			g.D(Y, Ux);
		}
		else {
			H(Ux);
		}
	}
	public static void H(short[] Ux, boolean a) {
		if(a) {
			x[] Y = g.Q(Ux);
			H(Y, f.c());
			g.F(Y, Ux);
		}
		else {
			H(Ux);
		}
	}
	public static void H(int[] Ux, boolean a) {
		if(a) {
			q[] Y = g.s(Ux);
			H(Y, f.c());
			g.n(Y, Ux);
		}
		else {
			H(Ux);
		}
	}
	public static void H(long[] Ux, boolean a) {
		if(a) {
			o[] Y = g.u(Ux);
			H(Y, f.c());
			g.KS(Y, Ux);
		}
		else {
			H(Ux);
		}
	}
	public static void H(float[] Ux, boolean a) {
		if(a) {
			U[] Y = g.m(Ux);
			H(Y, f.c());
			g.t(Y, Ux);
		}
		else {
			H(Ux);
		}
	}
	public static void H(double[] Ux, boolean a) {
		if(a) {
			v[] Y = g.p(Ux);
			H(Y, f.c());
			g.nw(Y, Ux);
		}
		else {
			H(Ux);
		}
	}
}