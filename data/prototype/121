package main;
import java.util.LinkedList;
public class RedBlackTree<K extends Comparable<? super K>, V> {
    public TreeNode<K, V> root;
    public void leftRotate(TreeNode<K, V> x) {  
        TreeNode<K, V> y = x.right;
        x.right = y.left;
        if(y.left != null)y.left.parent = x;
        y.parent = x.parent;
        if (x.parent == null) {
            assert this.root == x;
            root = y;
        } else if (x == x.parent.left) {
            x.parent.left = y;
        } else {
            x.parent.right = y;
        }
        y.left = x;
        x.parent = y;
    }
    public void rightRotate(TreeNode<K, V> y) {  
        TreeNode<K, V> x = y.left;
        y.left = x.right;
        if(x.right != null)x.right.parent = y;
        x.parent = y.parent;
        if (y.parent == null) {
            assert this.root == y;
            this.root = x;
        } else if (y == y.parent.right) {
            y.parent.right = x;
        } else {
            y.parent.left = x;
        }
        x.right = y;
        y.parent = x;
    }
    public V insert(K key, V val) {
        if(key == null) return null;
        TreeNode<K, V> y = null;
        TreeNode<K, V> x = this.root;
        while (x != null) {
            y = x;
            if (key.compareTo(x.key) == -1) {
                x = x.left;
            } else if (key.compareTo(x.key) == 1) {
                x = x.right;
            } else {
                x.val = val;
                return val;
            }
        }
        TreeNode<K, V> z = new TreeNode<>(Color.RED, key, val);
        z.parent = y;
        if (y == null) {
            root = z;
        } else if (z.key.compareTo(y.key) == -1) {
            y.left = z;
        } else {
            y.right = z;
        }
        insertFixup(z);
        return val;
    }
    public void insertFixup(TreeNode<K, V> z) {
        while (z.parent != null && z.parent.parent != null && z.parent.color == Color.RED) {
            if (z.parent == z.parent.parent.left) {
                TreeNode<K, V> y = z.parent.parent.right;
                if (y != null && y.color == Color.RED) {
                    z.parent.color = Color.BLACK;
                    y.color = Color.BLACK;
                    z.parent.parent.color = Color.RED;
                    z = z.parent.parent;
                } else {
                    if (z == z.parent.right) {
                        z = z.parent;
                        leftRotate(z);
                    }
                    z.parent.color = Color.BLACK;
                    z.parent.parent.color = Color.RED;
                    rightRotate(z.parent.parent);
                }
            } else {
                TreeNode<K, V> y = z.parent.parent.left;
                if (y != null && y.color == Color.RED) {
                    z.parent.color = Color.BLACK;
                    y.color = Color.BLACK;
                    z.parent.parent.color = Color.RED;
                    z = z.parent.parent;
                } else {
                    if (z == z.parent.left) {
                        z = z.parent;
                        rightRotate(z);
                    }
                    z.parent.color = Color.BLACK;
                    z.parent.parent.color = Color.RED;
                    leftRotate(z.parent.parent);
                }
            }
        }
        this.root.color = Color.BLACK;
    }
    public TreeNode<K, V> higherEntry(K key){
        TreeNode<K, V> x = this.find(key);
        if(x == null) return null;
        if(x.right != null){
            x = x.right;
            while(x.left != null){
                x = x.left;
            }
            return x;
        }else{
            while(x.parent != null){
                if(x.parent.left == x)return x;
                x = x.parent;
            }
            return null;
        }
    }
    public TreeNode<K, V> find(K key){
        TreeNode<K, V> x = this.root;
        while(x != null){
            if(key.compareTo(x.key) == 0){
                return x;
            }else if(key.compareTo(x.key) == -1){
                x = x.left;
            }else{
                x = x.right;
            }
        }
        return null;
    }
    public V get(K key){
        TreeNode<K,V> res = find(key);
        if(res == null) return null;
        return res.val;
    }
    public TreeNode<K, V> getMinimum(TreeNode<K, V> x){
        if(x == null) return null;
        while(x.left != null) x = x.left;
        return x;
    }
    public TreeNode<K, V> getSuccessor(TreeNode<K, V> x){
        if(x == null) return null;
        if(x.right != null){
            return getMinimum(x.right);
        }
        TreeNode<K, V> y = x.parent;
        while(y != null && x == y.right){
            x = y;
            y = y.parent;
        }
        return y;
    }
    public V delete(K key){
        if(key == null)return null;
        TreeNode<K, V> z = this.find(key);
        if(z == null){
            return null;
        }
        V removedVal = z.val;
        TreeNode<K, V> y = null;
        if(z.left == null || z.right == null){
            y = z;
        }else{
            y = getSuccessor(z);
        }
        TreeNode<K, V> x = null;
        if(y.left != null){
            x = y.left;
        }else{
            x = y.right;
        }
        if(x != null)x.parent = y.parent;
        if(y.parent == null){
            this.root = x;
        }else if(y == y.parent.left){
            y.parent.left = x;
        }else{
            y.parent.right = x;
        }
        if(y != z){
            z.key = y.key;
            z.val = y.val;
        }
        if(y.color == Color.BLACK){
            deleteFixup(x);
        }
        return removedVal;
    }
    public void deleteFixup(TreeNode<K, V> x){
        if(x == null) return;
        TreeNode<K, V> w = null;
        while(x != this.root && x.color == Color.BLACK){
            if(x == x.parent.left){
                w = x.parent.right;
                if(w.color == Color.RED){
                    w.color = Color.BLACK;
                    x.parent.color = Color.RED;
                    leftRotate(x.parent);
                    w = x.parent.right;
                }
                if((w.left == null || w.left.color == Color.BLACK) && (w.right == null || w.right.color == Color.BLACK)){
                    w.color = Color.RED;
                    x = x.parent;
                }else if(w.right == null || w.right.color == Color.BLACK){
                    if(w.left != null)w.left.color = Color.BLACK;
                    w.color = Color.RED;
                    rightRotate(w);
                    w = x.parent.right;
                    x.parent.color = Color.BLACK;
                    if(w.right != null)w.right.color = Color.BLACK;
                    leftRotate(x.parent);
                    x = this.root;
                }
            }else{
                w = x.parent.left;
                if(w.color == Color.RED){
                    w.color = Color.BLACK;
                    x.parent.color = Color.RED;
                    rightRotate(x.parent);
                    w = x.parent.left;
                }
                if((w.right == null ||w.right.color == Color.BLACK) && (w.left == null || w.left.color == Color.BLACK)){
                    w.color = Color.RED;
                    x = x.parent;
                }else if(w.left == null || w.left.color == Color.BLACK){
                    if(w.right != null)w.right.color = Color.BLACK;
                    w.color = Color.RED;
                    leftRotate(w);
                    w = x.parent.left;
                    x.parent.color = Color.BLACK;
                    if(w.left != null)w.left.color = Color.BLACK;
                    rightRotate(x.parent);
                    x = this.root;
                }
            }
        }
        x.color = Color.BLACK;
    }
    @Override
    public String toString(){
        LinkedList<TreeNode<K, V>> queue = new LinkedList<>();
        StringBuilder sb = new StringBuilder();
        queue.addLast(root);
        while(!queue.isEmpty()){
            int size = queue.size();
            while(size != 0){
                TreeNode<K, V> node = queue.removeFirst();
                size--;
                if(node == null){
                    sb.append("#,");
                }else{
                    sb.append(node.key.toString());
                    sb.append("(");
                    sb.append(node.val.toString());
                    sb.append(",");
                    sb.append(node.color);
                    sb.append(")");
                    sb.append(",");
                    queue.addLast(node.left);
                    queue.addLast(node.right);
                }
            }
        }
        return sb.toString();
    }
}