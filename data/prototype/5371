package qn.o6.hO;
import xE.Z.d6;
import xE.Z.NL;
import xE.Z.k;
import xE.Z.B;
public class X<o3> implements d6<o3>
{
	private g<o3> x_;
	private int F;
	public X() {
		x_ = new g<o3>(null, null, null);
		x_.Y = x_;
		x_.G0 = x_;
		F = 0;
	}
	public int F() {
		return F;
	}
	public boolean b() {
		return F == 0 ? true : false;
	}
	public boolean L(o3 e) {
		g<o3> Bp = x_;
		g<o3> v = new g<o3>(e, Bp, Bp.G0);
		Bp.G0.Y = v;
		Bp.G0 = v;
		F++;
		return true;
	}
	public void L(int i, o3 e) {
		g<o3> Bp = x_;
		if (i == F) {
			Bp = x_;
		} else if (i >= 0 && i < F/2) {
			for (int S = 0; S <= i; S++)
				Bp = Bp.Y;
		} else if (i < F && i >= F/2) {
			for (int S = F; S > i; S--)
				Bp = Bp.G0;
		} else {
			throw new W(
				"Index: " + i + ", Size: " + F);
		}
		g<o3> v = new g<o3>(e, Bp, Bp.G0);
		Bp.G0.Y = v;
		Bp.G0 = v;
		F++;
	}
	public o3 pq(int i) {
		g<o3> Bp = x_;
		if (i >= 0 && i < F/2) {
			for (int S = 0; S <= i; S++)
				Bp = Bp.Y;
		} else if (i < F && i >= F/2) {
			for (int S = F; S > i; S--)
				Bp = Bp.G0;
		} else {
			throw new W(
				"Index: " + i + ", Size: " + F);
		}
		return Bp.fr;
	}
	public o3 V(int i, o3 e) {
		g<o3> Bp = x_;
		if (i >= 0 && i < F/2) {
			for (int S = 0; S <= i; S++)
				Bp = Bp.Y;
		} else if (i < F && i >= F/2) {
			for (int S = F; S > i; S--)
				Bp = Bp.G0;
		} else {
			throw new W(
				"Index: " + i + ", Size: " + F);
		}
		o3 qO = Bp.fr;
		Bp.fr = e;
		return qO;
	}
	public o3 T(int i) {
		g<o3> Bp = x_;
		if (i >= 0 && i < F/2) {
			for (int S = 0; S <= i; S++)
				Bp = Bp.Y;
		} else if (i < F && i >= F/2) {
			for (int S = F; S > i; S--)
				Bp = Bp.G0;
		} else {
			throw new W(
				"Index: " + i + ", Size: " + F);
		}
		Bp.Y.G0 = Bp.G0;
		Bp.G0.Y = Bp.Y;
		F--;
		return Bp.fr;
	}
	public boolean T(N lp) {
		g<o3> Bp = x_;
		for (int S = 0; S < F; S++) {
			Bp = Bp.Y;
			if ((lp != null && lp.equals(Bp.fr)) ||
					(lp == null && Bp.fr == null)) {
				Bp.Y.G0 = Bp.G0;
				Bp.G0.Y = Bp.Y;
				F--;
				return true;
			}
		}
		return false;
	}
	public void tZ() {
		g<o3> Bp = x_;
		while (F > 0) {
			Bp.Y.G0 = Bp.G0;
			Bp.G0.Y = Bp.Y;
			F--;
		}
	}
	public int indexOf(N lp) {
		g<o3> Bp = x_;
		for (int S = 0; S < F; S++) {
			Bp = Bp.Y;
			if ((lp != null && lp.equals(Bp.fr)) ||
					(lp == null && Bp.fr == null))
				return S;
		}
		return -1;
	}
	public int c(N lp) {
		g<o3> Bp = x_;
		for (int S = 0; S < F; S++) {
			Bp = Bp.G0;
			if ((lp != null && lp.equals(Bp.fr)) ||
					(lp == null && Bp.fr == null))
				return F - 1 - S;
		}
		return -1;
	}
	public boolean U(N lp) {
		return indexOf(lp) != -1 ? true : false;
	}
	public k<o3> A() {
		return new z(0);
	}
	public B<o3> mI() {
		return new z(0);
	}
	public B<o3> mI(int i) {
		return new z(i);
	}
	private class z implements B<o3> {
		private g<o3> Q;
		private g<o3> uz;
		private int D;
		z(int i) {
			Q = x_;
			uz = x_;
			if (i >= 0 && i < F/2) {
				for (int S = 0; S <= i; S++)
					uz = uz.Y;
			} else if (i <= F && i >= F/2) {
				for (int S = F; S >= i; S--)
					uz = uz.G0;
			} else {
				throw new W(
					"Index: " + i + ", Size: " + F);
			}
			D = i;
		}
		public boolean w() {
			return D == F ? false : true;
		}
		public o3 Y() {
			Q = uz;
			uz = uz.Y;
			D++;
			return Q.fr;
		}
		public int D() {
			return D;
		}
		public boolean KC() {
			return D == 0 ? false : true;
		}
		public o3 p() {
			Q = uz;
			uz = uz.G0;
			D--;
			return Q.fr;
		}
		public int r() {
			return D;
		}
		public void V(o3 e) {
			Q.fr = e;
		}
		public void L(o3 e) {
			g<o3> Bp = uz;
			g<o3> v = new g<o3>(e, Bp, Bp.G0);
			Bp.G0.Y = v;
			Bp.G0 = v;
			D++;
			F++;
		}
		public void T() {
			g<o3> Bp = uz;
			Bp.G0.G0.Y = Bp;
			Bp.G0 = Bp.G0.G0;
			D--;
			F--;
		}
	}
	public N[] VZ() {
		N[] lp = new N[F];
		g<o3> Bp = x_;
		for (int S = 0; S < F; S++) {
			Bp = Bp.Y;
			lp[S] = Bp.fr;
		}
		return lp;
	} 
	public <O> O[] VZ(O[] R) {
		if (R.aw < F)
			R = (O[])xE.E.s.G.f(
				R.Rz().q(), F);
		g<o3> Bp = x_;
		for (int S = 0; S < F; S++) {
			Bp = Bp.Y;
			R[S] = (O)Bp.fr;
		}
		return R;
	}
	public boolean Tk(NL<? extends N> M) {
		k<? extends N> S = M.A();
		while (S.w())
			if (!U(S.Y()))
				return false;
		return true;
	}
	public boolean H(NL<? extends o3> M) {
		g<o3> Bp = x_;
		k<? extends o3> S = M.A();
		while (S.w()) {
			g<o3> v =
				new g<o3>((o3)S.Y(), Bp, Bp.G0);
			Bp.G0.Y = v;
			Bp.G0 = v;
			F++;
		}
		return true;
	}
	public boolean H(int i, NL<? extends o3> M) {
		g<o3> Bp = x_;
		if (i == F) {
			Bp = x_;
		} else if (i >= 0 && i < F/2) {
			for (int S = 0; S <= i; S++)
				Bp = Bp.Y;
		} else if (i < F && i >= F/2) {
			for (int S = F; S > i; S--)
				Bp = Bp.G0;
		} else {
			throw new W(
				"Index: " + i + ", Size: " + F);
		}
		k<? extends o3> S = M.A();
		while (S.w()) {
			g<o3> v =
				new g<o3>((o3)S.Y(), Bp, Bp.G0);
			Bp.G0.Y = v;
			Bp.G0 = v;
			F++;
		}
		return true;
	}	
	public boolean AC(NL<?> M) {
		g<o3> Bp = x_;
		for (int S = 0, a = F; S < a; S++) {
			Bp = Bp.Y;
			if (M.U(Bp.fr)) {
				Bp.Y.G0 = Bp.G0;
				Bp.G0.Y = Bp.Y;
				F--;
			}
		}
		return true;
	}
	public boolean iQ(NL<?> M) {
		g<o3> Bp = x_;
		for (int S = 0, a = F; S < a; S++) {
			Bp = Bp.Y;
			if (!M.U(Bp.fr)) {
				Bp.Y.G0 = Bp.G0;
				Bp.G0.Y = Bp.Y;
				F--;
			}
		}
		return true;
	}
	public d6<o3> I(int l, int ZV) {
		throw new n();
	}
	public boolean equals(N lp) {
		if (lp == this)
			return true;
		if (!(lp instanceof d6))
			return false;
		k<o3> S = A();
		k<?> j = ((d6<?>) lp).A();
		while (S.w() && j.w()) {
			o3 fr = S.Y();
			N Uw = j.Y();
			if (!(Uw != null && Uw.equals(fr)) ||
					(Uw == null && fr == null))
				return false;
		}
		return !(S.w() || j.w());
	}
	public int hashCode() {
		int t = 1;
		k<o3> S = A();
		while (S.w()) {
			o3 fr = S.Y();
			t = 31*t + (fr == null ? 0 : fr.hashCode());
		}
		return t;
	}
	private static class g<o3> {
		o3 fr;
		g<o3> Y;
		g<o3> G0;
		g(o3 e, g<o3> Bp, g<o3> XI) {
			fr = e;
			Y = Bp;
			G0 = XI;
		}
	}
}