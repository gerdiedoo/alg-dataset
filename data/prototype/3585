package P.B;
import Q.Z.KI;
public class c {
	private c() {
	}
	public static void H(W[] J) {
		if(J == null)
			throw new O();
		W[] C = new W[J.L];
		H(J, C, 0, J.L - 1);
	}
	public static void H(X[] J, KI P) {
		if(J == null)
			throw new O();
		W[] C = new W[J.L];
		H(J, C, P, 0, J.L - 1);
	}
	private static void H(W[] t, W[] C, int k, int i) {
		if (i <= k)
			return;
		int Sz = k + (i - k) / 2;
		H(t, C, k, Sz);
		H(t, C, Sz + 1, i);
		oA(t, C, k, Sz, i);
	}
	private static void H(X[] t, X[] C, KI P, int k,
			int i) {
		if (i <= k)
			return;
		int Sz = k + (i - k) / 2;
		H(t, C, P, k, Sz);
		H(t, C, P, Sz + 1, i);
		oA(t, C, P, k, Sz, i);
	}
	private static void oA(W[] t, W[] C, int k,
			int Sz, int i) {
		for (int N = k; N <= i; N++) {
			C[N] = t[N];
		}
		int s3 = k, u = Sz + 1;
		for (int N = k; N <= i; N++) {
			if (s3 > Sz)
				t[N] = C[u++];
			else if (u > i)
				t[N] = C[s3++];
			else if (FB(C[u], C[s3]))
				t[N] = C[u++];
			else
				t[N] = C[s3++];
		}
	}
	private static void oA(X[] t, X[] C, KI P, int k,
			int Sz, int i) {
		for (int N = k; N <= i; N++) {
			C[N] = t[N];
		}
		int s3 = k, u = Sz + 1;
		for (int N = k; N <= i; N++) {
			if (s3 > Sz)
				t[N] = C[u++];
			else if (u > i)
				t[N] = C[s3++];
			else if (FB(P, C[u], C[s3]))
				t[N] = C[u++];
			else
				t[N] = C[s3++];
		}
	}
	private static boolean FB(W bw, W E) {
		return bw.x(E) < 0;
	}
	private static boolean FB(KI q, X bw, X E) {
		return q.m(bw, E) < 0;
	}
	private static void w(X[] t, int s3, int u) {
		X B9 = t[s3];
		t[s3] = t[u];
		t[u] = B9;
	}
	public static void d(W[] J) {
		int hm = J.L;
		for (int s3 = 0; s3 < hm; s3++) {
			System.out.Rh(J[s3] + ",");
		}
	}
}