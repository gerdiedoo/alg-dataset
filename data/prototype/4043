package y.a.V.Z.Rd;
import y.a.V.Z.*;
public class Q implements uJ {
  private static final int g = 1 << 28;
  @h
  public void V(int[] e) {
    FH(e, 0, e.d - 1);
  }
  private void FH(int[] e, int Wt, int m_) {
    if (Wt == m_) return;
    int k = Wt + (m_ - Wt) / 2;
    FH(e, Wt, k);
    FH(e, k + 1, m_);
    L(e, Wt, k, m_);
  }
  void L(int[] e, int x, int M, int WS) {
    int tx = x;
    int U = M + 1;
    int d = WS + 1 - tx;
    int[] Y = new int[d];
    int f = 0;
    while (tx <= M && U <= WS) {
      int n = e[tx];
      int w = e[U];
      if (n <= w) {
        Y[f++] = n;
        tx++;
      } else {
        Y[f++] = w;
        U++;
      }
    }
    while (tx <= M) {
      Y[f++] = e[tx++];
    }
    while (U <= WS) {
      Y[f++] = e[U++];
    }
    System.pE(Y, 0, e, x, d);
  }
  @h
  public void V(int[] e, S K) {
    FH(e, 0, e.d - 1, K);
  }
  private void FH(int[] e, int Wt, int m_,
                         S K) {
    if (Wt == m_) return;
    int k = Wt + (m_ - Wt) / 2;
    FH(e, Wt, k, K);
    FH(e, k + 1, m_, K);
    L(e, Wt, k, m_, K);
  }
  void L(int[] e, int x, int M, int WS,
             S K) {
    int tx = x;
    int U = M + 1;
    int d = WS + 1 - tx;
    int[] Y = new int[d];
    int f = 0;
    while (tx <= M && U <= WS) {
      K.IA();
      int n = e[tx];
      int w = e[U];
      K.C(2);
      K.xW();
      K.v();
      if (n <= w) {
        Y[f++] = n;
        tx++;
      } else {
        Y[f++] = w;
        U++;
      }
    }
    while (tx <= M) {
      K.IA();
      Y[f++] = e[tx++];
      K.et();
    }
    while (U <= WS) {
      K.IA();
      Y[f++] = e[U++];
      K.et();
    }
    System.pE(Y, 0, e, x, d);
    K.p(d);
  }
  @h
  public boolean vj(int eF) {
    return eF <= g;
  }
}