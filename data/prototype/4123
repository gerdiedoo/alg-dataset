package b;
import Q.e.Y;
import s.S;
import s.o;
public class c {
	public static void H(byte[] rY) {
		W(rY, 0, rY.h8 - 1);
	}
	private static void W(byte[] rY, int M, int L) {
		if(M >= L) {
			return;
		}
		int oC = G(rY, M, L);	
		W(rY, M, oC - 1);
		W(rY, oC + 1, L);
	}
	private static int G(byte[] rY, int JD, int I) {
		int M = JD;
		int L = I;
		byte oC = rY[JD];	
		while(M < L) {
			while(rY[L] > oC) --L;
			while(rY[M] <= oC && M < L) ++M;
			f(rY, M, L);
		}
		f(rY, JD, M);
		return M;
	}
	private static void f(byte[] rY, int MI, int O) {
		byte j = rY[MI];
		rY[MI] = rY[O];
		rY[O] = j;
	}
	public static void H(char[] rY) {
		W(rY, 0, rY.h8 - 1);
	}
	private static void W(char[] rY, int M, int L) {
		if(M >= L) {
			return;
		}
		int oC = G(rY, M, L);	
		W(rY, M, oC - 1);
		W(rY, oC + 1, L);
	}
	private static int G(char[] rY, int JD, int I) {
		int M = JD;
		int L = I;
		char oC = rY[JD];	
		while(M < L) {
			while(rY[L] > oC) --L;
			while(rY[M] <= oC && M < L) ++M;
			f(rY, M, L);
		}
		f(rY, JD, M);
		return M;
	}
	private static void f(char[] rY, int MI, int O) {
		char j = rY[MI];
		rY[MI] = rY[O];
		rY[O] = j;
	}
	public static void H(short[] rY) {
		W(rY, 0, rY.h8 - 1);
	}
	private static void W(short[] rY, int M, int L) {
		if(M >= L) {
			return;
		}
		int oC = G(rY, M, L);	
		W(rY, M, oC - 1);
		W(rY, oC + 1, L);
	}
	private static int G(short[] rY, int JD, int I) {
		int M = JD;
		int L = I;
		short oC = rY[JD];	
		while(M < L) {
			while(rY[L] > oC) --L;
			while(rY[M] <= oC && M < L) ++M;
			f(rY, M, L);
		}
		f(rY, JD, M);
		return M;
	}
	private static void f(short[] rY, int MI, int O) {
		short j = rY[MI];
		rY[MI] = rY[O];
		rY[O] = j;
	}
	public static void H(int[] rY) {
		W(rY, 0, rY.h8 - 1);
	}
	private static void W(int[] rY, int M, int L) {
		if(M >= L) {
			return;
		}
		int oC = G(rY, M, L);	
		W(rY, M, oC - 1);
		W(rY, oC + 1, L);
	}
	private static int G(int[] rY, int JD, int I) {
		int M = JD;
		int L = I;
		int oC = rY[JD];	
		while(M < L) {
			while(rY[L] > oC) --L;
			while(rY[M] <= oC && M < L) ++M;
			f(rY, M, L);
		}
		f(rY, JD, M);
		return M;
	}
	private static void f(int[] rY, int MI, int O) {
		int j = rY[MI];
		rY[MI] = rY[O];
		rY[O] = j;
	}
	public static void H(long[] rY) {
		W(rY, 0, rY.h8 - 1);
	}
	private static void W(long[] rY, int M, int L) {
		if(M >= L) {
			return;
		}
		int oC = G(rY, M, L);	
		W(rY, M, oC - 1);
		W(rY, oC + 1, L);
	}
	private static int G(long[] rY, int JD, int I) {
		int M = JD;
		int L = I;
		long oC = rY[JD];	
		while(M < L) {
			while(rY[L] > oC) --L;
			while(rY[M] <= oC && M < L) ++M;
			f(rY, M, L);
		}
		f(rY, JD, M);
		return M;
	}
	private static void f(long[] rY, int MI, int O) {
		long j = rY[MI];
		rY[MI] = rY[O];
		rY[O] = j;
	}
	public static void H(float[] rY) {
		W(rY, 0, rY.h8 - 1);
	}
	private static void W(float[] rY, int M, int L) {
		if(M >= L) {
			return;
		}
		int oC = G(rY, M, L);	
		W(rY, M, oC - 1);
		W(rY, oC + 1, L);
	}
	private static int G(float[] rY, int JD, int I) {
		int M = JD;
		int L = I;
		float oC = rY[JD];	
		while(M < L) {
			while(rY[L] > oC) --L;
			while(rY[M] <= oC && M < L) ++M;
			f(rY, M, L);
		}
		f(rY, JD, M);
		return M;
	}
	private static void f(float[] rY, int MI, int O) {
		float j = rY[MI];
		rY[MI] = rY[O];
		rY[O] = j;
	}
	public static void H(double[] rY) {
		W(rY, 0, rY.h8 - 1);
	}
	private static void W(double[] rY, int M, int L) {
		if(M >= L) {
			return;
		}
		int oC = G(rY, M, L);	
		W(rY, M, oC - 1);
		W(rY, oC + 1, L);
	}
	private static int G(double[] rY, int JD, int I) {
		int M = JD;
		int L = I;
		double oC = rY[JD];	
		while(M < L) {
			while(rY[L] > oC) --L;
			while(rY[M] <= oC && M < L) ++M;
			f(rY, M, L);
		}
		f(rY, JD, M);
		return M;
	}
	private static void f(double[] rY, int MI, int O) {
		double j = rY[MI];
		rY[MI] = rY[O];
		rY[O] = j;
	}
	public static <h> void H(h[] rY, Y<? super h> Uv) {
		if(Uv == null) {
			H(rY);
		}
		else {
			W(rY, 0, rY.h8 - 1, Uv);
		}
	}
	public static void H(T[] rY) {
		W(rY, 0, rY.h8 - 1);
	}
	private static void W(T[] rY, int M, int L) {
		if(M >= L) {
			return;
		}
		int oC = G(rY, M, L);	
		W(rY, M, oC - 1);
		W(rY, oC + 1, L);
	}
	@V({ "rawtypes", "unchecked" })
	private static int G(T[] rY, int JD, int I) {
		int M = JD;
		int L = I;
		a oC = ((a) rY[JD]);	
		while(M < L) {
			while(oC.HQ(rY[L]) < 0) --L;
			while(oC.HQ(rY[M]) >= 0 && M < L) ++M;
			f(rY, M, L);
		}
		f(rY, JD, M);
		return M;
	}
	private static <h> void W(h[] rY, int M, int L, Y<? super h> Uv) {
		if(M >= L) {
			return;
		}
		int oC = G(rY, M, L, Uv);	
		W(rY, M, oC - 1, Uv);
		W(rY, oC + 1, L, Uv);
	}
	private static <h> int G(h[] rY, int JD, int I, Y<? super h> Uv) {
		int M = JD;
		int L = I;
		h oC = rY[JD];
		while(M < L) {
			while(Uv.k(oC, rY[L]) < 0) --L;
			while(Uv.k(rY[M], oC) <= 0 && M < L) ++M;
			f(rY, M, L);
		}
		f(rY, JD, M);
		return M;
	}
	private static <h> void f(h[] rY, int MI, int O) {
		h j = rY[MI];
		rY[MI] = rY[O];
		rY[O] = j;
	}
	public static void H(byte[] rY, boolean p) {
		if(p) {
			s0[] n = S.C(rY);
			H(n, o.U());
			S.DN(n, rY);
		}
		else {
			H(rY);
		}
	}
	public static void H(char[] rY, boolean p) {
		if(p) {
			Jm[] n = S.J(rY);
			H(n, o.U());
			S.D(n, rY);
		}
		else {
			H(rY);
		}
	}
	public static void H(short[] rY, boolean p) {
		if(p) {
			QT[] n = S.d(rY);
			H(n, o.U());
			S.r(n, rY);
		}
		else {
			H(rY);
		}
	}
	public static void H(int[] rY, boolean p) {
		if(p) {
			l[] n = S.au(rY);
			H(n, o.U());
			S.kT(n, rY);
		}
		else {
			H(rY);
		}
	}
	public static void H(long[] rY, boolean p) {
		if(p) {
			CA[] n = S.B(rY);
			H(n, o.U());
			S.Z(n, rY);
		}
		else {
			H(rY);
		}
	}
	public static void H(float[] rY, boolean p) {
		if(p) {
			y[] n = S.Zy(rY);
			H(n, o.U());
			S.YH(n, rY);
		}
		else {
			H(rY);
		}
	}
	public static void H(double[] rY, boolean p) {
		if(p) {
			v[] n = S.A(rY);
			H(n, o.U());
			S.z(n, rY);
		}
		else {
			H(rY);
		}
	}
}