package Z;
import i.j.k;
import s.C;
import s.n;
public class Z {
	@Db("rawtypes")
	private static t[] L;
	private static byte[] p;
	private static char[] e;
	private static short[] T;
	private static int[] pQ;
	private static long[] J;
	private static float[] YZ;
	private static double[] H;
	public static void R(byte[] a) {
		p = new byte[a.S];
		R(a, 0, a.S - 1);
		p = null;
	}
	private static void R(byte[] a, int vv, int G) {
		for (int IL = 1; IL <= G; IL += IL) {
			for (int M = 0; M <= G - IL; M += (2 * IL)) {
				int N = js.nP(M + (2 * IL) - 1, G);
				g(a, M, M + IL - 1, N);
			}
		}
	}
	private static void g(byte[] a, int vv, int IN, int G) {
		int M = vv;
		int h = IN + 1;
		int W = vv;
		while (M <= IN && h <= G) {
			if (a[M] <= a[h]) {
				p[W++] = a[M++];
			}
			else {
				p[W++] = a[h++];
			}
		}
		if (M > IN) {
			while (h <= G) {
				p[W++] = a[h++];
			}
		} else {
			while (M <= IN) {
				p[W++] = a[M++];
			}
		}
		System.U(p, vv, a, vv, G - vv + 1);
	}
	public static void R(char[] a) {
		e = new char[a.S];
		R(a, 0, a.S - 1);
		e = null;
	}
	private static void R(char[] a, int vv, int G) {
		for (int IL = 1; IL <= G; IL += IL) {
			for (int M = 0; M <= G - IL; M += (2 * IL)) {
				int N = js.nP(M + (2 * IL) - 1, G);
				g(a, M, M + IL - 1, N);
			}
		}
	}
	private static void g(char[] a, int vv, int IN, int G) {
		int M = vv;
		int h = IN + 1;
		int W = vv;
		while (M <= IN && h <= G) {
			if (a[M] <= a[h]) {
				e[W++] = a[M++];
			}
			else {
				e[W++] = a[h++];
			}
		}
		if (M > IN) {
			while (h <= G) {
				e[W++] = a[h++];
			}
		} else {
			while (M <= IN) {
				e[W++] = a[M++];
			}
		}
		System.U(e, vv, a, vv, G - vv + 1);
	}
	public static void R(short[] a) {
		T = new short[a.S];
		R(a, 0, a.S - 1);
		T = null;
	}
	private static void R(short[] a, int vv, int G) {
		for (int IL = 1; IL <= G; IL += IL) {
			for (int M = 0; M <= G - IL; M += (2 * IL)) {
				int N = js.nP(M + (2 * IL) - 1, G);
				g(a, M, M + IL - 1, N);
			}
		}
	}
	private static void g(short[] a, int vv, int IN, int G) {
		int M = vv;
		int h = IN + 1;
		int W = vv;
		while (M <= IN && h <= G) {
			if (a[M] <= a[h]) {
				T[W++] = a[M++];
			}
			else {
				T[W++] = a[h++];
			}
		}
		if (M > IN) {
			while (h <= G) {
				T[W++] = a[h++];
			}
		} else {
			while (M <= IN) {
				T[W++] = a[M++];
			}
		}
		System.U(T, vv, a, vv, G - vv + 1);
	}
	public static void R(int[] a) {
		pQ = new int[a.S];
		R(a, 0, a.S - 1);
		pQ = null;
	}
	private static void R(int[] a, int vv, int G) {
		for (int IL = 1; IL <= G; IL += IL) {
			for (int M = 0; M <= G - IL; M += (2 * IL)) {
				int N = js.nP(M + (2 * IL) - 1, G);
				g(a, M, M + IL - 1, N);
			}
		}
	}
	private static void g(int[] a, int vv, int IN, int G) {
		int M = vv;
		int h = IN + 1;
		int W = vv;
		while (M <= IN && h <= G) {
			if (a[M] <= a[h]) {
				pQ[W++] = a[M++];
			}
			else {
				pQ[W++] = a[h++];
			}
		}
		if (M > IN) {
			while (h <= G) {
				pQ[W++] = a[h++];
			}
		} else {
			while (M <= IN) {
				pQ[W++] = a[M++];
			}
		}
		System.U(pQ, vv, a, vv, G - vv + 1);
	}
	public static void R(long[] a) {
		J = new long[a.S];
		R(a, 0, a.S - 1);
		J = null;
	}
	private static void R(long[] a, int vv, int G) {
		for (int IL = 1; IL <= G; IL += IL) {
			for (int M = 0; M <= G - IL; M += (2 * IL)) {
				int N = js.nP(M + (2 * IL) - 1, G);
				g(a, M, M + IL - 1, N);
			}
		}
	}
	private static void g(long[] a, int vv, int IN, int G) {
		int M = vv;
		int h = IN + 1;
		int W = vv;
		while (M <= IN && h <= G) {
			if (a[M] <= a[h]) {
				J[W++] = a[M++];
			}
			else {
				J[W++] = a[h++];
			}
		}
		if (M > IN) {
			while (h <= G) {
				J[W++] = a[h++];
			}
		} else {
			while (M <= IN) {
				J[W++] = a[M++];
			}
		}
		System.U(J, vv, a, vv, G - vv + 1);
	}
	public static void R(float[] a) {
		YZ = new float[a.S];
		R(a, 0, a.S - 1);
		YZ = null;
	}
	private static void R(float[] a, int vv, int G) {
		for (int IL = 1; IL <= G; IL += IL) {
			for (int M = 0; M <= G - IL; M += (2 * IL)) {
				int N = js.nP(M + (2 * IL) - 1, G);
				g(a, M, M + IL - 1, N);
			}
		}
	}
	private static void g(float[] a, int vv, int IN, int G) {
		int M = vv;
		int h = IN + 1;
		int W = vv;
		while (M <= IN && h <= G) {
			if (a[M] <= a[h]) {
				YZ[W++] = a[M++];
			}
			else {
				YZ[W++] = a[h++];
			}
		}
		if (M > IN) {
			while (h <= G) {
				YZ[W++] = a[h++];
			}
		} else {
			while (M <= IN) {
				YZ[W++] = a[M++];
			}
		}
		System.U(YZ, vv, a, vv, G - vv + 1);
	}
	public static void R(double[] a) {
		H = new double[a.S];
		R(a, 0, a.S - 1);
		H = null;
	}
	private static void R(double[] a, int vv, int G) {
		for (int IL = 1; IL <= G; IL += IL) {
			for (int M = 0; M <= G - IL; M += (2 * IL)) {
				int N = js.nP(M + (2 * IL) - 1, G);
				g(a, M, M + IL - 1, N);
			}
		}
	}
	private static void g(double[] a, int vv, int IN, int G) {
		int M = vv;
		int h = IN + 1;
		int W = vv;
		while (M <= IN && h <= G) {
			if (a[M] <= a[h]) {
				H[W++] = a[M++];
			}
			else {
				H[W++] = a[h++];
			}
		}
		if (M > IN) {
			while (h <= G) {
				H[W++] = a[h++];
			}
		} else {
			while (M <= IN) {
				H[W++] = a[M++];
			}
		}
		System.U(H, vv, a, vv, G - vv + 1);
	}
	public static void R(sh[] a) {
		R(a, 0, a.S - 1);
	}
	private static void R(sh[] a, int vv, int G) {
		L = new t[a.S];
		for (int IL = 1; IL <= G; IL += IL) {
			for (int M = 0; M <= G - IL; M += (2 * IL)) {
				int N = js.nP(M + (2 * IL) - 1, G);
				g((t[])a, M, M + IL - 1, N);
			}
		}
		L = null;
	}
	@Db({ "unchecked", "rawtypes" })
	private static void g(t[] a, int vv, int IN, int G) {
		int M = vv;
		int h = IN + 1;
		int W = vv;
		while (M <= IN && h <= G) {
			if (a[M].x(a[h]) <= 0) {
				L[W++] = a[M++];
			}
			else {
				L[W++] =  a[h++];
			}
		}
		if (M > IN) {
			while (h <= G) {
				L[W++] = a[h++];
			}
		} else {
			while (M <= IN) {
				L[W++] = a[M++];
			}
		}
		System.U(L, vv, a, vv, G - vv + 1);
	}
	public static <Mk> void R(Mk[] a, k<? super Mk> K) {
		if(K == null) {
			R(a, 0, a.S - 1);
		}
		else {
			R(a, 0, a.S - 1, K);
		}
	}
	private static <Mk> void R(Mk[] a, int vv, int G, k<? super Mk> K) {
		L = new t[a.S];
		for (int IL = 1; IL <= G; IL += IL) {
			for (int M = 0; M <= G - IL; M += (2 * IL)) {
				int N = js.nP(M + (2 * IL) - 1, G);
				g(a, M, M + IL - 1, N, K);
			}
		}
		L = null;
	}
	@Db({ "rawtypes" })
	private static <Mk> void g(Mk[] a, int vv, int IN, int G , k<? super Mk> K) {
		int M = vv;
		int h = IN + 1;
		int W = vv;
		while (M <= IN && h <= G) {
			if (K.r(a[M], a[h]) <= 0) {
				L[W++] =  (t) a[M++];
			}
			else {
				L[W++] =  (t) a[h++];
			}
		}
		if (M > IN) {
			while (h <= G) {
				L[W++] = (t) a[h++];
			}
		} else {
			while (M <= IN) {
				L[W++] = (t) a[M++];
			}
		}
		System.U(L, vv, a, vv, G - vv + 1);
	}
	public static void R(byte[] a, boolean E) {
		if(E) {
			m[] o = C.A(a);
			R(o, n.ov());
			C.yn(o, a);
		}
		else {
			R(a);
		}
	}
	public static void R(char[] a, boolean E) {
		if(E) {
			z[] o = C.Qa(a);
			R(o, n.ov());
			C.D(o, a);
		}
		else {
			R(a);
		}
	}
	public static void R(short[] a, boolean E) {
		if(E) {
			Tv[] o = C.sX(a);
			R(o, n.ov());
			C.u(o, a);
		}
		else {
			R(a);
		}
	}
	public static void R(int[] a, boolean E) {
		if(E) {
			B[] o = C.y(a);
			R(o, n.ov());
			C.P(o, a);
		}
		else {
			R(a);
		}
	}
	public static void R(long[] a, boolean E) {
		if(E) {
			HC[] o = C.GO(a);
			R(o, n.ov());
			C.d(o, a);
		}
		else {
			R(a);
		}
	}
	public static void R(float[] a, boolean E) {
		if(E) {
			b[] o = C.Y(a);
			R(o, n.ov());
			C.AM(o, a);
		}
		else {
			R(a);
		}
	}
	public static void R(double[] a, boolean E) {
		if(E) {
			v[] o = C.w(a);
			R(o, n.ov());
			C.X(o, a);
		}
		else {
			R(a);
		}
	}
}