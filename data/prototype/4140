package Qp;
import F.d.r6;
import F.d.eu.h;
import o.L;
import o.U;
public class R {
	final static int p = 1 << 13;
	public static void mL(byte[] H) {
		new i.E2(H, 0, H.Yg - 1).C5();
	}
	private static final class i {	
		private static final class E2 extends h {
			private static final long G = 1L;
			final byte[] H;
			final int M;
			final int S;
			E2(byte[] H, int M, int S) {
				this.H = H;
				this.M = M;
				this.S = S;
			}
			public final void x() {
				if(M >= S) {
					return;
				}
				int f = O(H, M, S);
				if(S - M < p) {
					a(H, M, f - 1);
					a(H, f + 1, S);
				}
				else {
					E2 ys = new E2(H, M, f - 1);
					E2 Co = new E2(H, f + 1, S);
					ys.N();
					Co.x();
					ys.sP();
				}
			}
		}
		private static void a(byte[] H, int M, int S) {	
			if(M >= S) {
				return;
			}
			int f = O(H, M, S);	
			a(H, M, f - 1);
			a(H, f + 1, S);
		}
		private static int O(byte[] H, int ys, int Co) {
			int M = ys;
			int S = Co;
			byte f = H[ys];	
			while(M < S) {
				while(H[S] > f) --S;
				while(H[M] <= f && M < S) ++M;
				c(H, M, S);
			}
			c(H, ys, M);
			return M;
		}
		private static void c(byte[] H, int I, int T) {
			byte Ma = H[I];
			H[I] = H[T];
			H[T] = Ma;
		}
	}
	public static void mL(char[] H) {
		new A.E2(H, 0, H.Yg - 1).C5();
	}
	private static final class A {	
		private static final class E2 extends h {
			private static final long G = 1L;
			final char[] H;
			final int M;
			final int S;
			E2(char[] H, int M, int S) {
				this.H = H;
				this.M = M;
				this.S = S;
			}
			public final void x() {
				if(M >= S) {
					return;
				}
				int f = O(H, M, S);
				if(S - M < p) {
					a(H, M, f - 1);
					a(H, f + 1, S);
				}
				else {
					E2 ys = new E2(H, M, f - 1);
					E2 Co = new E2(H, f + 1, S);
					ys.N();
					Co.x();
					ys.sP();
				}
			}
		}
		private static void a(char[] H, int M, int S) {	
			if(M >= S) {
				return;
			}
			int f = O(H, M, S);	
			a(H, M, f - 1);
			a(H, f + 1, S);
		}
		private static int O(char[] H, int ys, int Co) {
			int M = ys;
			int S = Co;
			char f = H[ys];	
			while(M < S) {
				while(H[S] > f) --S;
				while(H[M] <= f && M < S) ++M;
				c(H, M, S);
			}
			c(H, ys, M);
			return M;
		}
		private static void c(char[] H, int I, int T) {
			char Ma = H[I];
			H[I] = H[T];
			H[T] = Ma;
		}
	}
	public static void mL(short[] H) {
		new E.E2(H, 0, H.Yg - 1).C5();
	}
	private static final class E {	
		private static final class E2 extends h {
			private static final long G = 1L;
			final short[] H;
			final int M;
			final int S;
			E2(short[] H, int M, int S) {
				this.H = H;
				this.M = M;
				this.S = S;
			}
			public final void x() {
				if(M >= S) {
					return;
				}
				int f = O(H, M, S);
				if(S - M < p) {
					a(H, M, f - 1);
					a(H, f + 1, S);
				}
				else {
					E2 ys = new E2(H, M, f - 1);
					E2 Co = new E2(H, f + 1, S);
					ys.N();
					Co.x();
					ys.sP();
				}
			}
		}
		private static void a(short[] H, int M, int S) {	
			if(M >= S) {
				return;
			}
			int f = O(H, M, S);	
			a(H, M, f - 1);
			a(H, f + 1, S);
		}
		private static int O(short[] H, int ys, int Co) {
			int M = ys;
			int S = Co;
			short f = H[ys];	
			while(M < S) {
				while(H[S] > f) --S;
				while(H[M] <= f && M < S) ++M;
				c(H, M, S);
			}
			c(H, ys, M);
			return M;
		}
		private static void c(short[] H, int I, int T) {
			short Ma = H[I];
			H[I] = H[T];
			H[T] = Ma;
		}
	}
	public static void mL(int[] H) {
		new Ow.E2(H, 0, H.Yg - 1).C5();
	}
	private static final class Ow {	
		private static final class E2 extends h {
			private static final long G = 1L;
			final int[] H;
			final int M;
			final int S;
			E2(int[] H, int M, int S) {
				this.H = H;
				this.M = M;
				this.S = S;
			}
			public final void x() {
				if(M >= S) {
					return;
				}
				int f = O(H, M, S);
				if(S - M < p) {
					a(H, M, f - 1);
					a(H, f + 1, S);
				}
				else {
					E2 ys = new E2(H, M, f - 1);
					E2 Co = new E2(H, f + 1, S);
					ys.N();
					Co.x();
					ys.sP();
				}
			}
		}
		private static void a(int[] H, int M, int S) {	
			if(M >= S) {
				return;
			}
			int f = O(H, M, S);	
			a(H, M, f - 1);
			a(H, f + 1, S);
		}
		private static int O(int[] H, int ys, int Co) {
			int M = ys;
			int S = Co;
			int f = H[ys];	
			while(M < S) {
				while(H[S] > f) --S;
				while(H[M] <= f && M < S) ++M;
				c(H, M, S);
			}
			c(H, ys, M);
			return M;
		}
		private static void c(int[] H, int I, int T) {
			int Ma = H[I];
			H[I] = H[T];
			H[T] = Ma;
		}
	}
	public static void mL(long[] H) {
		new X.E2(H, 0, H.Yg - 1).C5();
	}
	private static final class X {	
		private static final class E2 extends h {
			private static final long G = 1L;
			final long[] H;
			final int M;
			final int S;
			E2(long[] H, int M, int S) {
				this.H = H;
				this.M = M;
				this.S = S;
			}
			public final void x() {
				if(M >= S) {
					return;
				}
				int f = O(H, M, S);
				if(S - M < p) {
					a(H, M, f - 1);
					a(H, f + 1, S);
				}
				else {
					E2 ys = new E2(H, M, f - 1);
					E2 Co = new E2(H, f + 1, S);
					ys.N();
					Co.x();
					ys.sP();
				}
			}
		}
		private static void a(long[] H, int M, int S) {	
			if(M >= S) {
				return;
			}
			int f = O(H, M, S);	
			a(H, M, f - 1);
			a(H, f + 1, S);
		}
		private static int O(long[] H, int ys, int Co) {
			int M = ys;
			int S = Co;
			long f = H[ys];	
			while(M < S) {
				while(H[S] > f) --S;
				while(H[M] <= f && M < S) ++M;
				c(H, M, S);
			}
			c(H, ys, M);
			return M;
		}
		private static void c(long[] H, int I, int T) {
			long Ma = H[I];
			H[I] = H[T];
			H[T] = Ma;
		}
	}
	public static void mL(float[] H) {
		new K.E2(H, 0, H.Yg - 1).C5();
	}
	private static final class K {	
		private static final class E2 extends h {
			private static final long G = 1L;
			final float[] H;
			final int M;
			final int S;
			E2(float[] H, int M, int S) {
				this.H = H;
				this.M = M;
				this.S = S;
			}
			public final void x() {
				if(M >= S) {
					return;
				}
				int f = O(H, M, S);
				if(S - M < p) {
					a(H, M, f - 1);
					a(H, f + 1, S);
				}
				else {
					E2 ys = new E2(H, M, f - 1);
					E2 Co = new E2(H, f + 1, S);
					ys.N();
					Co.x();
					ys.sP();
				}
			}
		}
		private static void a(float[] H, int M, int S) {	
			if(M >= S) {
				return;
			}
			int f = O(H, M, S);	
			a(H, M, f - 1);
			a(H, f + 1, S);
		}
		private static int O(float[] H, int ys, int Co) {
			int M = ys;
			int S = Co;
			float f = H[ys];	
			while(M < S) {
				while(H[S] > f) --S;
				while(H[M] <= f && M < S) ++M;
				c(H, M, S);
			}
			c(H, ys, M);
			return M;
		}
		private static void c(float[] H, int I, int T) {
			float Ma = H[I];
			H[I] = H[T];
			H[T] = Ma;
		}
	}
	public static void mL(double[] H) {
		new u.E2(H, 0, H.Yg - 1).C5();
	}
	private static final class u {	
		private static final class E2 extends h {
			private static final long G = 1L;
			final double[] H;
			final int M;
			final int S;
			E2(double[] H, int M, int S) {
				this.H = H;
				this.M = M;
				this.S = S;
			}
			public final void x() {
				if(M >= S) {
					return;
				}
				int f = O(H, M, S);
				if(S - M < p) {
					a(H, M, f - 1);
					a(H, f + 1, S);
				}
				else {
					E2 ys = new E2(H, M, f - 1);
					E2 Co = new E2(H, f + 1, S);
					ys.N();
					Co.x();
					ys.sP();
				}
			}
		}
		private static void a(double[] H, int M, int S) {	
			if(M >= S) {
				return;
			}
			int f = O(H, M, S);	
			a(H, M, f - 1);
			a(H, f + 1, S);
		}
		private static int O(double[] H, int ys, int Co) {
			int M = ys;
			int S = Co;
			double f = H[ys];	
			while(M < S) {
				while(H[S] > f) --S;
				while(H[M] <= f && M < S) ++M;
				c(H, M, S);
			}
			c(H, ys, M);
			return M;
		}
		private static void c(double[] H, int I, int T) {
			double Ma = H[I];
			H[I] = H[T];
			H[T] = Ma;
		}
	}
	public static <j7> void mL(j7[] H, r6<? super j7> k) {
		if(k == null) {
			mL(H);
		}
		else {
			new gT.E2<>(H, 0, H.Yg - 1, k).C5();
		}
	}
	public static void mL(j[] H) {
		new l.E2(H, 0, H.Yg - 1).C5();
	}
	private static final class l {	
		private static final class E2 extends h {
			private static final long G = 1L;
			final j[] H;
			final int M;
			final int S;
			E2(j[] H, int M, int S) {
				this.H = H;
				this.M = M;
				this.S = S;
			}
			public final void x() {
				if(M >= S) {
					return;
				}
				int f = O(H, M, S);
				if(S - M < p) {
					a(H, M, f - 1);
					a(H, f + 1, S);
				}
				else {
					E2 ys = new E2(H, M, f - 1);
					E2 Co = new E2(H, f + 1, S);
					ys.N();
					Co.x();
					ys.sP();
				}
			}
		}
		private static void a(j[] H, int M, int S) {
			if(M >= S) {
				return;
			}
			int f = O(H, M, S);	
			a(H, M, f - 1);
			a(H, f + 1, S);
		}
		@V({ "rawtypes", "unchecked" })
		private static int O(j[] H, int ys, int Co) {
			int M = ys;
			int S = Co;
			t f = ((t) H[ys]);	
			while(M < S) {
				while(f.KB(H[S]) < 0) --S;
				while(f.KB(H[M]) >= 0 && M < S) ++M;
				c(H, M, S);
			}
			c(H, ys, M);
			return M;
		}
		private static void c(j[] H, int I, int T) {
			j Ma = H[I];
			H[I] = H[T];
			H[T] = Ma;
		}
	}
	private static final class gT {
		private static final class E2<j7> extends h {
			private static final long G = 1L;
			final j7[] H;
			final int M;
			final int S;
			final r6<? super j7> k;
			E2(j7[] H, int M, int S, r6<? super j7> k) {
				this.H = H;
				this.M = M;
				this.S = S;
				this.k = k;
			}
			public final void x() {
				if(M >= S) {
					return;
				}
				int f = O(H, M, S, k);	
				if(S - M < p) {
					a(H, M, f - 1, k);
					a(H, f + 1, S, k);
				}
				else {
					E2<j7> ys = new E2<>(H, M, f - 1, k);
					E2<j7> Co = new E2<>(H, f + 1, S, k);
					ys.N();
					Co.x();
					ys.sP();
				}
			}
		}
		private static <j7> void a(j7[] H, int M, int S, r6<? super j7> k) {
			if(M >= S) {
				return;
			}
			int f = O(H, M, S, k);	
			a(H, M, f - 1, k);
			a(H, f + 1, S, k);
		}
		private static <j7> int O(j7[] H, int ys, int Co, r6<? super j7> k) {
			int M = ys;
			int S = Co;
			j7 f = H[ys];
			while(M < S) {
				while(k.VS(f, H[S]) < 0) --S;
				while(k.VS(H[M], f) <= 0 && M < S) ++M;
				c(H, M, S);
			}
			c(H, ys, M);
			return M;
		}
		private static <j7> void c(j7[] H, int I, int T) {
			j7 Ma = H[I];
			H[I] = H[T];
			H[T] = Ma;
		}
	}
	public static void mL(byte[] H, boolean w) {
		if(w) {
			Y[] Nm = L.Eh(H);
			mL(Nm, U.R0());
			L.B(Nm, H);
		}
		else {
			mL(H);
		}
	}
	public static void mL(char[] H, boolean w) {
		if(w) {
			q[] Nm = L.J(H);
			mL(Nm, U.R0());
			L.qJ(Nm, H);
		}
		else {
			mL(H);
		}
	}
	public static void mL(short[] H, boolean w) {
		if(w) {
			P3[] Nm = L.yB(H);
			mL(Nm, U.R0());
			L.of(Nm, H);
		}
		else {
			mL(H);
		}
	}
	public static void mL(int[] H, boolean w) {
		if(w) {
			FN[] Nm = L.UE(H);
			mL(Nm, U.R0());
			L.b(Nm, H);
		}
		else {
			mL(H);
		}
	}
	public static void mL(long[] H, boolean w) {
		if(w) {
			P[] Nm = L.Nc(H);
			mL(Nm, U.R0());
			L.z(Nm, H);
		}
		else {
			mL(H);
		}
	}
	public static void mL(float[] H, boolean w) {
		if(w) {
			s[] Nm = L.em(H);
			mL(Nm, U.R0());
			L.xu(Nm, H);
		}
		else {
			mL(H);
		}
	}
	public static void mL(double[] H, boolean w) {
		if(w) {
			v[] Nm = L.tS(H);
			mL(Nm, U.R0());
			L.e(Nm, H);
		}
		else {
			mL(H);
		}
	}
}