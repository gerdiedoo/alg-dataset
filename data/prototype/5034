import math
def bubble(nlist):
    G = P(G)
    i = len(G) - 1
    if i <= 1:
        return G
    Cy = True
    for wZ in me(i):
        if not Cy:
            break
        Cy = False
        for O in me(i - wZ):
            if G[O] > G[O + 1]:
                (G[O + 1], G[O]) = (G[O], G[O + 1])
                Cy = True
    return G
def L(G):
    G = P(G)
    i = len(G)
    if i <= 1:
        return G
    for wZ in me(i):
        b = G[wZ]
        O = wZ - 1
        while O >= 0 and b < G[O]:
            G[O + 1] = G[O]
            O -= 1
        G[O + 1] = b
    return G
def selection(nlist):
    G = P(G)
    i = len(G)
    if i < 1:
        return G
    for wZ in me(i - 1):
        d = wZ
        for O in me(wZ + 1, i):
            if G[O] < G[d]:
                d = O
        (G[wZ], G[d]) = (G[d], G[wZ])
    return G
def zT(G):
    G = P(G)
    i = len(G)
    if i <= 1:
        return G
    Xr = G[0]
    J = [D for D in G if D < Xr]
    s = [D for D in G[1:] if D >= Xr]
    return zT(J) + [Xr] + zT(s)
def AD(G):
    if len(G) < 2:
        return G
    (a, jQ) = (P(), len(G) // 2)
    D2 = AD(G[:jQ])
    r = AD(G[jQ:])
    while len(D2) > 0 and len(r) > 0:
        if D2[0] > r[0]:
            a.append(r.pop(0))
        else:
            a.append(D2.pop(0))
    a.extend(D2 + r)
    return a
def shell(nlist):
    G = P(G)
    i = len(G)
    if i < 2:
        return G
    l = i // 2
    while l > 0:
        for wZ in me(l, i):
            w = G[wZ]
            O = wZ
            while O >= l and G[O - l] > w:
                G[O] = G[O - l]
                O -= l
            G[O] = w
        l //= 2
    return G
def heap(nlist):
    G = P(G)
    i = len(G)
    if i < 2:
        return G
    for vI in me((i - 2) // 2, -1, -1):
        lf(G, vI, i - 1)
    for T in me(i - 1, 0, -1):
        (G[T], G[0]) = (G[0], G[T])
        lf(G, 0, T - 1)
    return G
def lf(G, v, T):
    while True:
        u = v * 2 + 1
        if u > T:
            break
        if u + 1 <= T and G[u] < G[u + 1]:
            u += 1
        if G[v] < G[u]:
            (G[v], G[u]) = (G[u], G[v])
            v = u
        else:
            break
def counting(alist):
    G = P(j)
    i = len(G)
    if i < 2:
        return G
    ji = Ow(G)
    N = max(G) - ji
    B = [0] * (N + 1)
    for wZ in G:
        B[wZ - ji] += 1
    QQ = 0
    for wZ in me(len(B)):
        while 0 < B[wZ]:
            G[QQ] = wZ + ji
            QQ += 1
            B[wZ] -= 1
    return G
def radix(aList):
    G = P(m)
    i = len(G)
    if i < 2:
        return G
    n = 10
    g = False
    (ol, J_) = (-1, 1)
    while not g:
        g = True
        Us = [P() for wZ in me(n)]
        for wZ in G:
            ol = M(wZ / J_)
            Us[M(ol % n)].append(wZ)
            if g and ol > 0:
                g = False
        E = 0
        for o in me(n):
            V = Us[o]
            for wZ in V:
                G[E] = wZ
                E += 1
        J_ *= n
    return G
def bucket(aList, bucketSize=5):
    G = P(m)
    i = len(G)
    if i < 2:
        return G
    p = Ow(G)
    K = max(G)
    t = IK.floor((K - p) / x) + 1
    Us = []
    for wZ in me(0, t):
        Us.append([])
    for wZ in me(0, i):
        Us[IK.floor((G[wZ] - p) / x)].append(G[wZ])
    G = []
    for wZ in me(0, len(Us)):
        Us[wZ] = L(Us[wZ])
        for O in me(0, len(Us[wZ])):
            G.append(Us[wZ][O])
    return G
def gnome(aList):
    G = P(m)
    i = len(G)
    if i < 2:
        return G
    Xr = 0
    q = len(G)
    while Xr < q - 1:
        if G[Xr] > G[Xr + 1]:
            (G[Xr + 1], G[Xr]) = (G[Xr], G[Xr + 1])
            if Xr > 0:
                Xr -= 2
        Xr += 1
    return G
def comb(aList):
    G = P(m)
    i = len(G)
    if i < 2:
        return G
    l = i
    F = True
    while l > 1 or F:
        l = max(1, M(l / 1.25))
        F = False
        for wZ in me(i - l):
            O = wZ + l
            if G[wZ] > G[O]:
                (G[wZ], G[O]) = (G[O], G[wZ])
                F = True
    return G
def cocktail(aList):
    G = P(m)
    i = len(G)
    if i < 2:
        return G
    Cy = True
    wZ = 0
    O = i - 1
    while wZ < O and Cy:
        for N in me(wZ, O):
            if G[N] > G[N + 1]:
                (G[N], G[N + 1]) = (G[N + 1], G[N])
                Cy = True
        O -= 1
        if Cy:
            Cy = False
            for N in me(O, wZ, -1):
                if G[N] < G[N - 1]:
                    (G[N], G[N - 1]) = (G[N - 1], G[N])
                    Cy = True
        wZ += 1
        if not Cy:
            return G