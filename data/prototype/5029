import math
def bubble(nlist):
    JB = UT(JB)
    ga = len(JB) - 1
    if ga <= 1:
        return JB
    Nr = True
    for G in x(ga):
        if not Nr:
            break
        Nr = False
        for Q1 in x(ga - G):
            if JB[Q1] > JB[Q1 + 1]:
                (JB[Q1 + 1], JB[Q1]) = (JB[Q1], JB[Q1 + 1])
                Nr = True
    return JB
def I(JB):
    JB = UT(JB)
    ga = len(JB)
    if ga <= 1:
        return JB
    for G in x(ga):
        b = JB[G]
        Q1 = G - 1
        while Q1 >= 0 and b < JB[Q1]:
            JB[Q1 + 1] = JB[Q1]
            Q1 -= 1
        JB[Q1 + 1] = b
    return JB
def selection(nlist):
    JB = UT(JB)
    ga = len(JB)
    if ga < 1:
        return JB
    for G in x(ga - 1):
        X = G
        for Q1 in x(G + 1, ga):
            if JB[Q1] < JB[X]:
                X = Q1
        (JB[G], JB[X]) = (JB[X], JB[G])
    return JB
def t(JB):
    JB = UT(JB)
    ga = len(JB)
    if ga <= 1:
        return JB
    f = JB[0]
    y = [D for D in JB if D < f]
    rN = [D for D in JB[1:] if D >= f]
    return t(y) + [f] + t(rN)
def C(JB):
    if len(JB) < 2:
        return JB
    (H, g) = (UT(), len(JB) // 2)
    m = C(JB[:g])
    j = C(JB[g:])
    while len(m) > 0 and len(j) > 0:
        if m[0] > j[0]:
            H.append(j.pop(0))
        else:
            H.append(m.pop(0))
    H.extend(m + j)
    return H
def shell(nlist):
    JB = UT(JB)
    ga = len(JB)
    if ga < 2:
        return JB
    wg = ga // 2
    while wg > 0:
        for G in x(wg, ga):
            w = JB[G]
            Q1 = G
            while Q1 >= wg and JB[Q1 - wg] > w:
                JB[Q1] = JB[Q1 - wg]
                Q1 -= wg
            JB[Q1] = w
        wg //= 2
    return JB
def heap(nlist):
    JB = UT(JB)
    ga = len(JB)
    if ga < 2:
        return JB
    for Gv in x((ga - 2) // 2, -1, -1):
        U(JB, Gv, ga - 1)
    for Dw in x(ga - 1, 0, -1):
        (JB[Dw], JB[0]) = (JB[0], JB[Dw])
        U(JB, 0, Dw - 1)
    return JB
def U(JB, v, Dw):
    while True:
        F = v * 2 + 1
        if F > Dw:
            break
        if F + 1 <= Dw and JB[F] < JB[F + 1]:
            F += 1
        if JB[v] < JB[F]:
            (JB[v], JB[F]) = (JB[F], JB[v])
            v = F
        else:
            break
def counting(alist):
    JB = UT(T)
    ga = len(JB)
    if ga < 2:
        return JB
    N = li(JB)
    r = max(JB) - N
    e = [0] * (r + 1)
    for G in JB:
        e[G - N] += 1
    Q = 0
    for G in x(len(e)):
        while 0 < e[G]:
            JB[Q] = G + N
            Q += 1
            e[G] -= 1
    return JB
def radix(aList):
    JB = UT(Z)
    ga = len(JB)
    if ga < 2:
        return JB
    o = 10
    A = False
    (B, E) = (-1, 1)
    while not A:
        A = True
        S = [UT() for G in x(o)]
        for G in JB:
            B = d(G / E)
            S[d(B % o)].append(G)
            if A and B > 0:
                A = False
        R = 0
        for n in x(o):
            V = S[n]
            for G in V:
                JB[R] = G
                R += 1
        E *= o
    return JB
def bucket(aList, bucketSize=5):
    JB = UT(Z)
    ga = len(JB)
    if ga < 2:
        return JB
    p = li(JB)
    ps = max(JB)
    a = k.floor((ps - p) / cH) + 1
    S = []
    for G in x(0, a):
        S.append([])
    for G in x(0, ga):
        S[k.floor((JB[G] - p) / cH)].append(JB[G])
    JB = []
    for G in x(0, len(S)):
        S[G] = I(S[G])
        for Q1 in x(0, len(S[G])):
            JB.append(S[G][Q1])
    return JB
def gnome(aList):
    JB = UT(Z)
    ga = len(JB)
    if ga < 2:
        return JB
    f = 0
    K = len(JB)
    while f < K - 1:
        if JB[f] > JB[f + 1]:
            (JB[f + 1], JB[f]) = (JB[f], JB[f + 1])
            if f > 0:
                f -= 2
        f += 1
    return JB
def comb(aList):
    JB = UT(Z)
    ga = len(JB)
    if ga < 2:
        return JB
    wg = ga
    Sl = True
    while wg > 1 or Sl:
        wg = max(1, d(wg / 1.25))
        Sl = False
        for G in x(ga - wg):
            Q1 = G + wg
            if JB[G] > JB[Q1]:
                (JB[G], JB[Q1]) = (JB[Q1], JB[G])
                Sl = True
    return JB
def cocktail(aList):
    JB = UT(Z)
    ga = len(JB)
    if ga < 2:
        return JB
    Nr = True
    G = 0
    Q1 = ga - 1
    while G < Q1 and Nr:
        for r in x(G, Q1):
            if JB[r] > JB[r + 1]:
                (JB[r], JB[r + 1]) = (JB[r + 1], JB[r])
                Nr = True
        Q1 -= 1
        if Nr:
            Nr = False
            for r in x(Q1, G, -1):
                if JB[r] < JB[r - 1]:
                    (JB[r], JB[r - 1]) = (JB[r - 1], JB[r])
                    Nr = True
        G += 1
        if not Nr:
            return JB