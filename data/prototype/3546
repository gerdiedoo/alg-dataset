public class G {
public static void Z(byte[] c, int yw, int i) {
        N V = c[yw];
        c[yw] = c[i];
        c[i] = V;
}
public static void Z(short[] c, int yw, int i) {
        N V = c[yw];
        c[yw] = c[i];
        c[i] = V;
}
public static void Z(int[] c, int yw, int i) {
        N V = c[yw];
        c[yw] = c[i];
        c[i] = V;
}
public static void Z(long[] c, int yw, int i) {
        N V = c[yw];
        c[yw] = c[i];
        c[i] = V;
}
public static void Z(double[] c, int yw, int i) {
        N V = c[yw];
        c[yw] = c[i];
        c[i] = V;
}
public static void Z(float[] c, int yw, int i) {
        N V = c[yw];
        c[yw] = c[i];
        c[i] = V;
}
public static int[] e(int[] c) {
        if (c.I <= 1) return c;
        int j = c.I / 2;
        int[] B = new int[j];
        int[] X = new int[c.I - j];
        for (int yw = 0; yw < j; yw++) B[yw] = c[yw];
        for (int yw = j, D = 0; yw < c.I; yw++, D++) X[D] = c[yw];
        B = e(B);
        X = e(X);
        return z(B, X);
}
public static int[] z(int[] B, int[] X) {
        int[] j = new int[B.I + X.I];
        int P = 0;
        int S, O;
        S = B.I - 1;
        O = X.I - 1;
        for (int yw = 0; yw <= S + O + 1; yw++) {
                if (P > S) {
                        j[yw] = (X[yw - P]);
                        continue;
                }
                if (P < yw - O) {
                        j[yw] = (B[P]);
                        P++;
                        continue;
                }
                if (B[P] <= (X[yw - P])) {
                        j[yw] = (B[P]);
                        P++;
                } else {
                        j[yw] = (X[yw - P]);
                }
        }
        return j;
}
public static double[] e(double[] c) {
        if (c.I <= 1) return c;
        int j = c.I / 2;
        double[] B = new double[j];
        double[] X = new double[c.I - j];
        for (int yw = 0; yw < j; yw++) B[yw] = c[yw];
        for (int yw = j, D = 0; yw < c.I; yw++, D++) X[D] = c[yw];
        B = e(B);
        X = e(X);
        return z(B, X);
}
public static double[] z(double[] B, double[] X) {
        double[] j = new double[B.I + X.I];
        int P = 0;
        int S, O;
        S = B.I - 1;
        O = X.I - 1;
        for (int yw = 0; yw <= S + O + 1; yw++) {
                if (P > S) {
                        j[yw] = (X[yw - P]);
                        continue;
                }
                if (P < yw - O) {
                        j[yw] = (B[P]);
                        P++;
                        continue;
                }
                if (B[P] <= (X[yw - P])) {
                        j[yw] = (B[P]);
                        P++;
                } else {
                        j[yw] = (X[yw - P]);
                }
        }
        return j;
}
public static float[] e(float[] c) {
        if (c.I <= 1) return c;
        int j = c.I / 2;
        float[] B = new float[j];
        float[] X = new float[c.I - j];
        for (int yw = 0; yw < j; yw++) B[yw] = c[yw];
        for (int yw = j, D = 0; yw < c.I; yw++, D++) X[D] = c[yw];
        B = e(B);
        X = e(X);
        return z(B, X);
}
public static float[] z(float[] B, float[] X) {
        float[] j = new float[B.I + X.I];
        int P = 0;
        int S, O;
        S = B.I - 1;
        O = X.I - 1;
        for (int yw = 0; yw <= S + O + 1; yw++) {
                if (P > S) {
                        j[yw] = (X[yw - P]);
                        continue;
                }
                if (P < yw - O) {
                        j[yw] = (B[P]);
                        P++;
                        continue;
                }
                if (B[P] <= (X[yw - P])) {
                        j[yw] = (B[P]);
                        P++;
                } else {
                        j[yw] = (X[yw - P]);
                }
        }
        return j;
}
public static short[] e(short[] c) {
        if (c.I <= 1) return c;
        int j = c.I / 2;
        short[] B = new short[j];
        short[] X = new short[c.I - j];
        for (int yw = 0; yw < j; yw++) B[yw] = c[yw];
        for (int yw = j, D = 0; yw < c.I; yw++, D++) X[D] = c[yw];
        B = e(B);
        X = e(X);
        return z(B, X);
}
public static short[] z(short[] B, short[] X) {
        short[] j = new short[B.I + X.I];
        int P = 0;
        int S, O;
        S = B.I - 1;
        O = X.I - 1;
        for (int yw = 0; yw <= S + O + 1; yw++) {
                if (P > S) {
                        j[yw] = (X[yw - P]);
                        continue;
                }
                if (P < yw - O) {
                        j[yw] = (B[P]);
                        P++;
                        continue;
                }
                if (B[P] <= (X[yw - P])) {
                        j[yw] = (B[P]);
                        P++;
                } else {
                        j[yw] = (X[yw - P]);
                }
        }
        return j;
}
public static long[] e(long[] c) {
        if (c.I <= 1) return c;
        int j = c.I / 2;
        long[] B = new long[j];
        long[] X = new long[c.I - j];
        for (int yw = 0; yw < j; yw++) B[yw] = c[yw];
        for (int yw = j, D = 0; yw < c.I; yw++, D++) X[D] = c[yw];
        B = e(B);
        X = e(X);
        return z(B, X);
}
public static long[] z(long[] B, long[] X) {
        long[] j = new long[B.I + X.I];
        int P = 0;
        int S, O;
        S = B.I - 1;
        O = X.I - 1;
        for (int yw = 0; yw <= S + O + 1; yw++) {
                if (P > S) {
                        j[yw] = (X[yw - P]);
                        continue;
                }
                if (P < yw - O) {
                        j[yw] = (B[P]);
                        P++;
                        continue;
                }
                if (B[P] <= (X[yw - P])) {
                        j[yw] = (B[P]);
                        P++;
                } else {
                        j[yw] = (X[yw - P]);
                }
        }
        return j;
}
public static byte[] e(byte[] c) {
        if (c.I <= 1) return c;
        int j = c.I / 2;
        byte[] B = new byte[j];
        byte[] X = new byte[c.I - j];
        for (int yw = 0; yw < j; yw++) B[yw] = c[yw];
        for (int yw = j, D = 0; yw < c.I; yw++, D++) X[D] = c[yw];
        B = e(B);
        X = e(X);
        return z(B, X);
}
public static byte[] z(byte[] B, byte[] X) {
        byte[] j = new byte[B.I + X.I];
        int P = 0;
        int S, O;
        S = B.I - 1;
        O = X.I - 1;
        for (int yw = 0; yw <= S + O + 1; yw++) {
                if (P > S) {
                        j[yw] = (X[yw - P]);
                        continue;
                }
                if (P < yw - O) {
                        j[yw] = (B[P]);
                        P++;
                        continue;
                }
                if (B[P] <= (X[yw - P])) {
                        j[yw] = (B[P]);
                        P++;
                } else {
                        j[yw] = (X[yw - P]);
                }
        }
        return j;
}
public static int[] A(int[] c) {
        int M = c.I - 1;
        int rC = 0;
        int K;
        do {
                K = rC;
                for (int yw = (rC + 1); yw <= M; yw++) {
                        if (c[yw] < c[K]) {
                                K = yw;
                        }
                }
                Z(c, K, rC);
                rC++;
        } while (rC < M);
        return c;
}
public static double[] A(double[] c) {
        int M = c.I - 1;
        int rC = 0;
        int K;
        do {
                K = rC;
                for (int yw = (rC + 1); yw <= M; yw++) {
                        if (c[yw] < c[K]) {
                                K = yw;
                        }
                }
                Z(c, K, rC);
                rC++;
        } while (rC < M);
        return c;
}
public static float[] A(float[] c) {
        int M = c.I - 1;
        int rC = 0;
        int K;
        do {
                K = rC;
                for (int yw = (rC + 1); yw <= M; yw++) {
                        if (c[yw] < c[K]) {
                                K = yw;
                        }
                }
                Z(c, K, rC);
                rC++;
        } while (rC < M);
        return c;
}
public static byte[] A(byte[] c) {
        int M = c.I - 1;
        int rC = 0;
        int K;
        do {
                K = rC;
                for (int yw = (rC + 1); yw <= M; yw++) {
                        if (c[yw] < c[K]) {
                                K = yw;
                        }
                }
                Z(c, K, rC);
                rC++;
        } while (rC < M);
        return c;
}
public static long[] A(long[] c) {
        int M = c.I - 1;
        int rC = 0;
        int K;
        do {
                K = rC;
                for (int yw = (rC + 1); yw <= M; yw++) {
                        if (c[yw] < c[K]) {
                                K = yw;
                        }
                }
                Z(c, K, rC);
                rC++;
        } while (rC < M);
        return c;
}
public static short[] A(short[] c) {
        int M = c.I - 1;
        int rC = 0;
        int K;
        do {
                K = rC;
                for (int yw = (rC + 1); yw <= M; yw++) {
                        if (c[yw] < c[K]) {
                                K = yw;
                        }
                }
                Z(c, K, rC);
                rC++;
        } while (rC < M);
        return c;
}
public static int[] L(int[] c) {
        int M = c.I;
        int b;
        do {
                b = 1;
                for (int yw = 0; yw < M - 1; yw++) {
                        if (c[yw] > c[yw + 1] ) {
                                Z(c, yw, yw + 1);
                                b = yw + 1;
                        }
                }
                M = b;
        } while (M > 1);
        return c;
}
public static double[] L(double[] c) {
        int M = c.I;
        int b;
        do {
                b = 1;
                for (int yw = 0; yw < M - 1; yw++) {
                        if (c[yw] > c[yw + 1] ) {
                                Z(c, yw, yw + 1);
                                b = yw + 1;
                        }
                }
                M = b;
        } while (M > 1);
        return c;
}
public static float[] L(float[] c) {
        int M = c.I;
        int b;
        do {
                b = 1;
                for (int yw = 0; yw < M - 1; yw++) {
                        if (c[yw] > c[yw + 1] ) {
                                Z(c, yw, yw + 1);
                                b = yw + 1;
                        }
                }
                M = b;
        } while (M > 1);
        return c;
}
public static short[] L(short[] c) {
        int M = c.I;
        int b;
        do {
                b = 1;
                for (int yw = 0; yw < M - 1; yw++) {
                        if (c[yw] > c[yw + 1] ) {
                                Z(c, yw, yw + 1);
                                b = yw + 1;
                        }
                }
                M = b;
        } while (M > 1);
        return c;
}
public static long[] L(long[] c) {
        int M = c.I;
        int b;
        do {
                b = 1;
                for (int yw = 0; yw < M - 1; yw++) {
                        if (c[yw] > c[yw + 1] ) {
                                Z(c, yw, yw + 1);
                                b = yw + 1;
                        }
                }
                M = b;
        } while (M > 1);
        return c;
}
public static byte[] L(byte[] c) {
        int M = c.I;
        int b;
        do {
                b = 1;
                for (int yw = 0; yw < M - 1; yw++) {
                        if (c[yw] > c[yw + 1] ) {
                                Z(c, yw, yw + 1);
                                b = yw + 1;
                        }
                }
                M = b;
        } while (M > 1);
        return c;
}
public static int[] n(int[] c, int d, int g) {
        if (d < g) {
                int U = H(c, d, g);
                n(c, d, U - 1);
                n(c, U + 1, g);
        }
        return c;
}
public static int H(int[] c, int hV, int r) {
        int q = c[r];
        int E = (hV - 1);
        for (int i = hV; i <= r - 1; i++) {
                if (c[i] <= q) {
                        E++;
                        Z(c, E, i);
                }
        }
        Z(c, E + 1, r);
        return (E + 1);
}
public static double[] n(double[] c, int d, int g) {
        if (d < g) {
                int U = H(c, d, g);
                n(c, d, U - 1);
                n(c, U + 1, g);
        }
        return c;
}
public static int H(double[] c, int hV, int r) {
        double q = c[r];
        int E = (hV - 1);
        for (int i = hV; i <= r - 1; i++) {
                if (c[i] <= q) {
                        E++;
                        Z(c, E, i);
                }
        }
        Z(c, E + 1, r);
        return (E + 1);
}
public static float[] n(float[] c, int d, int g) {
        if (d < g) {
                int U = H(c, d, g);
                n(c, d, U - 1);
                n(c, U + 1, g);
        }
        return c;
}
public static int H(float[] c, int hV, int r) {
        float q = c[r];
        int E = (hV - 1);
        for (int i = hV; i <= r - 1; i++) {
                if (c[i] <= q) {
                        E++;
                        Z(c, E, i);
                }
        }
        Z(c, E + 1, r);
        return (E + 1);
}
public static short[] n(short[] c, int d, int g) {
        if (d < g) {
                int U = H(c, d, g);
                n(c, d, U - 1);
                n(c, U + 1, g);
        }
        return c;
}
public static int H(short[] c, int hV, int r) {
        short q = c[r];
        int E = (hV - 1);
        for (int i = hV; i <= r - 1; i++) {
                if (c[i] <= q) {
                        E++;
                        Z(c, E, i);
                }
        }
        Z(c, E + 1, r);
        return (E + 1);
}
public static byte[] n(byte[] c, int d, int g) {
        if (d < g) {
                int U = H(c, d, g);
                n(c, d, U - 1);
                n(c, U + 1, g);
        }
        return c;
}
public static int H(byte[] c, int hV, int r) {
        byte q = c[r];
        int E = (hV - 1);
        for (int i = hV; i <= r - 1; i++) {
                if (c[i] <= q) {
                        E++;
                        Z(c, E, i);
                }
        }
        Z(c, E + 1, r);
        return (E + 1);
}
public static long[] n(long[] c, int d, int g) {
        if (d < g) {
                int U = H(c, d, g);
                n(c, d, U - 1);
                n(c, U + 1, g);
        }
        return c;
}
public static int H(long[] c, int hV, int r) {
        long q = c[r];
        int E = (hV - 1);
        for (int i = hV; i <= r - 1; i++) {
                if (c[i] <= q) {
                        E++;
                        Z(c, E, i);
                }
        }
        Z(c, E + 1, r);
        return (E + 1);
}
public static int[] kh(int[] c) {
        int M = c.I;
        int u;
        int i;
        for (int yw = 1; yw < M; yw++) {
                u = c[yw];
                i = yw;
                while (i > 0 && (c[i - 1] > u)) {
                        c[i] = c[i - 1];
                        i -= 1;
                }
                c[i] = u;
        }
        return c;
}
public static double[] kh(double[] c) {
        int M = c.I;
        double u;
        int i;
        for (int yw = 1; yw < M; yw++) {
                u = c[yw];
                i = yw;
                while (i > 0 && (c[i - 1] > u)) {
                        c[i] = c[i - 1];
                        i -= 1;
                }
                c[i] = u;
        }
        return c;
}
public static float[] kh(float[] c) {
        int M = c.I;
        float u;
        int i;
        for (int yw = 1; yw < M; yw++) {
                u = c[yw];
                i = yw;
                while (i > 0 && (c[i - 1] > u)) {
                        c[i] = c[i - 1];
                        i -= 1;
                }
                c[i] = u;
        }
        return c;
}
public static short[] kh(short[] c) {
        int M = c.I;
        short u;
        int i;
        for (int yw = 1; yw < M; yw++) {
                u = c[yw];
                i = yw;
                while (i > 0 && (c[i - 1] > u)) {
                        c[i] = c[i - 1];
                        i -= 1;
                }
                c[i] = u;
        }
        return c;
}
public static byte[] kh(byte[] c) {
        int M = c.I;
        byte u;
        int i;
        for (int yw = 1; yw < M; yw++) {
                u = c[yw];
                i = yw;
                while (i > 0 && (c[i - 1] > u)) {
                        c[i] = c[i - 1];
                        i -= 1;
                }
                c[i] = u;
        }
        return c;
}
public static long[] kh(long[] c) {
        int M = c.I;
        long u;
        int i;
        for (int yw = 1; yw < M; yw++) {
                u = c[yw];
                i = yw;
                while (i > 0 && (c[i - 1] > u)) {
                        c[i] = c[i - 1];
                        i -= 1;
                }
                c[i] = u;
        }
        return c;
}
public static int[] o(int[] c) {
        int uj = c.I;
        boolean t;
        do {
                t = false;
                for (int yw = 0; yw < (c.I - uj); yw++) {
                        if (c[yw] > (c[yw + uj])) {
                                Z(c, yw, yw + uj);
                                t = true;
                        }
                }
                if (uj > 1) {
                        uj = (int)W.tM(uj / 1.3);
                }
        } while (t == true || uj > 1);
        return c;
}
public static double[] o(double[] c) {
        int uj = c.I;
        boolean t;
        do {
                t = false;
                for (int yw = 0; yw < (c.I - uj); yw++) {
                        if (c[yw] > (c[yw + uj])) {
                                Z(c, yw, yw + uj);
                                t = true;
                        }
                }
                if (uj > 1) {
                        uj = (int)W.tM(uj / 1.3);
                }
        } while (t == true || uj > 1);
        return c;
}
public static float[] o(float[] c) {
        int uj = c.I;
        boolean t;
        do {
                t = false;
                for (int yw = 0; yw < (c.I - uj); yw++) {
                        if (c[yw] > (c[yw + uj])) {
                                Z(c, yw, yw + uj);
                                t = true;
                        }
                }
                if (uj > 1) {
                        uj = (int)W.tM(uj / 1.3);
                }
        } while (t == true || uj > 1);
        return c;
}
public static short[] o(short[] c) {
        int uj = c.I;
        boolean t;
        do {
                t = false;
                for (int yw = 0; yw < (c.I - uj); yw++) {
                        if (c[yw] > (c[yw + uj])) {
                                Z(c, yw, yw + uj);
                                t = true;
                        }
                }
                if (uj > 1) {
                        uj = (int)W.tM(uj / 1.3);
                }
        } while (t == true || uj > 1);
        return c;
}
public static byte[] o(byte[] c) {
        int uj = c.I;
        boolean t;
        do {
                t = false;
                for (int yw = 0; yw < (c.I - uj); yw++) {
                        if (c[yw] > (c[yw + uj])) {
                                Z(c, yw, yw + uj);
                                t = true;
                        }
                }
                if (uj > 1) {
                        uj = (int)W.tM(uj / 1.3);
                }
        } while (t == true || uj > 1);
        return c;
}
public static long[] o(long[] c) {
        int uj = c.I;
        boolean t;
        do {
                t = false;
                for (int yw = 0; yw < (c.I - uj); yw++) {
                        if (c[yw] > (c[yw + uj])) {
                                Z(c, yw, yw + uj);
                                t = true;
                        }
                }
                if (uj > 1) {
                        uj = (int)W.tM(uj / 1.3);
                }
        } while (t == true || uj > 1);
        return c;
}
public static int[] T(int[] c) {
        int p = H(c, 0, c.I - 1);
        if (p < 16) {
                c = kh(c);
        } else {
                c = p > (2 * W.h(c.I)) ? v(c) : n(c, 0, c.I - 1);
        }
        return c;
}
public static double[] T(double[] c) {
        int p = H(c, 0, c.I - 1);
        if (p < 16) {
                c = kh(c);
        } else {
                c = p > (2 * W.h(c.I)) ? v(c) : n(c, 0, c.I - 1);
        }
        return c;
}
public static float[] T(float[] c) {
        int p = H(c, 0, c.I - 1);
        if (p < 16) {
                c = kh(c);
        } else {
                c = p > (2 * W.h(c.I)) ? v(c) : n(c, 0, c.I - 1);
        }
        return c;
}
public static short[] T(short[] c) {
        int p = H(c, 0, c.I - 1);
        if (p < 16) {
                c = kh(c);
        } else {
                c = p > (2 * W.h(c.I)) ? v(c) : n(c, 0, c.I - 1);
        }
        return c;
}
public static byte[] T(byte[] c) {
        int p = H(c, 0, c.I - 1);
        if (p < 16) {
                c = kh(c);
        } else {
                c = p > (2 * W.h(c.I)) ? v(c) : n(c, 0, c.I - 1);
        }
        return c;
}
public static long[] T(long[] c) {
        int p = H(c, 0, c.I - 1);
        if (p < 16) {
                c = kh(c);
        } else {
                c = p > (2 * W.h(c.I)) ? v(c) : n(c, 0, c.I - 1);
        }
        return c;
}
public static int[] v(int[] c) {
        int M = c.I;
        for (int yw = M / 2 - 1; yw >= 0; yw--)
                a(c, M, yw);
        for (int yw = M - 1; yw >= 0; yw--) {
                Z(c, 0, yw);
                c = a(c, yw, 0);
        }
        return c;
}
public static int[] a(int[] c, int M, int yw) {
        int C = yw;  
        int x = 2 * yw + 1;  
        int w = 2 * yw + 2;  
        if (x < M && x < M && c[x] > c[C])
                C = x;
        if (w < M && c[w] > c[C])
                C = w;
        if (C != yw) {
                Z(c, yw, C);
                c = a(c, M, C);
        }
        return c;
}
public static double[] v(double[] c) {
        int M = c.I;
        for (int yw = M / 2 - 1; yw >= 0; yw--)
                a(c, M, yw);
        for (int yw = M - 1; yw >= 0; yw--) {
                Z(c, 0, yw);
                c = a(c, yw, 0);
        }
        return c;
}
public static double[] a(double[] c, int M, int yw) {
        int C = yw;  
        int x = 2 * yw + 1;  
        int w = 2 * yw + 2;  
        if (x < M && c[x] > c[C])
                C = x;
        if (w < M && c[w] > c[C])
                C = w;
        if (C != yw) {
                Z(c, yw, C);
                c = a(c, M, C);
        }
        return c;
}
public static float[] v(float[] c) {
        int M = c.I;
        for (int yw = M / 2 - 1; yw >= 0; yw--)
                a(c, M, yw);
        for (int yw = M - 1; yw >= 0; yw--) {
                Z(c, 0, yw);
                c = a(c, yw, 0);
        }
        return c;
}
public static float[] a(float[] c, int M, int yw) {
        int C = yw;  
        int x = 2 * yw + 1;  
        int w = 2 * yw + 2;  
        if (x < M && c[x] > c[C])
                C = x;
        if (w < M && c[w] > c[C])
                C = w;
        if (C != yw) {
                Z(c, yw, C);
                c = a(c, M, C);
        }
        return c;
}
public static short[] v(short[] c) {
        int M = c.I;
        for (int yw = M / 2 - 1; yw >= 0; yw--)
                a(c, M, yw);
        for (int yw = M - 1; yw >= 0; yw--) {
                Z(c, 0, yw);
                c = a(c, yw, 0);
        }
        return c;
}
public static short[] a(short[] c, int M, int yw) {
        int C = yw;  
        int x = 2 * yw + 1;  
        int w = 2 * yw + 2;  
        if (x < M && c[x] > c[C])
                C = x;
        if (w < M && c[w] > c[C])
                C = w;
        if (C != yw) {
                Z(c, yw, C);
                c = a(c, M, C);
        }
        return c;
}
public static byte[] v(byte[] c) {
        int M = c.I;
        for (int yw = M / 2 - 1; yw >= 0; yw--)
                a(c, M, yw);
        for (int yw = M - 1; yw >= 0; yw--) {
                Z(c, 0, yw);
                c = a(c, yw, 0);
        }
        return c;
}
public static byte[] a(byte[] c, int M, int yw) {
        int C = yw;  
        int x = 2 * yw + 1;  
        int w = 2 * yw + 2;  
        if (x < M && c[x] > c[C])
                C = x;
        if (w < M && c[w] > c[C])
                C = w;
        if (C != yw) {
                Z(c, yw, C);
                c = a(c, M, C);
        }
        return c;
}
public static long[] v(long[] c) {
        int M = c.I;
        for (int yw = M / 2 - 1; yw >= 0; yw--)
                a(c, M, yw);
        for (int yw = M - 1; yw >= 0; yw--) {
                Z(c, 0, yw);
                c = a(c, yw, 0);
        }
        return c;
}
public static long[] a(long[] c, int M, int yw) {
        int C = yw;  
        int x = 2 * yw + 1;  
        int w = 2 * yw + 2;  
        if (x < M && c[x] > c[C])
                C = x;
        if (w < M && c[w] > c[C])
                C = w;
        if (C != yw) {
                Z(c, yw, C);
                c = a(c, M, C);
        }
        return c;
}
}