def to_hash(key, length=10):
    try:
        return abs(hash(key)) % (10 ** length)
    except TypeError:
        return abs(hash(str(key))) % (10 ** length)
class Node:
    def __init__(self, key, value, next_node=None):
        self.key = key
        self.value = value
        self.next = next_node
    def __repr__(self):
        return f'Node {{{self.key}: {self.value}}}'
class LinkedList:
    def __init__(self, head=None):
        self.head = head
        self.current = self.head
    def __repr__(self):
        return f'LinkedList <{self.head}> -> ...'
    def __iter__(self):
        return self
    def __next__(self):
        if self.current is not None:
            node, self.current = self.current, self.current.next
            return node
        self.current = self.head
        raise StopIteration
    def __len__(self):
        count = 0
        for _ in self:
            count += 1
        return count
    def _append(self, key, value):
        node = self.head
        if node is None:
            self.head = Node(key, value)
            self.current = self.head
            return self.head
        else:
            while node.next:
                node = node.next
            node.next = Node(key, value)
            return node.next
    def get(self, key):
        node = self.head
        if node is None:
            return None
        if node.key == key:
            return node
        while node:
            if node.key == key:
                return node
            node = node.next
        return node
    def set(self, key, value):
        node = self.get(key)
        if node:
            node.value = value
        else:
            node = self._append(key, value)
        return node
class Hashtable:
    def __init__(self, size=100):
        self.size = size
        self._buckets = [None for i in range(size)]
        self._hash_map = {}
    def __repr__(self):
        return f'Hashtable <{len(self._hash_map)} key/val pairs>'
    def _get_list(self, index):
        try:
            return self._buckets[index]
        except IndexError:
            return None
    def get(self, *keys):
        values = []
        for key in keys:
            hash_key = to_hash(key)
            if hash_key not in self._hash_map:
                continue
            index = self._hash_map[hash_key]
            lst = self._get_list(index)
            if lst and lst.get(key):
                values.append(lst.get(key).value)
        return values[0] if len(values) == 1 else tuple(values) or None
    def set(self, key=None, value=None):
        if key is None:
            return None
        hash_key = to_hash(key)
        if hash_key in self._hash_map:
            lst = self._get_list(index=self._hash_map[hash_key])
            node = lst.set(key, value)
        else:
            index = hash_key % self.size
            if self._get_list(index) is None:
                self._buckets[index] = LinkedList()
            node = self._buckets[index].set(key, value)
            self._hash_map[hash_key] = index
        return node
    def keys(self):
        keys = []
        indices = set(self._hash_map.values())
        for i in indices:
            keys.extend([node.key for node in self._buckets[i] if node])
        return tuple(keys)