import sys
class HashMap(object):
    def __init__(self, size: int):
        self.size = size
        self.key_list = [None] * self.size
        self.value_list = [None] * self.size
        self.num_items = 0
    def set(self, key: str, value):
        key, hash_index = self._process_key(key)
        probe_length = 0
        elem_to_swap, elem_to_swap_found, new_probe_length = None, False, 0
        while probe_length < self.size:
            if self.key_list[hash_index] is None:
                self.key_list[hash_index] = key, probe_length
                self.value_list[hash_index] = value
                self.num_items += 1
                if elem_to_swap_found:
                    self._swap_elements(elem_to_swap, hash_index, new_probe_length)
                return True
            elif self.key_list[hash_index][0] == key:
                self.value_list[hash_index] = value
                return True
            else:
                if elem_to_swap_found is False and self.key_list[hash_index][1] < probe_length:
                    elem_to_swap, elem_to_swap_found, new_probe_length = hash_index, True, probe_length
                hash_index = self._increment_hash(hash_index)
            probe_length += 1
        return False
    def get(self, key: str):
        key, hash_index = self._process_key(key)
        for probe_length in range(self.size):
            if self.key_list[hash_index] is not None and self.key_list[hash_index][0] == key:
                return self.value_list[hash_index]
            else:
                hash_index = self._increment_hash(hash_index)
        return None
    def delete(self, key: str):
        if self.load() == 0:
            return None
        key, hash_index = self._process_key(key)
        for probe_length in range(self.size):
            if self.key_list[hash_index] is not None and self.key_list[hash_index][0] == key:
                value = self.value_list[hash_index]
                self.key_list[hash_index], self.value_list[hash_index] = None, None
                self.num_items -= 1
                return value
            else:
                hash_index = self._increment_hash(hash_index)
        return None
    def load(self):
        return self.num_items / self.size
    def clear(self):
        self.key_list.clear()
        self.value_list.clear()
        self.num_items = 0
    def _process_key(self, key: str):
        key = sys.intern(key)
        return key, hash(key) % self.size
    def _increment_hash(self, index: int):
        return (index + 1) % self.size
    def _swap_elements(self, existing_index: int, new_index: int, new_probe_length: int):
        delta = new_index - existing_index
        if delta < 0:
            delta = self.size - existing_index + new_index
        self.key_list[existing_index] = self.key_list[existing_index][0], self.key_list[existing_index][1] + delta
        self.key_list[new_index] = self.key_list[new_index][0], new_probe_length
        self.key_list[existing_index], self.key_list[new_index] =            self.key_list[new_index], self.key_list[existing_index]
        self.value_list[existing_index], self.value_list[new_index] =            self.value_list[new_index], self.value_list[existing_index]
    @property
    def probe_lengths(self):
        return [probe_length[1] for probe_length in self.key_list if probe_length is not None]