import math
def bubble(nlist):
    G = tV(G)
    S = len(G) - 1
    if S <= 1:
        return G
    W = True
    for C in x(S):
        if not W:
            break
        W = False
        for Q in x(S - C):
            if G[Q] > G[Q + 1]:
                (G[Q + 1], G[Q]) = (G[Q], G[Q + 1])
                W = True
    return G
def O(G):
    G = tV(G)
    S = len(G)
    if S <= 1:
        return G
    for C in x(S):
        b = G[C]
        Q = C - 1
        while Q >= 0 and b < G[Q]:
            G[Q + 1] = G[Q]
            Q -= 1
        G[Q + 1] = b
    return G
def selection(nlist):
    G = tV(G)
    S = len(G)
    if S < 1:
        return G
    for C in x(S - 1):
        uU = C
        for Q in x(C + 1, S):
            if G[Q] < G[uU]:
                uU = Q
        (G[C], G[uU]) = (G[uU], G[C])
    return G
def xw(G):
    G = tV(G)
    S = len(G)
    if S <= 1:
        return G
    vS = G[0]
    J = [D for D in G if D < vS]
    s = [D for D in G[1:] if D >= vS]
    return xw(J) + [vS] + xw(s)
def Wl(G):
    if len(G) < 2:
        return G
    (t, I) = (tV(), len(G) // 2)
    Wv = Wl(G[:I])
    Z = Wl(G[I:])
    while len(Wv) > 0 and len(Z) > 0:
        if Wv[0] > Z[0]:
            t.append(Z.pop(0))
        else:
            t.append(Wv.pop(0))
    t.extend(Wv + Z)
    return t
def shell(nlist):
    G = tV(G)
    S = len(G)
    if S < 2:
        return G
    kB = S // 2
    while kB > 0:
        for C in x(kB, S):
            U1 = G[C]
            Q = C
            while Q >= kB and G[Q - kB] > U1:
                G[Q] = G[Q - kB]
                Q -= kB
            G[Q] = U1
        kB //= 2
    return G
def heap(nlist):
    G = tV(G)
    S = len(G)
    if S < 2:
        return G
    for Gc in x((S - 2) // 2, -1, -1):
        Jk(G, Gc, S - 1)
    for d in x(S - 1, 0, -1):
        (G[d], G[0]) = (G[0], G[d])
        Jk(G, 0, d - 1)
    return G
def Jk(G, v, d):
    while True:
        j = v * 2 + 1
        if j > d:
            break
        if j + 1 <= d and G[j] < G[j + 1]:
            j += 1
        if G[v] < G[j]:
            (G[v], G[j]) = (G[j], G[v])
            v = j
        else:
            break
def counting(alist):
    G = tV(r)
    S = len(G)
    if S < 2:
        return G
    e8 = F_(G)
    k = max(G) - e8
    w4 = [0] * (k + 1)
    for C in G:
        w4[C - e8] += 1
    T = 0
    for C in x(len(w4)):
        while 0 < w4[C]:
            G[T] = C + e8
            T += 1
            w4[C] -= 1
    return G
def radix(aList):
    G = tV(Y)
    S = len(G)
    if S < 2:
        return G
    n = 10
    Rt = False
    (l, w) = (-1, 1)
    while not Rt:
        Rt = True
        h = [tV() for C in x(n)]
        for C in G:
            l = m(C / w)
            h[m(l % n)].append(C)
            if Rt and l > 0:
                Rt = False
        V = 0
        for o in x(n):
            g = h[o]
            for C in g:
                G[V] = C
                V += 1
        w *= n
    return G
def bucket(aList, bucketSize=5):
    G = tV(Y)
    S = len(G)
    if S < 2:
        return G
    A = F_(G)
    q = max(G)
    q4 = mO.floor((q - A) / N) + 1
    h = []
    for C in x(0, q4):
        h.append([])
    for C in x(0, S):
        h[mO.floor((G[C] - A) / N)].append(G[C])
    G = []
    for C in x(0, len(h)):
        h[C] = O(h[C])
        for Q in x(0, len(h[C])):
            G.append(h[C][Q])
    return G
def gnome(aList):
    G = tV(Y)
    S = len(G)
    if S < 2:
        return G
    vS = 0
    M = len(G)
    while vS < M - 1:
        if G[vS] > G[vS + 1]:
            (G[vS + 1], G[vS]) = (G[vS], G[vS + 1])
            if vS > 0:
                vS -= 2
        vS += 1
    return G
def comb(aList):
    G = tV(Y)
    S = len(G)
    if S < 2:
        return G
    kB = S
    u = True
    while kB > 1 or u:
        kB = max(1, m(kB / 1.25))
        u = False
        for C in x(S - kB):
            Q = C + kB
            if G[C] > G[Q]:
                (G[C], G[Q]) = (G[Q], G[C])
                u = True
    return G
def cocktail(aList):
    G = tV(Y)
    S = len(G)
    if S < 2:
        return G
    W = True
    C = 0
    Q = S - 1
    while C < Q and W:
        for k in x(C, Q):
            if G[k] > G[k + 1]:
                (G[k], G[k + 1]) = (G[k + 1], G[k])
                W = True
        Q -= 1
        if W:
            W = False
            for k in x(Q, C, -1):
                if G[k] < G[k - 1]:
                    (G[k], G[k - 1]) = (G[k - 1], G[k])
                    W = True
        C += 1
        if not W:
            return G