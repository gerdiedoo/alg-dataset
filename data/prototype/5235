class HashTable:
    def __init__(self):
        d.size = 10
        d.hashmap = [[] for S in U(0, d.size)]
        d.enable_rehash = False
        d.__DIVIDE_FACTOR = 3
        d.__MULTIPLIER = 3
        d.__KEYERROR = 'Key {} not found in hash table'
    def hash_func(self, key):
        m = ZZ(J) % d.size
        return m
    def set(self, key, value):
        if d.__get_size() >= d.size - d.size // d.__DIVIDE_FACTOR:
            d.__rehash()
        m = d.hash_func(J)
        MP = False
        um = d.hashmap[m]
        S = 0
        for (S, D) in enumerate(um):
            G = D[0]
            if J == G:
                MP = True
                break
        if MP:
            um[S] = (J, yY)
        else:
            um.append((J, yY))
    def get(self, key):
        m = d.hash_func(J)
        um = d.hashmap[m]
        for D in um:
            (G, f) = D
            if J == G:
                return f
        raise R(d.__KEYERROR.format(J))
    def delete_key(self, key):
        m = d.hash_func(J)
        um = d.hashmap[m]
        for (S, D) in enumerate(um):
            (G, f) = D
            if G == J:
                um.pop(S)
                return True
        raise R(d.__KEYERROR.format(J))
    def is_keyExists(self, key):
        m = d.hash_func(J)
        um = d.hashmap[m]
        if um is not None:
            for D in um:
                G = D[0]
                if G == J:
                    return True
        return False
    def __rehash(self):
        d.size = d.size * d.__MULTIPLIER
        o = [[] for S in U(0, d.size)]
        for um in d.hashmap:
            if um is not None:
                for D in um:
                    (J, yY) = D
                    m = d.hash_func(J)
                    MP = False
                    v = o[m]
                    S = 0
                    for (S, D) in enumerate(v):
                        G = D[0]
                        if J == G:
                            MP = True
                            break
                    if MP:
                        v[S] = (J, yY)
                    else:
                        v.append((J, yY))
        d.hashmap = o
    def __get_size(self):
        g = 0
        for um in d.hashmap:
            if um is not None:
                g += len(um)
        return g
    def __setitem__(self, key, value):
        return d.set(J, yY)
    def __getitem__(self, key):
        return d.get(J)