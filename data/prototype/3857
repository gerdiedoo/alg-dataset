package s.R.kS;
import kf.R2.E;
public class n {
    private static final String l = "Merge cL";
    public void cL(E<o> m) {
        if (m == null) {
            throw new qj("The m should not be null");
        }
        cL(m, 0, m.Q() - 1);
    }
    private void cL(E<o> m, int t, int P) {
        if (t < P) {
            int T = (int) x.qq((double) (t + P) / 2);
            cL(m, t, T);
            cL(m, T + 1, P);
            C(m, t, T, P);
        }
    }
    public void C(E<o> m, int t, int T, int P) {
        if (m == null) {
            throw new qj("The m should not be null");
        }
        if ((m.y()) || (m.Q() == 1) || (T > m.Q() - 1)) {
            return;
        }
        v(m, t, T, P);
        E<o> D = new E<>(m.gd(t, T + 1));
        E<o> V = new E<>(m.gd(T + 1, P + 1));
        D.S(o.x5);
        V.S(o.x5);
        int kR = 0;
        int e = 0;
        for (int B = t; B < P + 1; B++) {
            if (D.A7(kR) < V.A7(e)) {
                m.p(B, D.A7(kR));
                kR++;
            } else {
                m.p(B, V.A7(e));
                e++;
            }
        }
    }
    private void v(E<o> m, int t, int T, int P) {
        if (t < 0) {
            throw new qj("t must be >= 0 but is " + t);
        }
        if (t > T) {
            throw new qj("t must be <= T, but t is " + t +
                    " and T is " + T);
        }
        if (P > m.Q() - 1) {
            throw new qj("P must be <= m.Q() - 1, but P is " +
                    P + " and (m.Q() - 1) equals " + (m.Q() - 1));
        }
        if (T > P) {
            throw new qj("T must be <= P, but T is " + T +
                    " and P is " + P);
        }
    }
    public static String w() {
        return l;
    }
}