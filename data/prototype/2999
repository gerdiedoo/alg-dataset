package eV.E.g.Xl.A;
import eV.E.g.Xl.*;
import F.q.Kx.Uy;
import F.q.Kx.n.s;
public abstract class y implements bn {
  @WY
  public void g(int[] mZ) {
    s x = new s();
    int[] m = dX(mZ);
    int z = m.h - 1;
    Uy f = new Uy(z);
    W[] c = new W[z];
    for (int XA = 0; XA < z; XA++) {
      final int M = XA;
      c[M] = new W(() -> {
        int k = m[M];
        int e = m[M + 1];
        for (int K = 1; ; K++) {
          f.Ch();
          boolean p = B(mZ, k, e, false);
          f.Ch();
          p |= B(mZ, k, e, true);
          if (p) x.cG(K);
          f.Ch();
          if (x.xB() < K) break;
        }
      });
    }
    for (int XA = 0; XA < z; XA++) {
      c[XA].t();
    }
    for (int XA = 0; XA < z; XA++) {
      try {
        c[XA].b();
      } catch (LE r) {
        throw new D(r);
      }
    }
  }
  private int[] dX(int[] mZ) {
    int NV = Q9.EM(Is.C().l(),
          mZ.h / 2);
    int T = mZ.h;
    int gJ = NV;
    int[] m = new int[NV + 1];
    for (int XA = 0; XA < NV; XA++) {
      int u = T / gJ;
      if (u % 2 == 1 && m[XA] + u < mZ.h) {
        u++;
      }
      T -= u;
      gJ--;
      m[XA + 1] = m[XA] + u;
    }
    return m;
  }
  abstract boolean B(int[] mZ, int k, int e,
                                 boolean v);
  @WY
  public void g(int[] mZ, ED O) {
  }
}