package EH.Oa;
import yl.s.Nk.R.y.No;
import Q.wL.a7;
import Q.wL.O;
import Q.wL.aR;
import Q.vz.*;
abstract class kY<qc, Fo> {
    public static final kY Cz = new l(
            new yl.s.Nk.R.y.q());
    final yl.s.Nk.R.y.v<qc, Fn> jm;  
    public static final String tg = new String("Non existing mapping M");
    private static final j qX = new j();
    public kY(yl.s.Nk.R.y.v<qc, Fn> jm) {
        this.jm = jm;
    }
    private qc Wl(qc oW) {
        return oW == null ? (qc) qX : oW;
    }
    private qc J3(qc oW) {
        return oW == qX ? null : oW;
    }
    protected v<qc, Fo> P() {
        return L.kL();
    }
    protected abstract l<qc, Fo> dL();
    public Fo z(p<qc, Fo> V, qc oW) {
        j DS = aU(V, oW);
        return DS != tg ? (Fo) DS : null;
    }
    private j aU(p<qc, Fo> V, j oW) {
        qc w = Wl((qc) oW);
        final Fn qO = jm.z(w);
        if (qO == null)
            return P().z(w);
        return K(V, qO);
    }
    protected static j K(p V, int qO) {
        switch (qO) {
            case -1:
                return V.YW;
            case -2:
                return V.tn;
            case -3:
                return V.we;
        }
        return ((j[]) V.YW)[qO];
    }
    public Fo n(p<qc, Fo> V, qc oW, j M) {
        qc w = Wl(oW);
        Fn qO = jm.z(w);
        j Nw = tg;
        if (qO == null) {
            Nw = P().z(w);
            v<qc, Fo> A = wq.Ed(P(), w, M);
            if (A != null) {
                V.J = dL().u(A);
                return (Fo) Nw;
            }
            if (M == tg)
                return (Fo) Nw;
            qO = x(V, w);
        }
        switch (qO) {
            case -1:
                if (Nw == tg)
                    Nw = V.YW;
                V.YW = M;
                break;
            case -2:
                if (Nw == tg)
                    Nw = V.tn;
                V.tn = M;
                break;
            case -3:
                if (Nw == tg)
                    Nw = V.we;
                V.we = M;
                break;
            default:
                j[] qx = (j[]) V.YW;
                if (Nw == tg)
                    Nw = qx[qO];
                qx[qO] = M;
                break;
        }
        return (Fo) Nw;
    }
    private Fn x(p<qc, Fo> V, qc oW) {
        final kY<qc, Fo> I4 = dL().U(oW, P());
        V.J = I4;
        int z_ = jm.nX();
        if (z_ == 3) {
            j[] qx = new j[4];
            qx[0] = V.YW;
            V.YW = qx;
        } else if (z_ > 3) {
            j[] qx = (j[]) V.YW;
            if (qx.Q3 < z_ - 1) {
                int G = qx.Q3 * 3 / 2;
                G += G & 1;  
                j[] jw = new j[G];
                System.Ci(qx, 0, jw, 0, qx.Q3);
                V.YW = jw;
            }
        }
        return I4.jm.z(oW);
    }
    public int nX(p<qc, Fo> V) {
        return jm.nX() + P().nX() - S(V);
    }
    private int S(p<qc, Fo> V) {
        int Y = 0;
        switch (jm.nX()) {
            default:  
                for (j Jy : (j[]) V.YW) {
                    if (Jy == tg) Y++;
                }
            case 3:  
                if (V.YW == tg) Y++;
            case 2:  
                if (V.tn == tg) Y++;
            case 1:  
                if (V.we == tg) Y++;
            case 0:
        }
        return Y;
    }
    public boolean uw(p<qc, Fo> V, j oW) {
        qc w = Wl((qc) oW);
        final Fn qO = jm.z(w);
        if (qO == null)
            return P().uw(w);
        return K(V, qO) != tg;
    }
    public c<qc> d(p<qc, Fo> V) {
        return new kY.r<qc, Fo>(V);
    }
    public c<Fo> ZS(p<qc, Fo> V) {
        return new kY.E<qc, Fo>(V);
    }
    public c<v.J1<qc, Fo>> N(p<qc, Fo> V) {
        return new kY.OB<qc, Fo>(V);
    }
    public void sy(final p<qc, Fo> V, final aR b) throws a7 {
        int nX = jm.nX() - S(V);
        b.xI(nX);
        if (nX > 0)
            for (No<qc, Fn> ik : jm) {
                j M = K(V, ik.a());
                if (M == tg) continue;
                b.dQ(J3(ik.g()));
                b.dQ(M);
            }
        b.dQ(P());
    }
    public static <qc, Fo> void C(p<qc, Fo> V, O b) throws a7, a6 {
        int nX = b.Af();
        V.J = kY.Cz;
        for (int T = 0; T < nX; T++) {
            qc oW = (qc) b.m();
            Fo M = (Fo) b.m();
            V.n(oW, M);
        }
        v<qc, Fo> d3 = (v<qc, Fo>) b.m();
        for (v.J1<qc, Fo> ik : d3.N()) {
            V.n(ik.f(), ik.pY());
        }
    }
    static class r<qc, Fo> extends F<qc> {
        private final p<qc, Fo> V;
        public r(p<qc, Fo> V) {
            this.V = V;
        }
        @Xx
        public int nX() {
            return V.nX();
        }
        @Xx
        public boolean D(j Jy) {
            return V.uw(Jy);
        }
        @Xx
        public boolean I(j Jy) {
            return V.I(Jy) != null;  
        }
        @Xx
        public e<qc> i() {
            return new o<qc, Fo>(V);
        }
        @Xx
        public void lk() {
            V.lk();
        }
    }
    static class E<qc, Fo> extends F<Fo> {
        private final p<qc, Fo> V;
        public E(p<qc, Fo> V) {
            this.V = V;
        }
        @Xx
        public int nX() {
            return V.nX();
        }
        @Xx
        public e<Fo> i() {
            return new Z<qc, Fo>(V);
        }
        @Xx
        public void lk() {
            V.lk();
        }
    }
    static class OB<qc, Fo> extends F<v.J1<qc, Fo>> {
        private final p<qc, Fo> V;
        public OB(p<qc, Fo> V) {
            this.V = V;
        }
        @Xx
        public e<v.J1<qc, Fo>> i() {
            return new HK<qc, Fo>(V);
        }
        @Xx
        public boolean D(j Jy) {
            if (!(Jy instanceof v.J1))
                return false;
            v.J1<qc, Fo> X = (v.J1<qc, Fo>) Jy;
            qc oW = X.f();
            Fo M = X.pY();
            Fo h = V.z(oW);
            if (M == null) {
                return h == null && V.uw(oW);
            }
            return M.equals(h);
        }
        @Xx
        public boolean I(j Jy) {
            if (!(Jy instanceof v.J1))
                return false;
            v.J1<qc, Fo> X = (v.J1<qc, Fo>) Jy;
            return V.I(X.f()) != null;  
        }
        @Xx
        public int nX() {
            return V.nX();
        }
        @Xx
        public void lk() {
            V.lk();
        }
    }
    static abstract class YF<qc, Fo, jn> implements e<jn> {
        boolean Co = true;
        private final p<qc, Fo> V;
        e e_;
        v.J1<qc, Fo> t, hA;
        public YF(p<qc, Fo> V) {
            this.V = V;
            if (V.Wx()) return;
            this.e_ = V.J.P().N().i();
            OI();
        }
        private void OI() {
            if (!e_.H() && Co) {
                Co = false;
                e_ = V.J.jm.k().N().i();
            }
            if (!e_.H()) {
                hA = null;
                return;
            }
            while (e_.H()) {
                v.J1 ik = (v.J1) e_.hA();
                Fo M;
                if (Co)
                    M = (Fo) ik.pY();
                else {
                    M = (Fo) K(V, (Fn) ik.pY());
                    if (M == tg) continue;
                }
                hA = new de<qc, Fo>(V, (qc) ik.f(), M);
                return;
            }
            hA = null;
        }
        public boolean H() {
            return hA != null;
        }
        public v.J1<qc, Fo> Zm() {
            if (hA == null)
                throw new W();
            t = hA;
            OI();
            return t;
        }
        public void I() {
            if (t == null) {
                throw new PS();
            }
            V.I(t.f());
            t = null;
        }
    }
    static class o<qc, Fo> extends YF<qc, Fo, qc> {
        public o(p<qc, Fo> yf) {
            super(yf);
        }
        public qc hA() {
            return Zm().f();
        }
    }
    static class Z<qc, Fo> extends YF<qc, Fo, Fo> {
        public Z(p<qc, Fo> yf) {
            super(yf);
        }
        public Fo hA() {
            return Zm().pY();
        }
    }
    static class HK<qc, Fo> extends YF<qc, Fo, v.J1<qc, Fo>> {
        public HK(p<qc, Fo> yf) {
            super(yf);
        }
        public v.J1<qc, Fo> hA() {
            return Zm();
        }
    }
    static class de<qc, Fo> implements v.J1<qc, Fo> {
        final qc oW;
        Fo M;
        private final p<qc, Fo> V;
        public de(p<qc, Fo> V, qc oW, Fo M) {
            this.V = V;
            this.oW = oW;
            this.M = M;
        }
        public qc f() {
            return V.J.J3(oW);
        }
        public Fo pY() {
            return M;
        }
        public Fo Vl(Fo M) {
            this.M = M;
            return V.n(oW, M);
        }
        private static boolean B(j OW, j EE) {
            return OW == null ? EE == null : OW.equals(EE);
        }
        public boolean equals(j Jy) {
            if (!(Jy instanceof v.J1)) {
                return false;
            }
            v.J1<?, ?> X = (v.J1<?, ?>) Jy;
            return B(f(), X.f()) && B(M, X.pY());
        }
        public int hashCode() {
            return (oW == qX ? 0 : oW.hashCode()) ^
                    (M == null ? 0 : M.hashCode());
        }
        @Xx
        public String toString() {
            return V.J.J3(oW) + "=" + M;
        }
    }
}