package P.gR.c6.z.A;
import P.gR.c6.z.*;
import j.fT.l_.g;
import j.fT.l_.Pg.kO;
public abstract class uh implements K1 {
  @Q
  public void c6(int[] e) {
    kO H = new kO();
    int[] nk = i(e);
    int k = nk.T - 1;
    g n = new g(k);
    t[] Rf = new t[k];
    for (int i0 = 0; i0 < k; i0++) {
      final int m = i0;
      Rf[m] = new t(() -> {
        int R_ = nk[m];
        int q = nk[m + 1];
        for (int JA = 1; ; JA++) {
          n.cL();
          boolean w = Y(e, R_, q, false);
          n.cL();
          w |= Y(e, R_, q, true);
          if (w) H.Hg(JA);
          n.cL();
          if (H.r() < JA) break;
        }
      });
    }
    for (int i0 = 0; i0 < k; i0++) {
      Rf[i0].nx();
    }
    for (int i0 = 0; i0 < k; i0++) {
      try {
        Rf[i0].J();
      } catch (E Z) {
        throw new i5(Z);
      }
    }
  }
  private int[] i(int[] e) {
    int h = Z3.s(u.G().o(),
          e.T / 2);
    int K = e.T;
    int b = h;
    int[] nk = new int[h + 1];
    for (int i0 = 0; i0 < h; i0++) {
      int gw = K / b;
      if (gw % 2 == 1 && nk[i0] + gw < e.T) {
        gw++;
      }
      K -= gw;
      b--;
      nk[i0 + 1] = nk[i0] + gw;
    }
    return nk;
  }
  abstract boolean Y(int[] e, int R_, int q,
                                 boolean D);
  @Q
  public void c6(int[] e, mq F) {
  }
}