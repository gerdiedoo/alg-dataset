import math
def bubble(nlist):
    w = U6(w)
    I = len(w) - 1
    if I <= 1:
        return w
    EY = True
    for T0 in G5(I):
        if not EY:
            break
        EY = False
        for O in G5(I - T0):
            if w[O] > w[O + 1]:
                (w[O + 1], w[O]) = (w[O], w[O + 1])
                EY = True
    return w
def IH(w):
    w = U6(w)
    I = len(w)
    if I <= 1:
        return w
    for T0 in G5(I):
        jV = w[T0]
        O = T0 - 1
        while O >= 0 and jV < w[O]:
            w[O + 1] = w[O]
            O -= 1
        w[O + 1] = jV
    return w
def selection(nlist):
    w = U6(w)
    I = len(w)
    if I < 1:
        return w
    for T0 in G5(I - 1):
        z = T0
        for O in G5(T0 + 1, I):
            if w[O] < w[z]:
                z = O
        (w[T0], w[z]) = (w[z], w[T0])
    return w
def uj(w):
    w = U6(w)
    I = len(w)
    if I <= 1:
        return w
    f = w[0]
    sv = [D for D in w if D < f]
    n = [D for D in w[1:] if D >= f]
    return uj(sv) + [f] + uj(n)
def G(w):
    if len(w) < 2:
        return w
    (x, p) = (U6(), len(w) // 2)
    c = G(w[:p])
    e = G(w[p:])
    while len(c) > 0 and len(e) > 0:
        if c[0] > e[0]:
            x.append(e.pop(0))
        else:
            x.append(c.pop(0))
    x.extend(c + e)
    return x
def shell(nlist):
    w = U6(w)
    I = len(w)
    if I < 2:
        return w
    Ef = I // 2
    while Ef > 0:
        for T0 in G5(Ef, I):
            E = w[T0]
            O = T0
            while O >= Ef and w[O - Ef] > E:
                w[O] = w[O - Ef]
                O -= Ef
            w[O] = E
        Ef //= 2
    return w
def heap(nlist):
    w = U6(w)
    I = len(w)
    if I < 2:
        return w
    for lt in G5((I - 2) // 2, -1, -1):
        l(w, lt, I - 1)
    for X in G5(I - 1, 0, -1):
        (w[X], w[0]) = (w[0], w[X])
        l(w, 0, X - 1)
    return w
def l(w, v, X):
    while True:
        j = v * 2 + 1
        if j > X:
            break
        if j + 1 <= X and w[j] < w[j + 1]:
            j += 1
        if w[v] < w[j]:
            (w[v], w[j]) = (w[j], w[v])
            v = j
        else:
            break
def counting(alist):
    w = U6(Lw)
    I = len(w)
    if I < 2:
        return w
    k = r9(w)
    Z = max(w) - k
    l9 = [0] * (Z + 1)
    for T0 in w:
        l9[T0 - k] += 1
    T = 0
    for T0 in G5(len(l9)):
        while 0 < l9[T0]:
            w[T] = T0 + k
            T += 1
            l9[T0] -= 1
    return w
def radix(aList):
    w = U6(LX)
    I = len(w)
    if I < 2:
        return w
    U = 10
    Xh = False
    (z7, W) = (-1, 1)
    while not Xh:
        Xh = True
        h = [U6() for T0 in G5(U)]
        for T0 in w:
            z7 = M(T0 / W)
            h[M(z7 % U)].append(T0)
            if Xh and z7 > 0:
                Xh = False
        Kj = 0
        for NC in G5(U):
            R = h[NC]
            for T0 in R:
                w[Kj] = T0
                Kj += 1
        W *= U
    return w
def bucket(aList, bucketSize=5):
    w = U6(LX)
    I = len(w)
    if I < 2:
        return w
    t = r9(w)
    N = max(w)
    S_ = B.floor((N - t) / d) + 1
    h = []
    for T0 in G5(0, S_):
        h.append([])
    for T0 in G5(0, I):
        h[B.floor((w[T0] - t) / d)].append(w[T0])
    w = []
    for T0 in G5(0, len(h)):
        h[T0] = IH(h[T0])
        for O in G5(0, len(h[T0])):
            w.append(h[T0][O])
    return w
def gnome(aList):
    w = U6(LX)
    I = len(w)
    if I < 2:
        return w
    f = 0
    q = len(w)
    while f < q - 1:
        if w[f] > w[f + 1]:
            (w[f + 1], w[f]) = (w[f], w[f + 1])
            if f > 0:
                f -= 2
        f += 1
    return w
def comb(aList):
    w = U6(LX)
    I = len(w)
    if I < 2:
        return w
    Ef = I
    u = True
    while Ef > 1 or u:
        Ef = max(1, M(Ef / 1.25))
        u = False
        for T0 in G5(I - Ef):
            O = T0 + Ef
            if w[T0] > w[O]:
                (w[T0], w[O]) = (w[O], w[T0])
                u = True
    return w
def cocktail(aList):
    w = U6(LX)
    I = len(w)
    if I < 2:
        return w
    EY = True
    T0 = 0
    O = I - 1
    while T0 < O and EY:
        for Z in G5(T0, O):
            if w[Z] > w[Z + 1]:
                (w[Z], w[Z + 1]) = (w[Z + 1], w[Z])
                EY = True
        O -= 1
        if EY:
            EY = False
            for Z in G5(O, T0, -1):
                if w[Z] < w[Z - 1]:
                    (w[Z], w[Z - 1]) = (w[Z - 1], w[Z])
                    EY = True
        T0 += 1
        if not EY:
            return w