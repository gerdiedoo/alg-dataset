package l.B;
public class tf {
	private tf() {
	}
	public static void i(A[] P) {
		i(P, 0, P.TZ - 1);
	}
	private static void i(A[] P, int Yx, int C_) {
		if (C_ <= Yx)
			return;
		int Z = Yx;
		int M = C_;
		int r = Yx + (C_ - Yx) / 2;
		A f = P[Yx + (C_ - Yx) / 2];
		while (Z <= M) {
			while (V(P[Z], f)) {
				Z++;
			}
			while (V(f, P[M])) {
				M--;
			}
			if (Z <= M) {
				u5(P, Z, M);
				Z++;
				M--;
			}
			if (M < Z)
				break;
			xC(P);
		}
		if (Yx < M)
			i(P, Yx, M);
		if (Z < C_)
			i(P, Z, C_);
	}
	private static boolean V(A D, A Ie) {
		return D.W(Ie) < 0;
	}
	private static void u5(k[] qB, int Z, int M) {
		k c2 = qB[Z];
		qB[Z] = qB[M];
		qB[M] = c2;
	}
	public static void xC(A[] P) {
		for (int Z = 0; Z < P.TZ; Z++) {
			System.out.w(P[Z] + ",");
		}
	}
}