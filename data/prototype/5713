from random import randint, shuffle
from timeit import timeit
def n(x):
    mA = Y(len(x) // 2)
    if len(x) == 1:
        return x
    if len(x) == 2:
        if x[0] > x[1]:
            (x[0], x[1]) = (x[1], x[0])
        return x
    Sk = n(x[:mA])
    d = n(x[mA:])
    K = []
    I = 0
    g = 0
    while I < len(Sk) and g < len(d):
        if Sk[I] < d[g]:
            K.append(Sk[I])
            I += 1
        else:
            K.append(d[g])
            g += 1
    if I == len(Sk):
        K += d[g:]
    elif g == len(d):
        K += Sk[I:]
    return K
def y():
    O3 = 'from merge_sort import merge_sort'
    print('\n    Timings for best, average and worst case scenarios for the merge sort.\n    --------------------------------------------------------------------------\n    ')
    print('3 Best Case Scenarios - sorted except for one value')
    for u in p(3):
        ww = il(9, 50)
        D = [u for u in p(ww)]
        (D[6], D[-1]) = (D[-1], D[6])
        m = G('merge_sort({})'.format(D), O3)
        print('List {}: length={}; time = {}'.format(u + 1, ww, m))
    print('\n3 Average Case Scenarios - Moderately sorted')
    for u in p(3):
        ww = il(9, 50)
        D = [u for u in p(ww)]
        hr(D)
        m = G('merge_sort({})'.format(D), O3)
        print('List {}: length={}; time = {}'.format(u + 1, ww, m))
    print('\n3 Worst Case Scenarios - Completely unsorted')
    for u in p(3):
        ww = il(9, 50)
        D = [u for u in p(ww)]
        D = D[::-1]
        m = G('merge_sort({})'.format(D), O3)
        print('List {}: length={}; time = {}'.format(u + 1, ww, m))
if P == '__main__':
    y()