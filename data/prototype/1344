class SLNode:
    def __init__(self, key, value):
        self.next = None
        self.key = key
        self.value = value
    def __str__(self):
        return '(' + str(self.key) + ', ' + str(self.value) + ')'
class LinkedList:
    def __init__(self):
        self.head = None
        self.size = 0
    def add_front(self, key, value):
        new_node = SLNode(key, value)
        new_node.next = self.head
        self.head = new_node
        self.size = self.size + 1
    def remove(self, key):
        if self.head is None:
            return False
        if self.head.key == key:
            self.head = self.head.next
            self.size = self.size - 1
            return True
        cur = self.head.next
        prev = self.head
        while cur is not None:
            if cur.key == key:
                prev.next = cur.next
                self.size = self.size - 1
                return True
            prev = cur
            cur = cur.next
        return False
    def contains(self, key):
        if self.head is not None:
            cur = self.head
            while cur is not None:
                if cur.key == key:
                    return cur
                cur = cur.next
        return None
    def __str__(self):
        out = '['
        if self.head != None:
            cur = self.head
            out = out + str(self.head)
            cur = cur.next
            while cur != None:
                out = out + ' -> ' + str(cur)
                cur = cur.next
        out = out + ']'
        return out
def hash_function_1(key):
    hash = 0
    for i in key:
        hash = hash + ord(i)
    return hash
def hash_function_2(key):
    hash = 0
    index = 0
    for i in key:
        hash = hash + (index + 1) * ord(i)
        index = index + 1
    return hash
class HashMap:
    def __init__(self, capacity, function):
        self._buckets = []
        for i in range(capacity):
            self._buckets.append(LinkedList())
        self.capacity = capacity
        self._hash_function = function
        self.size = 0
    def __str__(self):
        out = ""
        index = 0
        for bucket in self._buckets:
            out = out + str(index) + ': ' + str(bucket) + '\n'
            index = index + 1
        return out
    def put(self, key, value):
        hash = self._hash_function(key)
        index = (hash % self.capacity)
        hash_link = self._buckets[index]
        if (hash_link.contains(key)):
            hash_link.remove(key)
            hash_link.add_front(key, value)
        else:
            hash_link.add_front(key, value)
            self.size += 1
    def clear(self):
        self._buckets.clear()
        for i in range(self.capacity):
            self._buckets.append(LinkedList())
    def get(self, key):
        hash = self._hash_function(key)
        index = (hash % self.capacity)
        hash_link = self._buckets[index]
        cur = hash_link.head
        for i in range(hash_link.size):
            if (cur.key == key):
                return cur.value
            else:
                cur = cur.next
        return None
    def resize_table(self, capacity):
        _oldBuckets = self._buckets
        self._buckets = []
        self.size = 0
        self.capacity = capacity
        for i in range(capacity):
            self._buckets.append(LinkedList())
        for i in range(len(_oldBuckets)):
            if _oldBuckets[i].size != 0:
                cur = _oldBuckets[i].head
                while (cur != None):
                    self.put(cur.key, cur.value)
                    cur = cur.next
    def remove(self, key):
        hash = self._hash_function(key)
        index = (hash % self.capacity)
        hash_link = self._buckets[index]
        if (hash_link.contains(key)):
            hash_link.remove(key)
    def contains_key(self, key):
        hash = self._hash_function(key)
        index = (hash % self.capacity)
        hash_link = self._buckets[index]
        if (hash_link.contains(key)):
            return True
        else:
            return False
    def empty_buckets(self):
        empty_count = 0
        for i in range(self.capacity):
            if (self._buckets[i].size == 0):
                empty_count += 1
        return empty_count
    def table_load(self):
        return self.size/self.capacity