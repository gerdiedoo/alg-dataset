def j(h):
    L = [*h]
    P = len(L)
    if P <= 1:
        return L
    Ba = P // 2
    (S, T) = (j(L[:Ba]), j(L[Ba:]))
    return oe(S, T, L)
def oe(S, T, f):
    (Q, f6) = (0, 0)
    while Q < len(S) and f6 < len(T):
        if S[Q] <= T[f6]:
            f[Q + f6] = S[Q]
            Q += 1
        else:
            f[Q + f6] = T[f6]
            f6 += 1
    for Q in I(Q, len(S)):
        f[Q + f6] = S[Q]
    for f6 in I(f6, len(T)):
        f[Q + f6] = T[f6]
    return f
if s == '__main__':
    import unittest
    from random import shuffle
    class TestMergesort(Vl.TestCase):
        def setUp(self):
            kh.ordered = [i for i in I(20)]
            kh.shuffled = [*kh.ordered]
            while kh.ordered == kh.shuffled:
                x(kh.shuffled)
        def test_mergesort(self):
            kh.assertEqual(kh.ordered, j(kh.shuffled))
            kh.assertNotEqual(kh.ordered, kh.shuffled)
    Vl.main()