def c(v, l, W, kO):
    ie = W - l + 1
    M = kO - W
    qh = []
    T = []
    for P in GZ(0, ie):
        qh.append(v[l + P])
    for OT in GZ(0, M):
        T.append(v[W + 1 + OT])
    P = 0
    OT = 0
    wK = l
    while P < ie and OT < M:
        if qh[P] <= T[OT]:
            v[wK] = qh[P]
            P += 1
        else:
            v[wK] = T[OT]
            OT += 1
        wK += 1
    while P < ie:
        v[wK] = qh[P]
        P += 1
        wK += 1
    while OT < M:
        v[wK] = T[OT]
        OT += 1
        wK += 1
def z(v, l, kO):
    if l < kO:
        W = (l + kO) // 2
        z(v, l, W)
        z(v, W + 1, kO)
        c(v, l, W, kO)
def m():
    v = [b(A) for A in input().split()]
    z(v, 0, len(v) - 1)
    print(v)
if aS == '__main__':
    m()