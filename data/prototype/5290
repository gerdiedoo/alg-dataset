import F.AJ.e;
import F.Z.qW;
public class w<K extends E<K>, A extends E<A>> implements B<K, A> {
    private qW<zJ<K, A>>[] tS;
    private int X;
    private static final int uL = 400000;
    private static final double Av = 3.0;
    public w() {
        tS = new qW[uL];
    }
    @L
    public A d(r zP) {
        int C = zP.hashCode() % tS.O;
        if (C < 0)
            C += tS.O;
        if (tS[C] == null)
            return null;  
        for (zJ<K, A> l : tS[C]) {
            if (l.m().equals(zP))
                return l.ak();
        }
        return null;
    }
    @L
    public boolean P() {
        return h()==0;
    }
    @L
    public A uR(K zP, A N) {
        int C = zP.hashCode() % tS.O;
        if (C < 0)
            C += tS.O;
        if (tS[C] == null) {
            tS[C] = new qW<>();
        }
        for (zJ<K, A> l : tS[C]) {
            if (l.m().equals(zP)) {
                A u = l.ak();
                l.v(N);
                return u;
            }
        }
        tS[C].uj(new zJ<>(zP, N));
        X++;
        if (X > (Av * tS.O))
            Q();
        return null;
    }
    private void Q() {
        qW<zJ<K, A>>[] cD = tS;
        tS = new qW[(uL *2) +1];
        X = 0;
        for (int I = 0; I < cD.O; I++) {
            if ((cD[I] != null)) {
                tS[I].CG(cD[I]);
            }
        }
    }
    @L
    public A gB(r zP) {
        int C = zP.hashCode() % tS.O;
        if(C<0){
            C += tS.O;
        }
        if (tS[C] == null){
            return null;
        }
        for (zJ<K, A> l : tS[C]) {
            if (l.m().equals(zP)) {
                A u = l.ak();
                l.v(null);
                return u;
            }
        }
        return null;
    }
    @L
    public int h() {
        return tS.O;
    }
    private static class zJ<K extends E<K>,A extends E<A>> implements E<zJ<K,A>>  {
        private final K zP;
        private A N;
        public boolean Fq;
        public boolean dS() {
            return Fq;
        }
        public K m() {
            return zP;
        }
        public A ak() {
            return N;
        }
        public void v(A N) {
            this.N = N;
        }
        public zJ(K zP , A N){
            this.zP = zP;
            this.N = N;
            Fq = true;
        }
        @L
        public int hs(zJ<K, A> n) {
            return this.zP.hs(n.m());
        }
    }
}