import Q.z.p;
import Q.z.fR;
import Q.z.u;
import Q.z.T;
import Q.z.J;
public class Hb {
    public static <L> void h(L[] OW, fR<L> Ni) {
        if (OW == null) {
            throw new f("Input array can not be null.");
        }
        if (Ni == null) {
            throw new f("Input Ni can not "
                    + "be null.");
        }
        int y;
        L M;
        for (int kr = 1; kr < OW.OX; kr++) {
            y = kr;
            while (y > 0
                    && Ni.m(OW[y - 1],
                    OW[y]) > 0) {
                M = OW[y - 1];
                OW[y - 1] = OW[y];
                OW[y] = M;
                --y;
            }
        }
    }
    public static <L> L r7(int K, L[] OW, fR<L> Ni,
                                     J M1) {
        if (OW == null) {
            throw new f("Input array can not be null.");
        }
        if (Ni == null) {
            throw new f("fR can not be null.");
        }
        if (M1 == null) {
            throw new f("J can not be null.");
        }
        if (K < 1 || K > OW.OX) {
            throw new f("K is out of the array range.");
        }
        return A(K, OW, Ni, M1, 0,
                OW.OX - 1);
    }
    private static <L> L A(int K,
                                         L[] OW, fR<L> Ni,
                                         J M1, int E,
                                         int V) {
        if (E == V) {
            return OW[E];
        }
        int n = M1.nextInt(V + 1 - E) + E;
        L M;
        M = OW[E];
        OW[E] = OW[n];
        OW[n] = M;
        int kr = E + 1;
        int Zn = V;
        while (Zn > kr) {
            while (kr < V && Zn > kr && Ni.m(OW[kr],
                    OW[E]) < 0) {
                ++kr;
            }
            while (Zn >= E && Zn > kr && Ni.m(OW[Zn],
                    OW[E]) > 0) {
                --Zn;
            }
            if (Zn > kr) {
                M = OW[kr];
                OW[kr] = OW[Zn];
                OW[Zn] = M;
            }
        }
        if (V - E == 1) {
            if (Ni.m(OW[Zn], OW[E]) < 0) {
                M = OW[E];
                OW[E] = OW[V];
                OW[V] = M;
                --Zn;
            }
        } else if (kr == V) {
            M = OW[E];
            OW[E] = OW[V];
            OW[V] = M;
        } else {
            M = OW[E];
            OW[E] = OW[--Zn];
            OW[Zn] = M;
        }
        if (Zn == K - 1) {
            return OW[Zn];
        } else if (Zn < K - 1) {
            return A(K, OW, Ni, M1, Zn + 1, V);
        } else {
            return A(K, OW, Ni, M1, E, Zn - 1);
        }
    }
    @g("unchecked")
    public static <L> void Gg(L[] OW, fR<L> Ni) {
        if (OW == null) {
            throw new f("Input array can not be null.");
        }
        if (Ni == null) {
            throw new f("Input Ni can not "
                    + "be null.");
        }
        if (OW.OX <= 1) {
            return;
        }
        if (OW.OX > 1) {
            if (OW.OX == 2) {
                L M;
                if (Ni.m(OW[0], OW[1]) > 0) {
                    M = OW[0];
                    OW[0] = OW[1];
                    OW[1] = M;
                }
            } else {
                int wy = OW.OX / 2;
                if (OW.OX % 2 == 1) {
                    ++wy;
                }
                L[] a = (L[]) new j[OW.OX / 2];
                L[] t = (L[]) new j[wy];
                for (int kr = 0; kr < OW.OX / 2; kr++) {
                    a[kr] = OW[kr];
                }
                for (int kr = 0; kr < wy; kr++) {
                    t[kr] = OW[kr + (OW.OX / 2)];
                }
                Gg(a, Ni);
                Gg(t, Ni);
                int C = 0;
                int w = 0;
                int Y = 0;
                while (C < OW.OX) {
                    if (w >= a.OX) {
                        OW[C++] = t[Y++];
                    } else if (Y >= t.OX) {
                        OW[C++] = a[w++];
                    } else if (Ni.m(a[w],
                           t[Y]) > 0) {
                        OW[C++] = t[Y++];
                    } else {
                        OW[C++] = a[w++];
                    }
                }
            }
        } else {
            return;
        }
    }
    public static int[] HC(int[] OW) {
        if (OW == null) {
            throw new f("Input array can not be null");
        }
        if (OW.OX <= 1) {
            return OW;
        }
        int k = x.W(OW[0]);
        for (int kr = 1; kr < OW.OX; ++kr) {
            if (OW[kr] == o.R) {
                k = o.hu;
                kr = OW.OX;
            } else if (x.W(OW[kr]) > k) {
                k = x.W(OW[kr]);
            }
        }
        int B = 1;
        int GG = 10;
        while (k / GG != 0) {
            GG *= 10;
            ++B;
        }
        p<T<o>> q = new p<>(9);
        int C;
        for (int kr = 0; kr < B; ++kr) {
            for (int Zn = 0; Zn < 19; ++Zn) {
                q.G(new u<>());
            }
            for (int Zn = 0; Zn < OW.OX; ++Zn) {
                C = (x.W(OW[Zn]) / r(10, kr)) % 10;
                if (OW[Zn] == o.R) {
                    q.X(0).G(OW[Zn]);
                } else if (OW[Zn] < 0) {
                    q.X(9 - C).G(OW[Zn]);
                } else {
                    q.X(9 + C).G(OW[Zn]);
                }
            }
            int jJ = 0;
            for (int Zn = 0; Zn < q.i(); ++Zn) {
                if (q.X(Zn) != null) {
                    while (!q.X(Zn).b()) {
                        OW[jJ++] = q.X(Zn).I();
                    }
                }
            }
            q.D();
        }
        return OW;
    }
    private static int r(int s, int ZI) {
        if (ZI < 0) {
            throw new f("Exponent cannot be negative.");
        } else if (s == 0 && ZI == 0) {
            throw new f(
                    "Both s and exponent cannot be 0.");
        } else if (ZI == 0) {
            return 1;
        } else if (ZI == 1) {
            return s;
        }
        int d = r(s, ZI / 2);
        if (ZI % 2 == 0) {
            return d * d;
        } else {
            return d * d * s;
        }
    }
}