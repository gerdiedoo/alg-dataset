Array.prototype.elem = function (index) {
  return this[index-1];
};
Array.prototype.elemSwap = function (index1, index2) {
  var temp = this[index1 - 1];
  this[index1 - 1] = this[index2 - 1];
  this[index2 - 1] = temp;
};
Array.prototype.swap = function (index1, index2) {
  var temp = this[index1];
  this[index1] = this[index2];
  this[index2] = temp;
};
Array.prototype.clone = function() {
  return this.slice(0);
};
var sort = function (algo, arr) {
  function selectionSort (arr) {
    for (var i = 0; i < arr.length; i++) {
      var min = arr[i];
      var minIndex = i;
      for (var j = i+1; j < arr.length; j++) {
        if (arr[j] < min) {
          min = arr[j];
          minIndex = j;
        }
      }
      arr.swap(i, minIndex);
    }
    return arr;
  }
  function insertSort (arr) {
    for (var i = 1; i <= arr.length; i++) {
      for (var j = i-1; j >= 0; j--) {
        if (arr[j+1] < arr[j]) {
          arr.swap(j, j+1);
        }
      }
    }
    return arr;
  }
  function mergeSort (arr) {
    if (arr.length <= 1) {
      return arr;
    }
    var middleIndex = Math.floor(arr.length/2);
    var leftSorted = mergeSort(arr.slice(0, middleIndex));
    var rightSorted = mergeSort(arr.slice(middleIndex));
    return merge(leftSorted, rightSorted);
  }
  function merge (left, right) {
    var sortedArr = [];
    var leftInd = 0;
    var rightInd = 0;
    while (leftInd < left.length || rightInd < right.length) {
      if (rightInd === right.length || left[leftInd] <= right[rightInd]) {
        sortedArr.push(left[leftInd]);
        ++leftInd;
      } else {
        sortedArr.push(right[rightInd]);
        ++rightInd;
      }
    }
    return sortedArr;
  }
  function Heap (arr) {
    this.heapArray = arr.clone();
    this.heapSize = this.heapArray.length;
    this.numberOfNonLeaveNodes = Math.ceil(this.heapSize/2);
    this.buildHeap();
    this.sortedArray = [];
  }
  Heap.prototype.buildHeap = function () {
    for(var i = this.numberOfNonLeaveNodes; i >= 1; --i) {
      this.heapifyNode(i);
    }
  };
  Heap.prototype.heapifyNode = function (index) {
    var leftIndex = 2 * index;
    var rightIndex = 2 * index + 1;
    var smallest = index;
    if (leftIndex <= this.heapSize && this.heapArray.elem(leftIndex) < this.heapArray.elem(smallest)) {
      smallest = leftIndex;
    }
    if (rightIndex <= this.heapSize && this.heapArray.elem(rightIndex) < this.heapArray.elem(smallest)) {
      smallest = rightIndex;
    }
    if (smallest != index) {
      this.heapArray.elemSwap(index, smallest);
      this.heapifyNode(smallest);
    }
  };
  Heap.prototype.sort = function () {
    if (this.sortedArray.length !== 0) {
      return this.sortedArray;
    } else {
      for (var i = 1; i <= this.heapSize; ++i) {
        this.heapArray.elemSwap(1, this.heapArray.length);
        this.sortedArray[i - 1] = this.heapArray.pop();
        this.heapifyNode(1);
      }
      return this.sortedArray;
    }
  };
  switch (algo) {
    case "SELECTION":
      return selectionSort(arr);
    case "INSERT":
      return insertSort(arr);
    case "MERGE":
      return mergeSort(arr);
    case "HEAP":
      return new Heap(arr).sort();
    default:
      throw "Sorting algorithm not found";
  }
};