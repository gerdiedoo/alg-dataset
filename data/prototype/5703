def Q(iL, l, UF, m):
    E = UF - l + 1
    k = m - UF
    RT = []
    F2 = []
    for bs in d(0, E):
        RT.append(iL[l + bs])
    for j in d(0, k):
        F2.append(iL[UF + 1 + j])
    bs = 0
    j = 0
    G = l
    while bs < E and j < k:
        if RT[bs] <= F2[j]:
            iL[G] = RT[bs]
            bs += 1
        else:
            iL[G] = F2[j]
            j += 1
        G += 1
    while bs < E:
        iL[G] = RT[bs]
        bs += 1
        G += 1
    while j < k:
        iL[G] = F2[j]
        j += 1
        G += 1
def r(iL, l, m):
    if l < m:
        UF = (l + m) // 2
        r(iL, l, UF)
        r(iL, UF + 1, m)
        Q(iL, l, UF, m)
def Np():
    iL = [P(k1) for k1 in input().split()]
    r(iL, 0, len(iL) - 1)
    print(iL)
if i == '__main__':
    Np()