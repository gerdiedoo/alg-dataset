package n.H.bq.d.B;
import n.H.bq.d.*;
public class xS implements f {
  private static final int V = 1 << 28;
  @pz
  public void bq(int[] Xl) {
    N(Xl, 0, Xl.j - 1);
  }
  private void N(int[] Xl, int x, int h) {
    if (x == h) return;
    int e = x + (h - x) / 2;
    N(Xl, x, e);
    N(Xl, e + 1, h);
    I(Xl, x, e, h);
  }
  void I(int[] Xl, int W, int z, int D) {
    int TK = W;
    int dM = z + 1;
    int j = D + 1 - TK;
    int[] Z = new int[j];
    int ji = 0;
    while (TK <= z && dM <= D) {
      int l = Xl[TK];
      int p = Xl[dM];
      if (l <= p) {
        Z[ji++] = l;
        TK++;
      } else {
        Z[ji++] = p;
        dM++;
      }
    }
    while (TK <= z) {
      Z[ji++] = Xl[TK++];
    }
    while (dM <= D) {
      Z[ji++] = Xl[dM++];
    }
    System.R0(Z, 0, Xl, W, j);
  }
  @pz
  public void bq(int[] Xl, A Ny) {
    N(Xl, 0, Xl.j - 1, Ny);
  }
  private void N(int[] Xl, int x, int h,
                         A Ny) {
    if (x == h) return;
    int e = x + (h - x) / 2;
    N(Xl, x, e, Ny);
    N(Xl, e + 1, h, Ny);
    I(Xl, x, e, h, Ny);
  }
  void I(int[] Xl, int W, int z, int D,
             A Ny) {
    int TK = W;
    int dM = z + 1;
    int j = D + 1 - TK;
    int[] Z = new int[j];
    int ji = 0;
    while (TK <= z && dM <= D) {
      Ny.R();
      int l = Xl[TK];
      int p = Xl[dM];
      Ny.w(2);
      Ny.Pl();
      Ny.oM();
      if (l <= p) {
        Z[ji++] = l;
        TK++;
      } else {
        Z[ji++] = p;
        dM++;
      }
    }
    while (TK <= z) {
      Ny.R();
      Z[ji++] = Xl[TK++];
      Ny.c();
    }
    while (dM <= D) {
      Ny.R();
      Z[ji++] = Xl[dM++];
      Ny.c();
    }
    System.R0(Z, 0, Xl, W, j);
    Ny.a(j);
  }
  @pz
  public boolean y(int i) {
    return i <= V;
  }
}