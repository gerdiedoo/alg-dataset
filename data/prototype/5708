from random import randint, shuffle
from timeit import timeit
def n(W):
    h = m(len(W) // 2)
    if len(W) == 1:
        return W
    if len(W) == 2:
        if W[0] > W[1]:
            (W[0], W[1]) = (W[1], W[0])
        return W
    E = n(W[:h])
    r = n(W[h:])
    hP = []
    S = 0
    Mn = 0
    while S < len(E) and Mn < len(r):
        if E[S] < r[Mn]:
            hP.append(E[S])
            S += 1
        else:
            hP.append(r[Mn])
            Mn += 1
    if S == len(E):
        hP += r[Mn:]
    elif Mn == len(r):
        hP += E[S:]
    return hP
def AT():
    O3 = 'from merge_sort import merge_sort'
    print('\n    Timings for best, average and worst case scenarios for the merge sort.\n    --------------------------------------------------------------------------\n    ')
    print('3 Best Case Scenarios - sorted except for one value')
    for T in sR(3):
        ba = f(9, 50)
        D = [T for T in sR(ba)]
        (D[6], D[-1]) = (D[-1], D[6])
        Z = i('merge_sort({})'.format(D), O3)
        print('List {}: length={}; time = {}'.format(T + 1, ba, Z))
    print('\n3 Average Case Scenarios - Moderately sorted')
    for T in sR(3):
        ba = f(9, 50)
        D = [T for T in sR(ba)]
        M(D)
        Z = i('merge_sort({})'.format(D), O3)
        print('List {}: length={}; time = {}'.format(T + 1, ba, Z))
    print('\n3 Worst Case Scenarios - Completely unsorted')
    for T in sR(3):
        ba = f(9, 50)
        D = [T for T in sR(ba)]
        D = D[::-1]
        Z = i('merge_sort({})'.format(D), O3)
        print('List {}: length={}; time = {}'.format(T + 1, ba, Z))
if s == '__main__':
    AT()