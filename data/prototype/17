package org.joyfulmonster.util.concurrent.internal;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReferenceArray;
public class ConcurrentElasticHashMapImpl<K, V> implements MetricsSupport {
    private static final String ILLEGAL_ARGUMENT_EXPECTION_MSG = "The key or value can not be null.";
    public static final int DEFAULT_BUCKET_SIZE = 8092;  
    public static final int DEFAULT_BUCKET_COUNT = 8;
    public static final float DEFAULT_BUKCET_LOAD_FACTOR = 0.75f;
    public static final int MAX_CAPACITY = 1 << 30;
    public static final int MIN_BUCKET_COUNT = 2;
    public static final int MAX_BUCKET_COUNT = MAX_CAPACITY / MIN_BUCKET_COUNT;
    public static final float MAX_BUCKET_LOADFACTOR = 0.95f;
    private final Directory directory;
    private final AtomicInteger totalSplitCount;
    private final AtomicInteger totalEntryCount;
    public ConcurrentElasticHashMapImpl() {
        this(DEFAULT_BUCKET_SIZE, DEFAULT_BUCKET_COUNT, DEFAULT_BUKCET_LOAD_FACTOR);
    }
    public ConcurrentElasticHashMapImpl(int bucketSize, int initBucketCount, float bucketLoadFactor) {
        totalSplitCount = new AtomicInteger(0);
        totalEntryCount = new AtomicInteger(0);
        initBucketCount = lowestUpperBound(initBucketCount);
        bucketLoadFactor = (bucketLoadFactor < MAX_BUCKET_LOADFACTOR) ? bucketLoadFactor : MAX_BUCKET_LOADFACTOR;
        directory = DirectoryFactory.create(initBucketCount, bucketSize, bucketLoadFactor, totalEntryCount, totalSplitCount);
    }
    public V put(K key, V value) {
        if (key == null || value == null) {
            throw new IllegalArgumentException(ILLEGAL_ARGUMENT_EXPECTION_MSG);
        }
        return put(key, value, true);
    }
    public V putIfAbsent(K key, V value) {
        if (key == null || value == null) {
            throw new IllegalArgumentException(ILLEGAL_ARGUMENT_EXPECTION_MSG);
        }
        return put(key, value, false);
    }
    private V put(K key, V value, boolean replaceIfPresent) {
        int hashCode = HashStrategy.getInstance().hash(key.hashCode());
        while (true) {
            Bucket<K, V> bucket = directory.getBucket(hashCode);
            bucket.lock();
            if (bucket.isInvalid()) {
                bucket.unlock();
                continue;
            }
            else {
                try {
                    V result = null;
                    boolean putSuccess;
                    if (bucket.hasMoreSpace()) {
                        try {
                            result = (V) bucket.put(key, value, hashCode, replaceIfPresent);
                            putSuccess = true;
                        } catch (BucketOverflowError soe) {
                            putSuccess = false;
                        }
                    } else {
                        putSuccess = false;
                    }
                    if (!putSuccess) {
                        result = bucket.splitAndPut(key, value, hashCode, replaceIfPresent);
                    }
                    return result;
                } finally {
                    bucket.unlock();
                }
            }
        }
    }
    public boolean remove(K key, V value) {
        if (key == null || value == null) {
            throw new IllegalArgumentException(ILLEGAL_ARGUMENT_EXPECTION_MSG);
        }
        int hashValue = HashStrategy.getInstance().hash(key.hashCode());
        while (true) {
            Bucket bucket = directory.getBucket(hashValue);
            bucket.lock();
            try {
                if (!bucket.isInvalid()) {
                    return bucket.remove(key, hashValue, value) != null;
                }
            } finally {
                bucket.unlock();
            }
        }
    }
    public V replace(K key, V value) {
        if (key == null || value == null) {
            throw new IllegalArgumentException(ILLEGAL_ARGUMENT_EXPECTION_MSG);
        }
        int hashValue = HashStrategy.getInstance().hash(key.hashCode());
        while (true) {
            Bucket bucket = directory.getBucket(hashValue);
            bucket.lock();
            try {
                if (!bucket.isInvalid()) {
                    return (V) bucket.replace(key, hashValue, null, value);
                }
            } finally {
                bucket.unlock();
            }
        }
    }
    public boolean replace(K key, V oldValue, V newValue) {
        if (key == null || oldValue == null || newValue == null) {
            throw new IllegalArgumentException(ILLEGAL_ARGUMENT_EXPECTION_MSG);
        }
        int hashValue = HashStrategy.getInstance().hash(key.hashCode());
        while (true) {
            Bucket bucket = directory.getBucket(hashValue);
            bucket.lock();
            try {
                if (!bucket.isInvalid()) {
                    return bucket.replace(key, hashValue, oldValue, newValue) != null;
                }
            } finally {
                bucket.unlock();
            }
        }
    }
    public V get(K key) {
        if (key == null) {
            throw new IllegalArgumentException(ILLEGAL_ARGUMENT_EXPECTION_MSG);
        }
        int hashCode = HashStrategy.getInstance().hash(key.hashCode());
        Bucket<K, V> bucket = directory.getBucket(hashCode);
        return bucket.get(key, hashCode);
    }
    public V remove(K key) {
        if (key == null) {
            throw new IllegalArgumentException(ILLEGAL_ARGUMENT_EXPECTION_MSG);
        }
        int hashValue = HashStrategy.getInstance().hash(key.hashCode());
        while (true) {
            Bucket<K, V> bucket = directory.getBucket(hashValue);
            bucket.lock();
            try {
                if (!bucket.isInvalid()) {
                    return (V) bucket.remove(key, hashValue, null);
                }
            } finally {
                bucket.unlock();
            }
        }
    }
    public int size() {
        return totalEntryCount.get();
    }
    public int totalSplits() {
        return totalSplitCount.get();
    }
    public int getBucketCount() {
        return directory.getBucketCount();
    }
    @Override
    public int getMaxBucketCountDifference() {
        AtomicReferenceArray<Bucket> buckets = directory.get();
        int min = Integer.MAX_VALUE;
        int max = Integer.MIN_VALUE;
        for (int i=0; i<buckets.length(); i++) {
            Bucket bucket = buckets.get(i);
            if (bucket instanceof BucketMetricsSupport) {
                int entries = ((BucketMetricsSupport)bucket).getBucketEntries();
                if (entries < min) {
                    min = entries;
                }
                if (entries > max) {
                    max = entries;
                }
            }
        }
        return max-min;
    }
    private int lowestUpperBound (int i) {
        int seed = 1;
        while (seed < i) {
            seed = seed << 1;
        }
        return seed;
    }
}