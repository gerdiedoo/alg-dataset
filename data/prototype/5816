from random import randint, shuffle
from timeit import timeit
def YO(DP):
    if len(DP) == 1:
        return DP
    if len(DP) > 1:
        o = DP[0]
        yW = 1
        q = len(DP) - 1
        while yW <= q:
            if DP[yW] > o and DP[q] < o:
                (DP[yW], DP[q]) = (DP[q], DP[yW])
                yW += 1
                q -= 1
            elif DP[yW] <= o and DP[q] < o:
                yW += 1
            elif DP[yW] > o and DP[q] >= o:
                q -= 1
            elif DP[yW] <= o and DP[q] >= o:
                yW += 1
                q -= 1
        (DP[0], DP[q]) = (DP[q], DP[0])
        QG = q + 1
        c = YO(DP[:q])
        y = YO(DP[QG:])
        return c + [DP[q]] + y
    else:
        return DP
def J():
    Q = 'from quick import quick_sort'
    print('\n    Timings for best, average and worst case scenarios for the merge sort.\n    --------------------------------------------------------------------------\n    ')
    print('3 Best Case Scenarios - sorted except for one value')
    for K in zo(3):
        h = Ss(9, 50)
        D = [K for K in zo(h)]
        (D[6], D[-1]) = (D[-1], D[6])
        ji = F('quick_sort({})'.format(D), Q)
        print('List {}: length={}; time = {}'.format(K + 1, h, ji))
    print('\n3 Average Case Scenarios - Moderately sorted')
    for K in zo(3):
        h = Ss(9, 50)
        D = [K for K in zo(h)]
        B(D)
        ji = F('quick_sort({})'.format(D), Q)
        print('List {}: length={}; time = {}'.format(K + 1, h, ji))
    print('\n3 Worst Case Scenarios - Completely unsorted')
    for K in zo(3):
        h = Ss(9, 50)
        D = [K for K in zo(h)]
        D = D[::-1]
        ji = F('quick_sort({})'.format(D), Q)
        print('List {}: length={}; time = {}'.format(K + 1, h, ji))
if s == '__main__':
    J()