from typing import Optional, List
class _DoubleNode:
    def __init__(self, value: 'object') -> None:
        self.data, self.next, self.prev = value, None, None
class DoubleLinkedList:
    def __init__(self, items: List[Optional['object']]) -> None:
        if not items:
            self._first = None
        else:
            self._first = _DoubleNode(items[0])
            prev, curr = None, self._first
            for item in items[1:]:
                curr.next = _DoubleNode(item)
                prev, curr = curr, curr.next
                prev.next, curr.prev = curr, prev
    def __len__(self) -> int:
        count, current = 0, self._first
        while current:
            count += 1
            current = current.next
        return count
    def __str__(self) -> str:
        holder = ""
        curr = self._first
        if curr:
            holder += str(curr.data)
        while curr:
            curr = curr.next
            if curr:
                holder += " <-> " + str(curr.data)
        return holder
    def insert(self, index: int, value: 'object') -> None:
        if not self._first:
            self._first = _DoubleNode(value)
        else:
            new_node = _DoubleNode(value)
            curr = self._first
            if index == 0:
                new_node.next = curr
                curr.prev = new_node
                self._first = new_node
            elif len(self) <= index:
                while curr.next:
                    curr = curr.next
                new_node.prev, curr.next = curr, new_node
            else:
                count = 0
                while count < index:
                    count += 1
                    curr = curr.next
                curr.prev.next = new_node
                new_node.prev = curr.prev
                new_node.next = curr
                curr.prev = new_node
    def __contains__(self, item):
        cur = self._first
        while cur:
            if cur.data == item:
                return True
            cur = cur.next
        return False
    def remove(self, item:'object') -> None:
        if not (item in self):
            raise ValueError
        elif self._first.data == item:
            self._first = self._first.next
            if len(self) > 0:
                self._first.prev = None
        else:
            prev, curr = None, self._first
            while curr.data != item:
                nxt = curr.next
                prev, curr = curr, nxt
            prev.next = curr.next
            if curr:
                curr.next.prev = prev
    def pop(self) -> 'object':
        if not self._first:
            raise IndexError
        elif len(self) == 1:
            placeholder = self._first.data
            self._first = None
            return placeholder
        else:
            prev, curr, placeholder = None, self._first, self._first.next
            while placeholder:
                prev, curr, placeholder = curr, placeholder, placeholder.next
            prev.next = placeholder
            return curr.data
    def append(self, item: 'object') -> None:
        new_node = _DoubleNode(item)
        if len(self) == 0:
            self._first = new_node
        else:
            prev, curr = None, self._first
            while curr:
                nxt = curr.next
                prev, curr = curr, nxt
            prev.next = new_node
            new_node.prev = prev
if __name__ == "__main__":
    import doctest
    doctest.testmod()