def L(D, V, r, t):
    E = r - V + 1
    M = t - r
    e = []
    TW = []
    for Rj in zG(0, E):
        e.append(D[V + Rj])
    for sn in zG(0, M):
        TW.append(D[r + 1 + sn])
    Rj = 0
    sn = 0
    I = V
    while Rj < E and sn < M:
        if e[Rj] <= TW[sn]:
            D[I] = e[Rj]
            Rj += 1
        else:
            D[I] = TW[sn]
            sn += 1
        I += 1
    while Rj < E:
        D[I] = e[Rj]
        Rj += 1
        I += 1
    while sn < M:
        D[I] = TW[sn]
        sn += 1
        I += 1
def Cj(D, V, t):
    if V < t:
        r = (V + t) // 2
        Cj(D, V, r)
        Cj(D, r + 1, t)
        L(D, V, r, t)
def P():
    D = [B(n1) for n1 in input().split()]
    Cj(D, 0, len(D) - 1)
    print(D)
if s2 == '__main__':
    P()