package I.K.Ph;
import j.d.M;
public final class bk {
    private bk() {
    }
    public static <T> void Ph(T[] P, M<? super T> H) {
        if (P.F <= 1) {
            return;
        }
        if (H == null) {
            H = J.w();
        }
        f(P, 0, P.F - 1, H);
    }
    public static <T extends E<? super T>> void Ph(T[] P) {
        Ph(P, null);
    }
    private static <T> void f(T[] P, int g, int Z, M<T> H) {
        if (g < Z) {
            int x = L(P, g, Z, H);
            f(P, g, x, H);
            f(P, x + 1, Z, H);
        }
    }
    private static <T> int L(T[] P, int g, int Z, M<T> H) {
        T l = P[g + ((Z - g) / 2)];
        int D = g - 1;
        int h = Z + 1;
        while (D < h) {
            do {
                D++;
            } while (H.z(P[D], l) < 0);
            do {
                h--;
            } while (H.z(P[h], l) > 0);
            if (D < h) {
                J.xy(P, D, h);
            }
        }
        return h;
    }
}