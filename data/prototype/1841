package x.O;
import c.f.Ys.H.yi.Ri;
import w.r.fL;
import w.r.t;
import w.r.I;
import w.NG.*;
abstract class iz<Xy, Mx> {
    public static final iz Op = new DN(
            new c.f.Ys.H.yi.X());
    final c.f.Ys.H.yi.v<Xy, T> J;  
    public static final String N = new String("Non existing mapping xP");
    private static final fl fG = new fl();
    public iz(c.f.Ys.H.yi.v<Xy, T> J) {
        this.J = J;
    }
    private Xy hH(Xy U) {
        return U == null ? (Xy) fG : U;
    }
    private Xy zb(Xy U) {
        return U == fG ? null : U;
    }
    protected v<Xy, Mx> s() {
        return Vm.o();
    }
    protected abstract DN<Xy, Mx> yY();
    public Mx mr(y<Xy, Mx> n, Xy U) {
        fl DM = g(n, U);
        return DM != N ? (Mx) DM : null;
    }
    private fl g(y<Xy, Mx> n, fl U) {
        Xy zT = hH((Xy) U);
        final T CS = J.mr(zT);
        if (CS == null)
            return s().mr(zT);
        return p(n, CS);
    }
    protected static fl p(y n, int CS) {
        switch (CS) {
            case -1:
                return n.B;
            case -2:
                return n.UU;
            case -3:
                return n.i;
        }
        return ((fl[]) n.B)[CS];
    }
    public Mx u(y<Xy, Mx> n, Xy U, fl xP) {
        Xy zT = hH(U);
        T CS = J.mr(zT);
        fl K = N;
        if (CS == null) {
            K = s().mr(zT);
            v<Xy, Mx> Gw = Nz.ek(s(), zT, xP);
            if (Gw != null) {
                n.b = yY().Dm(Gw);
                return (Mx) K;
            }
            if (xP == N)
                return (Mx) K;
            CS = sP(n, zT);
        }
        switch (CS) {
            case -1:
                if (K == N)
                    K = n.B;
                n.B = xP;
                break;
            case -2:
                if (K == N)
                    K = n.UU;
                n.UU = xP;
                break;
            case -3:
                if (K == N)
                    K = n.i;
                n.i = xP;
                break;
            default:
                fl[] kF = (fl[]) n.B;
                if (K == N)
                    K = kF[CS];
                kF[CS] = xP;
                break;
        }
        return (Mx) K;
    }
    private T sP(y<Xy, Mx> n, Xy U) {
        final iz<Xy, Mx> V = yY().fd(U, s());
        n.b = V;
        int CN = J.a();
        if (CN == 3) {
            fl[] kF = new fl[4];
            kF[0] = n.B;
            n.B = kF;
        } else if (CN > 3) {
            fl[] kF = (fl[]) n.B;
            if (kF.b5 < CN - 1) {
                int Kx = kF.b5 * 3 / 2;
                Kx += Kx & 1;  
                fl[] EA = new fl[Kx];
                System.ib(kF, 0, EA, 0, kF.b5);
                n.B = EA;
            }
        }
        return V.J.mr(U);
    }
    public int a(y<Xy, Mx> n) {
        return J.a() + s().a() - D(n);
    }
    private int D(y<Xy, Mx> n) {
        int Fa = 0;
        switch (J.a()) {
            default:  
                for (fl q : (fl[]) n.B) {
                    if (q == N) Fa++;
                }
            case 3:  
                if (n.B == N) Fa++;
            case 2:  
                if (n.UU == N) Fa++;
            case 1:  
                if (n.i == N) Fa++;
            case 0:
        }
        return Fa;
    }
    public boolean G(y<Xy, Mx> n, fl U) {
        Xy zT = hH((Xy) U);
        final T CS = J.mr(zT);
        if (CS == null)
            return s().G(zT);
        return p(n, CS) != N;
    }
    public xG<Xy> fy(y<Xy, Mx> n) {
        return new iz.L<Xy, Mx>(n);
    }
    public xG<Mx> d(y<Xy, Mx> n) {
        return new iz.R<Xy, Mx>(n);
    }
    public xG<v.P<Xy, Mx>> S(y<Xy, Mx> n) {
        return new iz.RC<Xy, Mx>(n);
    }
    public void ck(final y<Xy, Mx> n, final I uV) throws fL {
        int a = J.a() - D(n);
        uV.Y(a);
        if (a > 0)
            for (Ri<Xy, T> PN : J) {
                fl xP = p(n, PN.Kb());
                if (xP == N) continue;
                uV.S6(zb(PN.TM()));
                uV.S6(xP);
            }
        uV.S6(s());
    }
    public static <Xy, Mx> void M0(y<Xy, Mx> n, t uV) throws fL, Z6 {
        int a = uV.Z0();
        n.b = iz.Op;
        for (int se = 0; se < a; se++) {
            Xy U = (Xy) uV.hN();
            Mx xP = (Mx) uV.hN();
            n.u(U, xP);
        }
        v<Xy, Mx> qv = (v<Xy, Mx>) uV.hN();
        for (v.P<Xy, Mx> PN : qv.S()) {
            n.u(PN.k(), PN.uQ());
        }
    }
    static class L<Xy, Mx> extends KC<Xy> {
        private final y<Xy, Mx> n;
        public L(y<Xy, Mx> n) {
            this.n = n;
        }
        @Eq
        public int a() {
            return n.a();
        }
        @Eq
        public boolean F7(fl q) {
            return n.G(q);
        }
        @Eq
        public boolean WK(fl q) {
            return n.WK(q) != null;  
        }
        @Eq
        public F<Xy> UG() {
            return new Z<Xy, Mx>(n);
        }
        @Eq
        public void nK() {
            n.nK();
        }
    }
    static class R<Xy, Mx> extends KC<Mx> {
        private final y<Xy, Mx> n;
        public R(y<Xy, Mx> n) {
            this.n = n;
        }
        @Eq
        public int a() {
            return n.a();
        }
        @Eq
        public F<Mx> UG() {
            return new j<Xy, Mx>(n);
        }
        @Eq
        public void nK() {
            n.nK();
        }
    }
    static class RC<Xy, Mx> extends KC<v.P<Xy, Mx>> {
        private final y<Xy, Mx> n;
        public RC(y<Xy, Mx> n) {
            this.n = n;
        }
        @Eq
        public F<v.P<Xy, Mx>> UG() {
            return new m8<Xy, Mx>(n);
        }
        @Eq
        public boolean F7(fl q) {
            if (!(q instanceof v.P))
                return false;
            v.P<Xy, Mx> Q = (v.P<Xy, Mx>) q;
            Xy U = Q.k();
            Mx xP = Q.uQ();
            Mx A = n.mr(U);
            if (xP == null) {
                return A == null && n.G(U);
            }
            return xP.equals(A);
        }
        @Eq
        public boolean WK(fl q) {
            if (!(q instanceof v.P))
                return false;
            v.P<Xy, Mx> Q = (v.P<Xy, Mx>) q;
            return n.WK(Q.k()) != null;  
        }
        @Eq
        public int a() {
            return n.a();
        }
        @Eq
        public void nK() {
            n.nK();
        }
    }
    static abstract class ZT<Xy, Mx, K4> implements F<K4> {
        boolean tZ = true;
        private final y<Xy, Mx> n;
        F E;
        v.P<Xy, Mx> US, M;
        public ZT(y<Xy, Mx> n) {
            this.n = n;
            if (n.IY()) return;
            this.E = n.b.s().S().UG();
            QU();
        }
        private void QU() {
            if (!E.W() && tZ) {
                tZ = false;
                E = n.b.J.Cs().S().UG();
            }
            if (!E.W()) {
                M = null;
                return;
            }
            while (E.W()) {
                v.P PN = (v.P) E.M();
                Mx xP;
                if (tZ)
                    xP = (Mx) PN.uQ();
                else {
                    xP = (Mx) p(n, (T) PN.uQ());
                    if (xP == N) continue;
                }
                M = new e<Xy, Mx>(n, (Xy) PN.k(), xP);
                return;
            }
            M = null;
        }
        public boolean W() {
            return M != null;
        }
        public v.P<Xy, Mx> C() {
            if (M == null)
                throw new Ib();
            US = M;
            QU();
            return US;
        }
        public void WK() {
            if (US == null) {
                throw new h();
            }
            n.WK(US.k());
            US = null;
        }
    }
    static class Z<Xy, Mx> extends ZT<Xy, Mx, Xy> {
        public Z(y<Xy, Mx> VV) {
            super(VV);
        }
        public Xy M() {
            return C().k();
        }
    }
    static class j<Xy, Mx> extends ZT<Xy, Mx, Mx> {
        public j(y<Xy, Mx> VV) {
            super(VV);
        }
        public Mx M() {
            return C().uQ();
        }
    }
    static class m8<Xy, Mx> extends ZT<Xy, Mx, v.P<Xy, Mx>> {
        public m8(y<Xy, Mx> VV) {
            super(VV);
        }
        public v.P<Xy, Mx> M() {
            return C();
        }
    }
    static class e<Xy, Mx> implements v.P<Xy, Mx> {
        final Xy U;
        Mx xP;
        private final y<Xy, Mx> n;
        public e(y<Xy, Mx> n, Xy U, Mx xP) {
            this.n = n;
            this.U = U;
            this.xP = xP;
        }
        public Xy k() {
            return n.b.zb(U);
        }
        public Mx uQ() {
            return xP;
        }
        public Mx ae(Mx xP) {
            this.xP = xP;
            return n.u(U, xP);
        }
        private static boolean Ie(fl m, fl x_) {
            return m == null ? x_ == null : m.equals(x_);
        }
        public boolean equals(fl q) {
            if (!(q instanceof v.P)) {
                return false;
            }
            v.P<?, ?> Q = (v.P<?, ?>) q;
            return Ie(k(), Q.k()) && Ie(xP, Q.uQ());
        }
        public int hashCode() {
            return (U == fG ? 0 : U.hashCode()) ^
                    (xP == null ? 0 : xP.hashCode());
        }
        @Eq
        public String toString() {
            return n.b.zb(U) + "=" + xP;
        }
    }
}