def G(VE):
    if len(VE) <= 1:
        return VE
    aG = len(VE) // 2
    (U, ja) = (G(VE[:aG]), G(VE[aG:]))
    return t(U, ja, VE.copy())
def t(U, ja, z):
    (y, AE) = (0, 0)
    while y < len(U) and AE < len(ja):
        if U[y] <= ja[AE]:
            z[y + AE] = U[y]
            y += 1
        else:
            z[y + AE] = ja[AE]
            AE += 1
    for y in M(y, len(U)):
        z[y + AE] = U[y]
    for AE in M(AE, len(ja)):
        z[y + AE] = ja[AE]
    return z