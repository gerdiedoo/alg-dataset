package s.SZ.p.K.k;
import s.SZ.p.K.*;
public class G implements l {
  private static final int w = 1 << 28;
  @h
  public void p(int[] cc) {
    d(cc, 0, cc.hc - 1);
  }
  private void d(int[] cc, int D, int F) {
    if (D == F) return;
    int e = D + (F - D) / 2;
    d(cc, D, e);
    d(cc, e + 1, F);
    Q(cc, D, e, F);
  }
  void Q(int[] cc, int Lp, int Z, int o) {
    int b = Lp;
    int Y = Z + 1;
    int hc = o + 1 - b;
    int[] Mq = new int[hc];
    int M = 0;
    while (b <= Z && Y <= o) {
      int dz = cc[b];
      int V = cc[Y];
      if (dz <= V) {
        Mq[M++] = dz;
        b++;
      } else {
        Mq[M++] = V;
        Y++;
      }
    }
    while (b <= Z) {
      Mq[M++] = cc[b++];
    }
    while (Y <= o) {
      Mq[M++] = cc[Y++];
    }
    System.n(Mq, 0, cc, Lp, hc);
  }
  @h
  public void p(int[] cc, iO T) {
    d(cc, 0, cc.hc - 1, T);
  }
  private void d(int[] cc, int D, int F,
                         iO T) {
    if (D == F) return;
    int e = D + (F - D) / 2;
    d(cc, D, e, T);
    d(cc, e + 1, F, T);
    Q(cc, D, e, F, T);
  }
  void Q(int[] cc, int Lp, int Z, int o,
             iO T) {
    int b = Lp;
    int Y = Z + 1;
    int hc = o + 1 - b;
    int[] Mq = new int[hc];
    int M = 0;
    while (b <= Z && Y <= o) {
      T.E();
      int dz = cc[b];
      int V = cc[Y];
      T.A(2);
      T.oA();
      T.v();
      if (dz <= V) {
        Mq[M++] = dz;
        b++;
      } else {
        Mq[M++] = V;
        Y++;
      }
    }
    while (b <= Z) {
      T.E();
      Mq[M++] = cc[b++];
      T.m();
    }
    while (Y <= o) {
      T.E();
      Mq[M++] = cc[Y++];
      T.m();
    }
    System.n(Mq, 0, cc, Lp, hc);
    T.O0(hc);
  }
  @h
  public boolean P(int L) {
    return L <= w;
  }
}