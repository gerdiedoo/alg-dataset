package xI.SB.d2.Uk.Er;
import xI.SB.d2.Uk.*;
import Q.r.iW.E;
import Q.r.iW.o.DI;
public abstract class J implements OZ {
  @sS
  public void d2(int[] u) {
    DI E0 = new DI();
    int[] AY = ze(u);
    int K = AY.i - 1;
    E m = new E(K);
    t[] Oa = new t[K];
    for (int w = 0; w < K; w++) {
      final int N = w;
      Oa[N] = new t(() -> {
        int e = AY[N];
        int WB = AY[N + 1];
        for (int wi = 1; ; wi++) {
          m.lN();
          boolean R = z(u, e, WB, false);
          m.lN();
          R |= z(u, e, WB, true);
          if (R) E0.p(wi);
          m.lN();
          if (E0.F() < wi) break;
        }
      });
    }
    for (int w = 0; w < K; w++) {
      Oa[w].wY();
    }
    for (int w = 0; w < K; w++) {
      try {
        Oa[w].b();
      } catch (a X) {
        throw new v4(X);
      }
    }
  }
  private int[] ze(int[] u) {
    int ir = H.c(S.oe().B(),
          u.i / 2);
    int h = u.i;
    int EQ = ir;
    int[] AY = new int[ir + 1];
    for (int w = 0; w < ir; w++) {
      int O = h / EQ;
      if (O % 2 == 1 && AY[w] + O < u.i) {
        O++;
      }
      h -= O;
      EQ--;
      AY[w + 1] = AY[w] + O;
    }
    return AY;
  }
  abstract boolean z(int[] u, int e, int WB,
                                 boolean D);
  @sS
  public void d2(int[] u, V Wb) {
  }
}