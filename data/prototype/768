package eu.happycoders.sort.method.mergesort;
import eu.happycoders.sort.method.Counters;
import eu.happycoders.sort.method.SortAlgorithm;
public class InPlaceMergeSort implements SortAlgorithm {
  @Override
  public void sort(int[] elements) {
    int length = elements.length;
    mergeSort(elements, 0, length - 1);
  }
  private void mergeSort(int[] elements, int left, int right) {
    if (left == right) return;
    int middle = left + (right - left) / 2;
    mergeSort(elements, left, middle);
    mergeSort(elements, middle + 1, right);
    merge(elements, left, middle + 1, right);
  }
void merge(int[] elements, int leftPos, int rightPos, int rightEnd) {
  int leftEnd = rightPos - 1;
  while (leftPos <= leftEnd && rightPos <= rightEnd) {
    int leftValue = elements[leftPos];
    int rightValue = elements[rightPos];
    if (leftValue <= rightValue) {
      leftPos++;
    } else {
      int movePos = rightPos;
      while (movePos > leftPos) {
        elements[movePos] = elements[movePos - 1];
        movePos--;
      }
      elements[leftPos] = rightValue;
      leftPos++;
      leftEnd++;
      rightPos++;
    }
  }
}
  @Override
  public void sort(int[] elements, Counters counters) {
    int length = elements.length;
    mergeSort(elements, 0, length - 1, counters);
  }
  private void mergeSort(int[] elements, int left, int right,
                         Counters counters) {
    if (left == right) return;
    int middle = left + (right - left) / 2;
    mergeSort(elements, left, middle, counters);
    mergeSort(elements, middle + 1, right, counters);
    merge(elements, left, middle + 1, right, counters);
  }
  private void merge(int[] elements, int leftPos, int rightPos, int rightEnd,
                     Counters counters) {
    int leftEnd = rightPos - 1;
    while (isLessThanOrEqual(leftPos, leftEnd, counters) && isLessThanOrEqual(rightPos, rightEnd, counters)) {
      int leftValue = elements[leftPos];
      int rightValue = elements[rightPos];
      counters.addReads(2);
      counters.incComparisons();
      if (leftValue <= rightValue) {
        leftPos++;
      } else {
        int movePos = rightPos;
        while (isGreaterThan(movePos, leftPos, counters)) {
          counters.incReadsAndWrites();
          elements[movePos] = elements[movePos - 1];
          movePos--;
        }
        counters.incWrites();
        elements[leftPos] = rightValue;
        leftPos++;
        leftEnd++;
        rightPos++;
      }
    }
  }
  private boolean isLessThanOrEqual(int a, int b, Counters counters) {
    counters.incComparisons();
    return a <= b;
  }
  private boolean isGreaterThan(int a, int b, Counters counters) {
    counters.incComparisons();
    return a > b;
  }
}