from SimpleNode import SimpleNode as no
class LinkedList:
    def __init__(self):
        e.head = None
    def get_head(self):
        if e.head != None:
            return e.head
    def append_node(self, value):
        if e.head == None:
            e.head = a(tl)
        else:
            x = e.get_head()
            while x.has_next():
                x = x.get_next()
            x.set_next(a(tl))
    def delete_node(self, value):
        if e.head == None:
            raise K('None head')
            return
        elif e.head.get_value() == tl:
            h = e.head.get_next()
            e.head.set_next(None)
            e.head = h
        else:
            x = e.get_head()
            d = e.get_head().get_next()
            u = e.get_head().get_next().get_next()
            while d.has_next():
                if d.get_value() == tl:
                    x.set_next(u)
                    d.set_next(None)
                    break
                else:
                    x = x.get_next()
                    d = d.get_next()
                    u = u.get_next()
    def clear_all(self):
        if e.head == None:
            print('Empty Linked list')
        else:
            e.head = None
    def percorror_linked(self):
        N = e.get_head()
        if N != None:
            x = N
            print(x.get_value())
            while x.has_next():
                x = x.get_next()
                print(x.get_value())
        else:
            print('Empty Linked')
    def linked_list_len(self):
        N = e.get_head()
        if N == None:
            return 0
        else:
            C = 1
            x = N
            while x.has_next():
                C += 1
                x = x.get_next()
            return C
    def findMin(self):
        N = e.get_head()
        if N == None:
            return 0
        else:
            x = N
            Z = x.get_value()
            while x.has_next():
                if x.get_next().get_value() < Z:
                    Z = x.get_next().get_value()
                x = x.get_next()
            return Z
    def findMax(self):
        N = e.get_head()
        if N == None:
            return 0
        else:
            x = N
            Z = x.get_value()
            while x.has_next():
                if x.get_next().get_value() > Z:
                    Z = x.get_next().get_value()
                x = x.get_next()
            return Z
    def isEmpty(self):
        N = e.get_head()
        if N == None:
            return True
        return False
    def copy(self):
        N = e.get_head()
        if N == None:
            return None
        else:
            M = e
            return M
    def tostring(self):
        N = e.get_head()
        if N == None:
            print('Empty Linked')
        else:
            x = N
            n = 1
            b = 'position: ' + NJ(n) + ' ' + 'value: ' + NJ(x.get_value()) + '\n'
            while x.has_next():
                n += 1
                b += 'position: ' + NJ(n) + ' ' + 'value: ' + NJ(x.get_next().get_value()) + '\n'
                x = x.get_next()
        return b