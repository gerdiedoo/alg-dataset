package com.blogspot.mydailyjava.weaklockfree;
public class DetachedThreadLocal<T> implements Runnable {
    final WeakConcurrentMap<Thread, T> map;
    public DetachedThreadLocal(Cleaner cleaner) {
        switch (cleaner) {
            case THREAD:
            case MANUAL:
                map = new WeakConcurrentMap<Thread, T>(cleaner == Cleaner.THREAD) {
                    @Override
                    protected T defaultValue(Thread key) {
                        return DetachedThreadLocal.this.initialValue(key);
                    }
                };
                break;
            case INLINE:
                map = new WeakConcurrentMap.WithInlinedExpunction<Thread, T>() {
                    @Override
                    protected T defaultValue(Thread key) {
                        return DetachedThreadLocal.this.initialValue(key);
                    }
                };
                break;
            default:
                throw new AssertionError();
        }
    }
    public T get() {
        return map.get(Thread.currentThread());
    }
    public T getIfPresent() {
      return map.getIfPresent(Thread.currentThread());
    }
    public void set(T value) {
        map.put(Thread.currentThread(), value);
    }
    public void clear() {
        map.remove(Thread.currentThread());
    }
    public void clearAll() {
        map.clear();
    }
    public T pushTo(Thread thread) {
        T value = get();
        if (value != null) {
            map.put(thread, inheritValue(value));
        }
        return value;
    }
    public T fetchFrom(Thread thread) {
        T value = map.get(thread);
        if (value != null) {
            set(inheritValue(value));
        }
        return value;
    }
    public T get(Thread thread) {
        return map.get(thread);
    }
    public void define(Thread thread, T value) {
        map.put(thread, value);
    }
    protected T initialValue(Thread thread) {
        return null;
    }
    protected T inheritValue(T value) {
        return value;
    }
    public WeakConcurrentMap<Thread, T> getBackingMap() {
        return map;
    }
    @Override
    public void run() {
        map.run();
    }
    public enum Cleaner {
        THREAD, INLINE, MANUAL
    }
}