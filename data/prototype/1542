package org.epalrov.collections;
import java.util.List;
import java.util.Collection;
import java.util.Iterator;
import java.util.ListIterator;
public class LinkedList<E> implements List<E>
{
	private ListNode<E> head;
	private int size;
	public LinkedList() {
		head = new ListNode<E>(null, null, null);
		head.next = head;
		head.prev = head;
		size = 0;
	}
	public int size() {
		return size;
	}
	public boolean isEmpty() {
		return size == 0 ? true : false;
	}
	public boolean add(E e) {
		ListNode<E> n = head;
		ListNode<E> node = new ListNode<E>(e, n, n.prev);
		n.prev.next = node;
		n.prev = node;
		size++;
		return true;
	}
	public void add(int index, E e) {
		ListNode<E> n = head;
		if (index == size) {
			n = head;
		} else if (index >= 0 && index < size/2) {
			for (int i = 0; i <= index; i++)
				n = n.next;
		} else if (index < size && index >= size/2) {
			for (int i = size; i > index; i--)
				n = n.prev;
		} else {
			throw new IndexOutOfBoundsException(
				"Index: " + index + ", Size: " + size);
		}
		ListNode<E> node = new ListNode<E>(e, n, n.prev);
		n.prev.next = node;
		n.prev = node;
		size++;
	}
	public E get(int index) {
		ListNode<E> n = head;
		if (index >= 0 && index < size/2) {
			for (int i = 0; i <= index; i++)
				n = n.next;
		} else if (index < size && index >= size/2) {
			for (int i = size; i > index; i--)
				n = n.prev;
		} else {
			throw new IndexOutOfBoundsException(
				"Index: " + index + ", Size: " + size);
		}
		return n.elem;
	}
	public E set(int index, E e) {
		ListNode<E> n = head;
		if (index >= 0 && index < size/2) {
			for (int i = 0; i <= index; i++)
				n = n.next;
		} else if (index < size && index >= size/2) {
			for (int i = size; i > index; i--)
				n = n.prev;
		} else {
			throw new IndexOutOfBoundsException(
				"Index: " + index + ", Size: " + size);
		}
		E oldElem = n.elem;
		n.elem = e;
		return oldElem;
	}
	public E remove(int index) {
		ListNode<E> n = head;
		if (index >= 0 && index < size/2) {
			for (int i = 0; i <= index; i++)
				n = n.next;
		} else if (index < size && index >= size/2) {
			for (int i = size; i > index; i--)
				n = n.prev;
		} else {
			throw new IndexOutOfBoundsException(
				"Index: " + index + ", Size: " + size);
		}
		n.next.prev = n.prev;
		n.prev.next = n.next;
		size--;
		return n.elem;
	}
	public boolean remove(Object o) {
		ListNode<E> n = head;
		for (int i = 0; i < size; i++) {
			n = n.next;
			if ((o != null && o.equals(n.elem)) ||
					(o == null && n.elem == null)) {
				n.next.prev = n.prev;
				n.prev.next = n.next;
				size--;
				return true;
			}
		}
		return false;
	}
	public void clear() {
		ListNode<E> n = head;
		while (size > 0) {
			n.next.prev = n.prev;
			n.prev.next = n.next;
			size--;
		}
	}
	public int indexOf(Object o) {
		ListNode<E> n = head;
		for (int i = 0; i < size; i++) {
			n = n.next;
			if ((o != null && o.equals(n.elem)) ||
					(o == null && n.elem == null))
				return i;
		}
		return -1;
	}
	public int lastIndexOf(Object o) {
		ListNode<E> n = head;
		for (int i = 0; i < size; i++) {
			n = n.prev;
			if ((o != null && o.equals(n.elem)) ||
					(o == null && n.elem == null))
				return size - 1 - i;
		}
		return -1;
	}
	public boolean contains(Object o) {
		return indexOf(o) != -1 ? true : false;
	}
	public Iterator<E> iterator() {
		return new LinkedListIterator(0);
	}
	public ListIterator<E> listIterator() {
		return new LinkedListIterator(0);
	}
	public ListIterator<E> listIterator(int index) {
		return new LinkedListIterator(index);
	}
	private class LinkedListIterator implements ListIterator<E> {
		private ListNode<E> currNode;
		private ListNode<E> nextNode;
		private int nextIndex;
		LinkedListIterator(int index) {
			currNode = head;
			nextNode = head;
			if (index >= 0 && index < size/2) {
				for (int i = 0; i <= index; i++)
					nextNode = nextNode.next;
			} else if (index <= size && index >= size/2) {
				for (int i = size; i >= index; i--)
					nextNode = nextNode.prev;
			} else {
				throw new IndexOutOfBoundsException(
					"Index: " + index + ", Size: " + size);
			}
			nextIndex = index;
		}
		public boolean hasNext() {
			return nextIndex == size ? false : true;
		}
		public E next() {
			currNode = nextNode;
			nextNode = nextNode.next;
			nextIndex++;
			return currNode.elem;
		}
		public int nextIndex() {
			return nextIndex;
		}
		public boolean hasPrevious() {
			return nextIndex == 0 ? false : true;
		}
		public E previous() {
			currNode = nextNode;
			nextNode = nextNode.prev;
			nextIndex--;
			return currNode.elem;
		}
		public int previousIndex() {
			return nextIndex;
		}
		public void set(E e) {
			currNode.elem = e;
		}
		public void add(E e) {
			ListNode<E> n = nextNode;
			ListNode<E> node = new ListNode<E>(e, n, n.prev);
			n.prev.next = node;
			n.prev = node;
			nextIndex++;
			size++;
		}
		public void remove() {
			ListNode<E> n = nextNode;
			n.prev.prev.next = n;
			n.prev = n.prev.prev;
			nextIndex--;
			size--;
		}
	}
	public Object[] toArray() {
		Object[] o = new Object[size];
		ListNode<E> n = head;
		for (int i = 0; i < size; i++) {
			n = n.next;
			o[i] = n.elem;
		}
		return o;
	} 
	public <T> T[] toArray(T[] a) {
		if (a.length < size)
			a = (T[])java.lang.reflect.Array.newInstance(
				a.getClass().getComponentType(), size);
		ListNode<E> n = head;
		for (int i = 0; i < size; i++) {
			n = n.next;
			a[i] = (T)n.elem;
		}
		return a;
	}
	public boolean containsAll(Collection<? extends Object> c) {
		Iterator<? extends Object> i = c.iterator();
		while (i.hasNext())
			if (!contains(i.next()))
				return false;
		return true;
	}
	public boolean addAll(Collection<? extends E> c) {
		ListNode<E> n = head;
		Iterator<? extends E> i = c.iterator();
		while (i.hasNext()) {
			ListNode<E> node =
				new ListNode<E>((E)i.next(), n, n.prev);
			n.prev.next = node;
			n.prev = node;
			size++;
		}
		return true;
	}
	public boolean addAll(int index, Collection<? extends E> c) {
		ListNode<E> n = head;
		if (index == size) {
			n = head;
		} else if (index >= 0 && index < size/2) {
			for (int i = 0; i <= index; i++)
				n = n.next;
		} else if (index < size && index >= size/2) {
			for (int i = size; i > index; i--)
				n = n.prev;
		} else {
			throw new IndexOutOfBoundsException(
				"Index: " + index + ", Size: " + size);
		}
		Iterator<? extends E> i = c.iterator();
		while (i.hasNext()) {
			ListNode<E> node =
				new ListNode<E>((E)i.next(), n, n.prev);
			n.prev.next = node;
			n.prev = node;
			size++;
		}
		return true;
	}	
	public boolean removeAll(Collection<?> c) {
		ListNode<E> n = head;
		for (int i = 0, count = size; i < count; i++) {
			n = n.next;
			if (c.contains(n.elem)) {
				n.next.prev = n.prev;
				n.prev.next = n.next;
				size--;
			}
		}
		return true;
	}
	public boolean retainAll(Collection<?> c) {
		ListNode<E> n = head;
		for (int i = 0, count = size; i < count; i++) {
			n = n.next;
			if (!c.contains(n.elem)) {
				n.next.prev = n.prev;
				n.prev.next = n.next;
				size--;
			}
		}
		return true;
	}
	public List<E> subList(int fromIndex, int toIndex) {
		throw new UnsupportedOperationException();
	}
	public boolean equals(Object o) {
		if (o == this)
			return true;
		if (!(o instanceof List))
			return false;
		Iterator<E> i = iterator();
		Iterator<?> j = ((List<?>) o).iterator();
		while (i.hasNext() && j.hasNext()) {
			E elem = i.next();
			Object obj = j.next();
			if (!(obj != null && obj.equals(elem)) ||
					(obj == null && elem == null))
				return false;
		}
		return !(i.hasNext() || j.hasNext());
	}
	public int hashCode() {
		int hash = 1;
		Iterator<E> i = iterator();
		while (i.hasNext()) {
			E elem = i.next();
			hash = 31*hash + (elem == null ? 0 : elem.hashCode());
		}
		return hash;
	}
	private static class ListNode<E> {
		E elem;
		ListNode<E> next;
		ListNode<E> prev;
		ListNode(E e, ListNode<E> n, ListNode<E> p) {
			elem = e;
			next = n;
			prev = p;
		}
	}
}