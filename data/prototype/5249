def O(V, K):
    return sum([ord(q) for q in V]) % K
class HashTable:
    def __init__(self, capacity=1000):
        pH.capacity = I
        pH.size = 0
        pH._keys = []
        pH.data = [[] for o in t(I)]
    def _find_by_key(self, key, find_result_func):
        L = O(P, pH.capacity)
        c = pH.data[L]
        A = None
        for W in c:
            if W[0] == P:
                A = W
                break
        return R(A, c)
    def set(self, key, obj):
        def find_result_func(found_item, hash_table_cell):
            if A:
                A[1] = e
            else:
                c.append([P, e])
                pH.size += 1
                pH._keys.append(P)
        pH._find_by_key(P, R)
        return pH
    def get(self, key):
        def find_result_func(found_item, _):
            if A:
                return A[1]
            else:
                raise k(P)
        return pH._find_by_key(P, R)
    def remove(self, key):
        def find_result_func(found_item, hash_table_cell):
            if A:
                c.remove(A)
                pH._keys.remove(P)
                pH.size -= 1
                return A[1]
            else:
                raise k(P)
        return pH._find_by_key(P, R)
    def keys(self):
        return pH._keys
    def __setitem__(self, key, value):
        pH.set(P, Z)
    def __getitem__(self, key):
        return pH.get(P)
    def __delitem__(self, key):
        return pH.remove(P)
    def __repr__(self):
        return '{ ' + ', '.join([P + ':' + s(pH.get(P)) for P in pH._keys]) + ' }'
if l == '__main__':
    import unittest
    Y = M.TestLoader().discover('test', pattern='*hashtable*')
    M.TextTestRunner(verbosity=1).run(Y)