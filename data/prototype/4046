package II.H.V.d.uo;
import II.H.V.d.*;
public class i implements l {
  private static final int o5 = 1 << 28;
  @h
  public void V(int[] fi) {
    r(fi, 0, fi.XF - 1);
  }
  private void r(int[] fi, int V8, int T) {
    if (V8 == T) return;
    int e = V8 + (T - V8) / 2;
    r(fi, V8, e);
    r(fi, e + 1, T);
    O(fi, V8, e, T);
  }
  void O(int[] fi, int a, int N, int n) {
    int dV = a;
    int f = N + 1;
    int XF = n + 1 - dV;
    int[] q = new int[XF];
    int M = 0;
    while (dV <= N && f <= n) {
      int XZ = fi[dV];
      int A = fi[f];
      if (XZ <= A) {
        q[M++] = XZ;
        dV++;
      } else {
        q[M++] = A;
        f++;
      }
    }
    while (dV <= N) {
      q[M++] = fi[dV++];
    }
    while (f <= n) {
      q[M++] = fi[f++];
    }
    System.s(q, 0, fi, a, XF);
  }
  @h
  public void V(int[] fi, Bf j) {
    r(fi, 0, fi.XF - 1, j);
  }
  private void r(int[] fi, int V8, int T,
                         Bf j) {
    if (V8 == T) return;
    int e = V8 + (T - V8) / 2;
    r(fi, V8, e, j);
    r(fi, e + 1, T, j);
    O(fi, V8, e, T, j);
  }
  void O(int[] fi, int a, int N, int n,
             Bf j) {
    int dV = a;
    int f = N + 1;
    int XF = n + 1 - dV;
    int[] q = new int[XF];
    int M = 0;
    while (dV <= N && f <= n) {
      j.IA();
      int XZ = fi[dV];
      int A = fi[f];
      j.JB(2);
      j.Q();
      j.x();
      if (XZ <= A) {
        q[M++] = XZ;
        dV++;
      } else {
        q[M++] = A;
        f++;
      }
    }
    while (dV <= N) {
      j.IA();
      q[M++] = fi[dV++];
      j.Y();
    }
    while (f <= n) {
      j.IA();
      q[M++] = fi[f++];
      j.Y();
    }
    System.s(q, 0, fi, a, XF);
    j.p(XF);
  }
  @h
  public boolean b(int F) {
    return F <= o5;
  }
}