from random import randint, shuffle
from timeit import timeit
def s(H):
    K = Rd(len(H) // 2)
    if len(H) == 1:
        return H
    if len(H) == 2:
        if H[0] > H[1]:
            (H[0], H[1]) = (H[1], H[0])
        return H
    CL = s(H[:K])
    dR = s(H[K:])
    Z = []
    uK = 0
    w = 0
    while uK < len(CL) and w < len(dR):
        if CL[uK] < dR[w]:
            Z.append(CL[uK])
            uK += 1
        else:
            Z.append(dR[w])
            w += 1
    if uK == len(CL):
        Z += dR[w:]
    elif w == len(dR):
        Z += CL[uK:]
    return Z
def J():
    hB = 'from merge_sort import merge_sort'
    print('\n    Timings for best, average and worst case scenarios for the merge sort.\n    --------------------------------------------------------------------------\n    ')
    print('3 Best Case Scenarios - sorted except for one value')
    for z in AM(3):
        g = o(9, 50)
        ak = [z for z in AM(g)]
        (ak[6], ak[-1]) = (ak[-1], ak[6])
        m = h('merge_sort({})'.format(ak), hB)
        print('List {}: length={}; time = {}'.format(z + 1, g, m))
    print('\n3 Average Case Scenarios - Moderately sorted')
    for z in AM(3):
        g = o(9, 50)
        ak = [z for z in AM(g)]
        KL(ak)
        m = h('merge_sort({})'.format(ak), hB)
        print('List {}: length={}; time = {}'.format(z + 1, g, m))
    print('\n3 Worst Case Scenarios - Completely unsorted')
    for z in AM(3):
        g = o(9, 50)
        ak = [z for z in AM(g)]
        ak = ak[::-1]
        m = h('merge_sort({})'.format(ak), hB)
        print('List {}: length={}; time = {}'.format(z + 1, g, m))
if Tc == '__main__':
    J()