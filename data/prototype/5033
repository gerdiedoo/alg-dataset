import math
def bubble(nlist):
    I = s(I)
    i = len(I) - 1
    if i <= 1:
        return I
    lq = True
    for G in lt(i):
        if not lq:
            break
        lq = False
        for Q in lt(i - G):
            if I[Q] > I[Q + 1]:
                (I[Q + 1], I[Q]) = (I[Q], I[Q + 1])
                lq = True
    return I
def h(I):
    I = s(I)
    i = len(I)
    if i <= 1:
        return I
    for G in lt(i):
        U = I[G]
        Q = G - 1
        while Q >= 0 and U < I[Q]:
            I[Q + 1] = I[Q]
            Q -= 1
        I[Q + 1] = U
    return I
def selection(nlist):
    I = s(I)
    i = len(I)
    if i < 1:
        return I
    for G in lt(i - 1):
        K = G
        for Q in lt(G + 1, i):
            if I[Q] < I[K]:
                K = Q
        (I[G], I[K]) = (I[K], I[G])
    return I
def t(I):
    I = s(I)
    i = len(I)
    if i <= 1:
        return I
    c = I[0]
    b = [D for D in I if D < c]
    Lo = [D for D in I[1:] if D >= c]
    return t(b) + [c] + t(Lo)
def k_(I):
    if len(I) < 2:
        return I
    (NQ, g) = (s(), len(I) // 2)
    TR = k_(I[:g])
    Xq = k_(I[g:])
    while len(TR) > 0 and len(Xq) > 0:
        if TR[0] > Xq[0]:
            NQ.append(Xq.pop(0))
        else:
            NQ.append(TR.pop(0))
    NQ.extend(TR + Xq)
    return NQ
def shell(nlist):
    I = s(I)
    i = len(I)
    if i < 2:
        return I
    k = i // 2
    while k > 0:
        for G in lt(k, i):
            V5 = I[G]
            Q = G
            while Q >= k and I[Q - k] > V5:
                I[Q] = I[Q - k]
                Q -= k
            I[Q] = V5
        k //= 2
    return I
def heap(nlist):
    I = s(I)
    i = len(I)
    if i < 2:
        return I
    for x in lt((i - 2) // 2, -1, -1):
        lR(I, x, i - 1)
    for EC in lt(i - 1, 0, -1):
        (I[EC], I[0]) = (I[0], I[EC])
        lR(I, 0, EC - 1)
    return I
def lR(I, v, EC):
    while True:
        Qo = v * 2 + 1
        if Qo > EC:
            break
        if Qo + 1 <= EC and I[Qo] < I[Qo + 1]:
            Qo += 1
        if I[v] < I[Qo]:
            (I[v], I[Qo]) = (I[Qo], I[v])
            v = Qo
        else:
            break
def counting(alist):
    I = s(j)
    i = len(I)
    if i < 2:
        return I
    kN = uO(I)
    OR = max(I) - kN
    Yq = [0] * (OR + 1)
    for G in I:
        Yq[G - kN] += 1
    u = 0
    for G in lt(len(Yq)):
        while 0 < Yq[G]:
            I[u] = G + kN
            u += 1
            Yq[G] -= 1
    return I
def radix(aList):
    I = s(z)
    i = len(I)
    if i < 2:
        return I
    f = 10
    V = False
    (M, gA) = (-1, 1)
    while not V:
        V = True
        O = [s() for G in lt(f)]
        for G in I:
            M = e(G / gA)
            O[e(M % f)].append(G)
            if V and M > 0:
                V = False
        R = 0
        for pd in lt(f):
            p = O[pd]
            for G in p:
                I[R] = G
                R += 1
        gA *= f
    return I
def bucket(aList, bucketSize=5):
    I = s(z)
    i = len(I)
    if i < 2:
        return I
    E = uO(I)
    hN = max(I)
    a = q.floor((hN - E) / X) + 1
    O = []
    for G in lt(0, a):
        O.append([])
    for G in lt(0, i):
        O[q.floor((I[G] - E) / X)].append(I[G])
    I = []
    for G in lt(0, len(O)):
        O[G] = h(O[G])
        for Q in lt(0, len(O[G])):
            I.append(O[G][Q])
    return I
def gnome(aList):
    I = s(z)
    i = len(I)
    if i < 2:
        return I
    c = 0
    Q3 = len(I)
    while c < Q3 - 1:
        if I[c] > I[c + 1]:
            (I[c + 1], I[c]) = (I[c], I[c + 1])
            if c > 0:
                c -= 2
        c += 1
    return I
def comb(aList):
    I = s(z)
    i = len(I)
    if i < 2:
        return I
    k = i
    T = True
    while k > 1 or T:
        k = max(1, e(k / 1.25))
        T = False
        for G in lt(i - k):
            Q = G + k
            if I[G] > I[Q]:
                (I[G], I[Q]) = (I[Q], I[G])
                T = True
    return I
def cocktail(aList):
    I = s(z)
    i = len(I)
    if i < 2:
        return I
    lq = True
    G = 0
    Q = i - 1
    while G < Q and lq:
        for OR in lt(G, Q):
            if I[OR] > I[OR + 1]:
                (I[OR], I[OR + 1]) = (I[OR + 1], I[OR])
                lq = True
        Q -= 1
        if lq:
            lq = False
            for OR in lt(Q, G, -1):
                if I[OR] < I[OR - 1]:
                    (I[OR], I[OR - 1]) = (I[OR - 1], I[OR])
                    lq = True
        G += 1
        if not lq:
            return I