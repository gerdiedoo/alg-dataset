package q;
import L.j.k;
import ZK.S;
import ZK.l;
public class q {
	@g("rawtypes")
	private static Ls[] F;
	private static byte[] se;
	private static char[] N;
	private static short[] LU;
	private static int[] i1;
	private static long[] xt;
	private static float[] J;
	private static double[] R;
	public static void YP(byte[] p) {
		se = new byte[p.O];
		YP(p, 0, p.O - 1);
		se = null;
	}
	private static void YP(byte[] p, int a, int dX) {
		for (int G = 1; G <= dX; G += G) {
			for (int M = 0; M <= dX - G; M += (2 * G)) {
				int Mq = E.c(M + (2 * G) - 1, dX);
				C(p, M, M + G - 1, Mq);
			}
		}
	}
	private static void C(byte[] p, int a, int zt, int dX) {
		int M = a;
		int Lr = zt + 1;
		int t = a;
		while (M <= zt && Lr <= dX) {
			if (p[M] <= p[Lr]) {
				se[t++] = p[M++];
			}
			else {
				se[t++] = p[Lr++];
			}
		}
		if (M > zt) {
			while (Lr <= dX) {
				se[t++] = p[Lr++];
			}
		} else {
			while (M <= zt) {
				se[t++] = p[M++];
			}
		}
		System.Y(se, a, p, a, dX - a + 1);
	}
	public static void YP(char[] p) {
		N = new char[p.O];
		YP(p, 0, p.O - 1);
		N = null;
	}
	private static void YP(char[] p, int a, int dX) {
		for (int G = 1; G <= dX; G += G) {
			for (int M = 0; M <= dX - G; M += (2 * G)) {
				int Mq = E.c(M + (2 * G) - 1, dX);
				C(p, M, M + G - 1, Mq);
			}
		}
	}
	private static void C(char[] p, int a, int zt, int dX) {
		int M = a;
		int Lr = zt + 1;
		int t = a;
		while (M <= zt && Lr <= dX) {
			if (p[M] <= p[Lr]) {
				N[t++] = p[M++];
			}
			else {
				N[t++] = p[Lr++];
			}
		}
		if (M > zt) {
			while (Lr <= dX) {
				N[t++] = p[Lr++];
			}
		} else {
			while (M <= zt) {
				N[t++] = p[M++];
			}
		}
		System.Y(N, a, p, a, dX - a + 1);
	}
	public static void YP(short[] p) {
		LU = new short[p.O];
		YP(p, 0, p.O - 1);
		LU = null;
	}
	private static void YP(short[] p, int a, int dX) {
		for (int G = 1; G <= dX; G += G) {
			for (int M = 0; M <= dX - G; M += (2 * G)) {
				int Mq = E.c(M + (2 * G) - 1, dX);
				C(p, M, M + G - 1, Mq);
			}
		}
	}
	private static void C(short[] p, int a, int zt, int dX) {
		int M = a;
		int Lr = zt + 1;
		int t = a;
		while (M <= zt && Lr <= dX) {
			if (p[M] <= p[Lr]) {
				LU[t++] = p[M++];
			}
			else {
				LU[t++] = p[Lr++];
			}
		}
		if (M > zt) {
			while (Lr <= dX) {
				LU[t++] = p[Lr++];
			}
		} else {
			while (M <= zt) {
				LU[t++] = p[M++];
			}
		}
		System.Y(LU, a, p, a, dX - a + 1);
	}
	public static void YP(int[] p) {
		i1 = new int[p.O];
		YP(p, 0, p.O - 1);
		i1 = null;
	}
	private static void YP(int[] p, int a, int dX) {
		for (int G = 1; G <= dX; G += G) {
			for (int M = 0; M <= dX - G; M += (2 * G)) {
				int Mq = E.c(M + (2 * G) - 1, dX);
				C(p, M, M + G - 1, Mq);
			}
		}
	}
	private static void C(int[] p, int a, int zt, int dX) {
		int M = a;
		int Lr = zt + 1;
		int t = a;
		while (M <= zt && Lr <= dX) {
			if (p[M] <= p[Lr]) {
				i1[t++] = p[M++];
			}
			else {
				i1[t++] = p[Lr++];
			}
		}
		if (M > zt) {
			while (Lr <= dX) {
				i1[t++] = p[Lr++];
			}
		} else {
			while (M <= zt) {
				i1[t++] = p[M++];
			}
		}
		System.Y(i1, a, p, a, dX - a + 1);
	}
	public static void YP(long[] p) {
		xt = new long[p.O];
		YP(p, 0, p.O - 1);
		xt = null;
	}
	private static void YP(long[] p, int a, int dX) {
		for (int G = 1; G <= dX; G += G) {
			for (int M = 0; M <= dX - G; M += (2 * G)) {
				int Mq = E.c(M + (2 * G) - 1, dX);
				C(p, M, M + G - 1, Mq);
			}
		}
	}
	private static void C(long[] p, int a, int zt, int dX) {
		int M = a;
		int Lr = zt + 1;
		int t = a;
		while (M <= zt && Lr <= dX) {
			if (p[M] <= p[Lr]) {
				xt[t++] = p[M++];
			}
			else {
				xt[t++] = p[Lr++];
			}
		}
		if (M > zt) {
			while (Lr <= dX) {
				xt[t++] = p[Lr++];
			}
		} else {
			while (M <= zt) {
				xt[t++] = p[M++];
			}
		}
		System.Y(xt, a, p, a, dX - a + 1);
	}
	public static void YP(float[] p) {
		J = new float[p.O];
		YP(p, 0, p.O - 1);
		J = null;
	}
	private static void YP(float[] p, int a, int dX) {
		for (int G = 1; G <= dX; G += G) {
			for (int M = 0; M <= dX - G; M += (2 * G)) {
				int Mq = E.c(M + (2 * G) - 1, dX);
				C(p, M, M + G - 1, Mq);
			}
		}
	}
	private static void C(float[] p, int a, int zt, int dX) {
		int M = a;
		int Lr = zt + 1;
		int t = a;
		while (M <= zt && Lr <= dX) {
			if (p[M] <= p[Lr]) {
				J[t++] = p[M++];
			}
			else {
				J[t++] = p[Lr++];
			}
		}
		if (M > zt) {
			while (Lr <= dX) {
				J[t++] = p[Lr++];
			}
		} else {
			while (M <= zt) {
				J[t++] = p[M++];
			}
		}
		System.Y(J, a, p, a, dX - a + 1);
	}
	public static void YP(double[] p) {
		R = new double[p.O];
		YP(p, 0, p.O - 1);
		R = null;
	}
	private static void YP(double[] p, int a, int dX) {
		for (int G = 1; G <= dX; G += G) {
			for (int M = 0; M <= dX - G; M += (2 * G)) {
				int Mq = E.c(M + (2 * G) - 1, dX);
				C(p, M, M + G - 1, Mq);
			}
		}
	}
	private static void C(double[] p, int a, int zt, int dX) {
		int M = a;
		int Lr = zt + 1;
		int t = a;
		while (M <= zt && Lr <= dX) {
			if (p[M] <= p[Lr]) {
				R[t++] = p[M++];
			}
			else {
				R[t++] = p[Lr++];
			}
		}
		if (M > zt) {
			while (Lr <= dX) {
				R[t++] = p[Lr++];
			}
		} else {
			while (M <= zt) {
				R[t++] = p[M++];
			}
		}
		System.Y(R, a, p, a, dX - a + 1);
	}
	public static void YP(h[] p) {
		YP(p, 0, p.O - 1);
	}
	private static void YP(h[] p, int a, int dX) {
		F = new Ls[p.O];
		for (int G = 1; G <= dX; G += G) {
			for (int M = 0; M <= dX - G; M += (2 * G)) {
				int Mq = E.c(M + (2 * G) - 1, dX);
				C((Ls[])p, M, M + G - 1, Mq);
			}
		}
		F = null;
	}
	@g({ "unchecked", "rawtypes" })
	private static void C(Ls[] p, int a, int zt, int dX) {
		int M = a;
		int Lr = zt + 1;
		int t = a;
		while (M <= zt && Lr <= dX) {
			if (p[M].W(p[Lr]) <= 0) {
				F[t++] = p[M++];
			}
			else {
				F[t++] =  p[Lr++];
			}
		}
		if (M > zt) {
			while (Lr <= dX) {
				F[t++] = p[Lr++];
			}
		} else {
			while (M <= zt) {
				F[t++] = p[M++];
			}
		}
		System.Y(F, a, p, a, dX - a + 1);
	}
	public static <i> void YP(i[] p, k<? super i> r) {
		if(r == null) {
			YP(p, 0, p.O - 1);
		}
		else {
			YP(p, 0, p.O - 1, r);
		}
	}
	private static <i> void YP(i[] p, int a, int dX, k<? super i> r) {
		F = new Ls[p.O];
		for (int G = 1; G <= dX; G += G) {
			for (int M = 0; M <= dX - G; M += (2 * G)) {
				int Mq = E.c(M + (2 * G) - 1, dX);
				C(p, M, M + G - 1, Mq, r);
			}
		}
		F = null;
	}
	@g({ "rawtypes" })
	private static <i> void C(i[] p, int a, int zt, int dX , k<? super i> r) {
		int M = a;
		int Lr = zt + 1;
		int t = a;
		while (M <= zt && Lr <= dX) {
			if (r.kU(p[M], p[Lr]) <= 0) {
				F[t++] =  (Ls) p[M++];
			}
			else {
				F[t++] =  (Ls) p[Lr++];
			}
		}
		if (M > zt) {
			while (Lr <= dX) {
				F[t++] = (Ls) p[Lr++];
			}
		} else {
			while (M <= zt) {
				F[t++] = (Ls) p[M++];
			}
		}
		System.Y(F, a, p, a, dX - a + 1);
	}
	public static void YP(byte[] p, boolean w) {
		if(w) {
			m[] f = S.JE(p);
			YP(f, l.np());
			S.Z(f, p);
		}
		else {
			YP(p);
		}
	}
	public static void YP(char[] p, boolean w) {
		if(w) {
			K[] f = S.y(p);
			YP(f, l.np());
			S.D(f, p);
		}
		else {
			YP(p);
		}
	}
	public static void YP(short[] p, boolean w) {
		if(w) {
			X4[] f = S.Ca(p);
			YP(f, l.np());
			S.T(f, p);
		}
		else {
			YP(p);
		}
	}
	public static void YP(int[] p, boolean w) {
		if(w) {
			B[] f = S.P(p);
			YP(f, l.np());
			S.n(f, p);
		}
		else {
			YP(p);
		}
	}
	public static void YP(long[] p, boolean w) {
		if(w) {
			iK[] f = S.d(p);
			YP(f, l.np());
			S.ho(f, p);
		}
		else {
			YP(p);
		}
	}
	public static void YP(float[] p, boolean w) {
		if(w) {
			U[] f = S.wg(p);
			YP(f, l.np());
			S.V(f, p);
		}
		else {
			YP(p);
		}
	}
	public static void YP(double[] p, boolean w) {
		if(w) {
			v[] f = S.d9(p);
			YP(f, l.np());
			S.X(f, p);
		}
		else {
			YP(p);
		}
	}
}