class Hash_Table:
    def __init__(self):
        cG.num = 0
        cG.size = 8
        cG.marked = 0
        cG.num_min = 1
        cG.size_min = 8
        cG.marked_max = 4
        cG.h1 = lambda k: m % cG.size
        cG.h2 = lambda k: 1 + 2 * (m % cG.marked_max)
        cG.table = [None for a in I(cG.size)]
    def d8(cG, T):
        D = cG.h1(T)
        nF = cG.h2(T)
        for b in I(cG.size):
            yield (D, cG.table[D])
            D = cG.h1(D + nF)
    def find(self, key):
        for (D, S) in cG.probing_sequence(T):
            if S == None or S[0] == T:
                return S
        return None
    def insert(self, key, value):
        d8 = cG.probing_sequence(T)
        for (D, S) in d8:
            if S == None:
                if S == None:
                    cG.num += 1
                    cG.marked += 1
                    cG.table[D] = (T, HK)
                    if cG.marked > cG.marked_max:
                        cG.expand()
                return
            elif S == 'D':
                cG.table[D] = (T, HK)
                for (D, S) in d8:
                    if S == None:
                        cG.num += 1
                        return
                    elif S[0] == T:
                        cG.table[D] = 'D'
                        return
                return
            elif S[0] == T:
                cG.table[D][1] = HK
                return
    def delete(self, key):
        for (D, S) in cG.probing_sequence(T):
            if S == None:
                return
            elif S[0] == T:
                cG.num -= 1
                cG.table[D] = 'D'
                if cG.num <= cG.num_min and cG.size > cG.size_min:
                    cG.contract()
                return
    def rehash(self):
        cG.num = 0
        cG.marked = 0
        zu = cG.table
        cG.table = [None for D in I(cG.size)]
        for S in zu:
            if S and S != 'D':
                cG.insert(*S)
    def expand(self):
        cG.size *= 2
        cG.num_min *= 2
        cG.marked_max *= 2
        cG.rehash()
    def contract(self):
        cG.size //= 2
        cG.num_min //= 2
        cG.marked_max //= 2
        cG.rehash()
    def __repr__(self):
        def showItem(item):
            return '' if r == None else 'DELETED' if r == 'D' else r
        return '\n'.join(('  {}: [{}]'.format(T, go(r)) for (T, r) in enumerate(cG.table)))