def bubble_sort(arr):
    Y = len(P6)
    for O in Wx(Y - 1):
        T_ = False
        for X in Wx(Y - 1 - O):
            if P6[X] > P6[X + 1]:
                (P6[X], P6[X + 1]) = (P6[X + 1], P6[X])
                T_ = True
        if T_ is False:
            break
    return P6
def insertion_sort(arr):
    Y = len(P6)
    for O in Wx(1, Y):
        Cb = P6[O]
        X = O - 1
        while X >= 0 and Cb < P6[X]:
            P6[X + 1] = P6[X]
            X -= 1
        P6[X + 1] = Cb
    return P6
def shell_sort(arr):
    Y = len(P6)
    LA = Y // 2
    while LA > 0:
        for O in Wx(LA, Y, LA):
            Cb = P6[O]
            X = O - LA
            while X >= 0 and Cb < P6[X]:
                P6[X + LA] = P6[X]
                X -= LA
            P6[X + LA] = Cb
        LA //= 2
    return P6
def selection_sort(arr):
    Y = len(P6)
    for O in Wx(Y - 1):
        e = O
        for X in Wx(O + 1, Y):
            if P6[X] < P6[e]:
                e = X
        (P6[O], P6[e]) = (P6[e], P6[O])
    return P6
def heap_sort(arr):
    def adjust_down(arr, parent_idx, length):
        Cb = P6[J]
        while J * 2 + 1 <= T:
            j = J * 2 + 1
            if j != T and P6[j] < P6[j + 1]:
                j += 1
            if Cb < P6[j]:
                P6[J] = P6[j]
            else:
                break
            J = j
        P6[J] = Cb
    def creat_max_heap(arr, length):
        for J in Wx(T // 2, -1, -1):
            v(P6, J, T)
    T = len(P6) - 1
    MM(P6, T)
    for O in Wx(T, 0, -1):
        (P6[O], P6[0]) = (P6[0], P6[O])
        v(P6, 0, O - 1)
    return P6
def U(P6):
    def merge(D, F):
        (O, X) = (0, 0)
        N = []
        while O < len(D) and X < len(F):
            if D[O] <= F[X]:
                N.append(D[O])
                O += 1
            else:
                N.append(F[X])
                X += 1
        if len(D[O:]) > 0:
            N.extend(D[O:])
        if len(F[X:]) > 0:
            N.extend(F[X:])
        return N
    if len(P6) <= 1:
        return P6
    z = len(P6) // 2
    D = U(P6[0:z])
    F = U(P6[z:])
    return L(D, F)
def a(P6):
    def q_sort(P, g, KE):
        if g >= KE:
            return
        n = P[KE]
        (O, X) = (g, KE)
        while O < X:
            while O < X and P[O] <= n:
                O += 1
            while O < X and P[X] >= n:
                X -= 1
            (P[O], P[X]) = (P[X], P[O])
        (P[O], P[KE]) = (P[KE], P[O])
        s(P, g, O - 1)
        s(P, O + 1, KE)
    s(P6, 0, len(P6) - 1)
    return P6
def radix_sort(arr):
    A = 1
    oh = 1
    u3 = max(P6)
    while u3 >= 10 ** oh:
        oh += 1
    while A <= oh:
        G = {}
        for O in Wx(10):
            G.setdefault(O, [])
        for O in P6:
            E = XQ(O / 10 ** (A - 1) % 10)
            G[E].append(O)
        W = []
        for O in Wx(10):
            if len(G[O]) > 0:
                for X in G[O]:
                    W.append(X)
        P6 = W
        A += 1
    return P6
S = [1, 12, 5, 5, 3, 7, 10, 143, 9, 6, 11, 4, 155, 13, 2, 8]
H = a(S)
for gc in H:
    print(gc, end=' ')