package Y;
import h.d.B;
import h.d.b.i;
import s.nu;
import s.n;
public class by {
	final static int a = 1 << 13;
	public static void H(byte[] W) {
		new I.p(W, 0, W.S - 1).Uj();
	}
	private static final class I {	
		private static final class p extends i {
			private static final long G = 1L;
			final byte[] W;
			final int k;
			final int BB;
			p(byte[] W, int k, int BB) {
				this.W = W;
				this.k = k;
				this.BB = BB;
			}
			public final void N_() {
				if(k >= BB) {
					return;
				}
				int s6 = C(W, k, BB);
				if(BB - k < a) {
					a9(W, k, s6 - 1);
					a9(W, s6 + 1, BB);
				}
				else {
					p MG = new p(W, k, s6 - 1);
					p g = new p(W, s6 + 1, BB);
					MG.e();
					g.N_();
					MG.P();
				}
			}
		}
		private static void a9(byte[] W, int k, int BB) {	
			if(k >= BB) {
				return;
			}
			int s6 = C(W, k, BB);	
			a9(W, k, s6 - 1);
			a9(W, s6 + 1, BB);
		}
		private static int C(byte[] W, int MG, int g) {
			int k = MG;
			int BB = g;
			byte s6 = W[MG];	
			while(k < BB) {
				while(W[BB] > s6) --BB;
				while(W[k] <= s6 && k < BB) ++k;
				m(W, k, BB);
			}
			m(W, MG, k);
			return k;
		}
		private static void m(byte[] W, int kE, int F) {
			byte j = W[kE];
			W[kE] = W[F];
			W[F] = j;
		}
	}
	public static void H(char[] W) {
		new V.p(W, 0, W.S - 1).Uj();
	}
	private static final class V {	
		private static final class p extends i {
			private static final long G = 1L;
			final char[] W;
			final int k;
			final int BB;
			p(char[] W, int k, int BB) {
				this.W = W;
				this.k = k;
				this.BB = BB;
			}
			public final void N_() {
				if(k >= BB) {
					return;
				}
				int s6 = C(W, k, BB);
				if(BB - k < a) {
					a9(W, k, s6 - 1);
					a9(W, s6 + 1, BB);
				}
				else {
					p MG = new p(W, k, s6 - 1);
					p g = new p(W, s6 + 1, BB);
					MG.e();
					g.N_();
					MG.P();
				}
			}
		}
		private static void a9(char[] W, int k, int BB) {	
			if(k >= BB) {
				return;
			}
			int s6 = C(W, k, BB);	
			a9(W, k, s6 - 1);
			a9(W, s6 + 1, BB);
		}
		private static int C(char[] W, int MG, int g) {
			int k = MG;
			int BB = g;
			char s6 = W[MG];	
			while(k < BB) {
				while(W[BB] > s6) --BB;
				while(W[k] <= s6 && k < BB) ++k;
				m(W, k, BB);
			}
			m(W, MG, k);
			return k;
		}
		private static void m(char[] W, int kE, int F) {
			char j = W[kE];
			W[kE] = W[F];
			W[F] = j;
		}
	}
	public static void H(short[] W) {
		new t.p(W, 0, W.S - 1).Uj();
	}
	private static final class t {	
		private static final class p extends i {
			private static final long G = 1L;
			final short[] W;
			final int k;
			final int BB;
			p(short[] W, int k, int BB) {
				this.W = W;
				this.k = k;
				this.BB = BB;
			}
			public final void N_() {
				if(k >= BB) {
					return;
				}
				int s6 = C(W, k, BB);
				if(BB - k < a) {
					a9(W, k, s6 - 1);
					a9(W, s6 + 1, BB);
				}
				else {
					p MG = new p(W, k, s6 - 1);
					p g = new p(W, s6 + 1, BB);
					MG.e();
					g.N_();
					MG.P();
				}
			}
		}
		private static void a9(short[] W, int k, int BB) {	
			if(k >= BB) {
				return;
			}
			int s6 = C(W, k, BB);	
			a9(W, k, s6 - 1);
			a9(W, s6 + 1, BB);
		}
		private static int C(short[] W, int MG, int g) {
			int k = MG;
			int BB = g;
			short s6 = W[MG];	
			while(k < BB) {
				while(W[BB] > s6) --BB;
				while(W[k] <= s6 && k < BB) ++k;
				m(W, k, BB);
			}
			m(W, MG, k);
			return k;
		}
		private static void m(short[] W, int kE, int F) {
			short j = W[kE];
			W[kE] = W[F];
			W[F] = j;
		}
	}
	public static void H(int[] W) {
		new o.p(W, 0, W.S - 1).Uj();
	}
	private static final class o {	
		private static final class p extends i {
			private static final long G = 1L;
			final int[] W;
			final int k;
			final int BB;
			p(int[] W, int k, int BB) {
				this.W = W;
				this.k = k;
				this.BB = BB;
			}
			public final void N_() {
				if(k >= BB) {
					return;
				}
				int s6 = C(W, k, BB);
				if(BB - k < a) {
					a9(W, k, s6 - 1);
					a9(W, s6 + 1, BB);
				}
				else {
					p MG = new p(W, k, s6 - 1);
					p g = new p(W, s6 + 1, BB);
					MG.e();
					g.N_();
					MG.P();
				}
			}
		}
		private static void a9(int[] W, int k, int BB) {	
			if(k >= BB) {
				return;
			}
			int s6 = C(W, k, BB);	
			a9(W, k, s6 - 1);
			a9(W, s6 + 1, BB);
		}
		private static int C(int[] W, int MG, int g) {
			int k = MG;
			int BB = g;
			int s6 = W[MG];	
			while(k < BB) {
				while(W[BB] > s6) --BB;
				while(W[k] <= s6 && k < BB) ++k;
				m(W, k, BB);
			}
			m(W, MG, k);
			return k;
		}
		private static void m(int[] W, int kE, int F) {
			int j = W[kE];
			W[kE] = W[F];
			W[F] = j;
		}
	}
	public static void H(long[] W) {
		new T.p(W, 0, W.S - 1).Uj();
	}
	private static final class T {	
		private static final class p extends i {
			private static final long G = 1L;
			final long[] W;
			final int k;
			final int BB;
			p(long[] W, int k, int BB) {
				this.W = W;
				this.k = k;
				this.BB = BB;
			}
			public final void N_() {
				if(k >= BB) {
					return;
				}
				int s6 = C(W, k, BB);
				if(BB - k < a) {
					a9(W, k, s6 - 1);
					a9(W, s6 + 1, BB);
				}
				else {
					p MG = new p(W, k, s6 - 1);
					p g = new p(W, s6 + 1, BB);
					MG.e();
					g.N_();
					MG.P();
				}
			}
		}
		private static void a9(long[] W, int k, int BB) {	
			if(k >= BB) {
				return;
			}
			int s6 = C(W, k, BB);	
			a9(W, k, s6 - 1);
			a9(W, s6 + 1, BB);
		}
		private static int C(long[] W, int MG, int g) {
			int k = MG;
			int BB = g;
			long s6 = W[MG];	
			while(k < BB) {
				while(W[BB] > s6) --BB;
				while(W[k] <= s6 && k < BB) ++k;
				m(W, k, BB);
			}
			m(W, MG, k);
			return k;
		}
		private static void m(long[] W, int kE, int F) {
			long j = W[kE];
			W[kE] = W[F];
			W[F] = j;
		}
	}
	public static void H(float[] W) {
		new r.p(W, 0, W.S - 1).Uj();
	}
	private static final class r {	
		private static final class p extends i {
			private static final long G = 1L;
			final float[] W;
			final int k;
			final int BB;
			p(float[] W, int k, int BB) {
				this.W = W;
				this.k = k;
				this.BB = BB;
			}
			public final void N_() {
				if(k >= BB) {
					return;
				}
				int s6 = C(W, k, BB);
				if(BB - k < a) {
					a9(W, k, s6 - 1);
					a9(W, s6 + 1, BB);
				}
				else {
					p MG = new p(W, k, s6 - 1);
					p g = new p(W, s6 + 1, BB);
					MG.e();
					g.N_();
					MG.P();
				}
			}
		}
		private static void a9(float[] W, int k, int BB) {	
			if(k >= BB) {
				return;
			}
			int s6 = C(W, k, BB);	
			a9(W, k, s6 - 1);
			a9(W, s6 + 1, BB);
		}
		private static int C(float[] W, int MG, int g) {
			int k = MG;
			int BB = g;
			float s6 = W[MG];	
			while(k < BB) {
				while(W[BB] > s6) --BB;
				while(W[k] <= s6 && k < BB) ++k;
				m(W, k, BB);
			}
			m(W, MG, k);
			return k;
		}
		private static void m(float[] W, int kE, int F) {
			float j = W[kE];
			W[kE] = W[F];
			W[F] = j;
		}
	}
	public static void H(double[] W) {
		new O.p(W, 0, W.S - 1).Uj();
	}
	private static final class O {	
		private static final class p extends i {
			private static final long G = 1L;
			final double[] W;
			final int k;
			final int BB;
			p(double[] W, int k, int BB) {
				this.W = W;
				this.k = k;
				this.BB = BB;
			}
			public final void N_() {
				if(k >= BB) {
					return;
				}
				int s6 = C(W, k, BB);
				if(BB - k < a) {
					a9(W, k, s6 - 1);
					a9(W, s6 + 1, BB);
				}
				else {
					p MG = new p(W, k, s6 - 1);
					p g = new p(W, s6 + 1, BB);
					MG.e();
					g.N_();
					MG.P();
				}
			}
		}
		private static void a9(double[] W, int k, int BB) {	
			if(k >= BB) {
				return;
			}
			int s6 = C(W, k, BB);	
			a9(W, k, s6 - 1);
			a9(W, s6 + 1, BB);
		}
		private static int C(double[] W, int MG, int g) {
			int k = MG;
			int BB = g;
			double s6 = W[MG];	
			while(k < BB) {
				while(W[BB] > s6) --BB;
				while(W[k] <= s6 && k < BB) ++k;
				m(W, k, BB);
			}
			m(W, MG, k);
			return k;
		}
		private static void m(double[] W, int kE, int F) {
			double j = W[kE];
			W[kE] = W[F];
			W[F] = j;
		}
	}
	public static <L> void H(L[] W, B<? super L> q) {
		if(q == null) {
			H(W);
		}
		else {
			new Xl.p<>(W, 0, W.S - 1, q).Uj();
		}
	}
	public static void H(u[] W) {
		new f.p(W, 0, W.S - 1).Uj();
	}
	private static final class f {	
		private static final class p extends i {
			private static final long G = 1L;
			final u[] W;
			final int k;
			final int BB;
			p(u[] W, int k, int BB) {
				this.W = W;
				this.k = k;
				this.BB = BB;
			}
			public final void N_() {
				if(k >= BB) {
					return;
				}
				int s6 = C(W, k, BB);
				if(BB - k < a) {
					a9(W, k, s6 - 1);
					a9(W, s6 + 1, BB);
				}
				else {
					p MG = new p(W, k, s6 - 1);
					p g = new p(W, s6 + 1, BB);
					MG.e();
					g.N_();
					MG.P();
				}
			}
		}
		private static void a9(u[] W, int k, int BB) {
			if(k >= BB) {
				return;
			}
			int s6 = C(W, k, BB);	
			a9(W, k, s6 - 1);
			a9(W, s6 + 1, BB);
		}
		@E({ "rawtypes", "unchecked" })
		private static int C(u[] W, int MG, int g) {
			int k = MG;
			int BB = g;
			R1 s6 = ((R1) W[MG]);	
			while(k < BB) {
				while(s6.hX(W[BB]) < 0) --BB;
				while(s6.hX(W[k]) >= 0 && k < BB) ++k;
				m(W, k, BB);
			}
			m(W, MG, k);
			return k;
		}
		private static void m(u[] W, int kE, int F) {
			u j = W[kE];
			W[kE] = W[F];
			W[F] = j;
		}
	}
	private static final class Xl {
		private static final class p<L> extends i {
			private static final long G = 1L;
			final L[] W;
			final int k;
			final int BB;
			final B<? super L> q;
			p(L[] W, int k, int BB, B<? super L> q) {
				this.W = W;
				this.k = k;
				this.BB = BB;
				this.q = q;
			}
			public final void N_() {
				if(k >= BB) {
					return;
				}
				int s6 = C(W, k, BB, q);	
				if(BB - k < a) {
					a9(W, k, s6 - 1, q);
					a9(W, s6 + 1, BB, q);
				}
				else {
					p<L> MG = new p<>(W, k, s6 - 1, q);
					p<L> g = new p<>(W, s6 + 1, BB, q);
					MG.e();
					g.N_();
					MG.P();
				}
			}
		}
		private static <L> void a9(L[] W, int k, int BB, B<? super L> q) {
			if(k >= BB) {
				return;
			}
			int s6 = C(W, k, BB, q);	
			a9(W, k, s6 - 1, q);
			a9(W, s6 + 1, BB, q);
		}
		private static <L> int C(L[] W, int MG, int g, B<? super L> q) {
			int k = MG;
			int BB = g;
			L s6 = W[MG];
			while(k < BB) {
				while(q.qS(s6, W[BB]) < 0) --BB;
				while(q.qS(W[k], s6) <= 0 && k < BB) ++k;
				m(W, k, BB);
			}
			m(W, MG, k);
			return k;
		}
		private static <L> void m(L[] W, int kE, int F) {
			L j = W[kE];
			W[kE] = W[F];
			W[F] = j;
		}
	}
	public static void H(byte[] W, boolean aq) {
		if(aq) {
			vZ[] Et = nu.A(W);
			H(Et, n.l());
			nu.Gz(Et, W);
		}
		else {
			H(W);
		}
	}
	public static void H(char[] W, boolean aq) {
		if(aq) {
			Z[] Et = nu.W5(W);
			H(Et, n.l());
			nu.D(Et, W);
		}
		else {
			H(W);
		}
	}
	public static void H(short[] W, boolean aq) {
		if(aq) {
			v9[] Et = nu.x(W);
			H(Et, n.l());
			nu.X(Et, W);
		}
		else {
			H(W);
		}
	}
	public static void H(int[] W, boolean aq) {
		if(aq) {
			AX[] Et = nu.J(W);
			H(Et, n.l());
			nu.y(Et, W);
		}
		else {
			H(W);
		}
	}
	public static void H(long[] W, boolean aq) {
		if(aq) {
			f4[] Et = nu.M(W);
			H(Et, n.l());
			nu.z(Et, W);
		}
		else {
			H(W);
		}
	}
	public static void H(float[] W, boolean aq) {
		if(aq) {
			Tg[] Et = nu.c(W);
			H(Et, n.l());
			nu.R(Et, W);
		}
		else {
			H(W);
		}
	}
	public static void H(double[] W, boolean aq) {
		if(aq) {
			TD[] Et = nu.w(W);
			H(Et, n.l());
			nu.N(Et, W);
		}
		else {
			H(W);
		}
	}
}