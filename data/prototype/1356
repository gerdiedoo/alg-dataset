import {sameValueZero, strictEquals, isFunction} from '../utils';
import {Option} from "../option";
export function hash(key, len = 0, seed = 0) {
    len = len > 0 ? Math.min(len, key.length) : key.length;
    seed |= 0;
    const remaining = len & 1;
    const doubleBytes = len - remaining;
    let hash = seed, k = 0, i = 0;
    while (i < doubleBytes) {
        k = (key.charCodeAt(i++) & 0xffff) |
            ((key.charCodeAt(i++) & 0xffff) << 16);
        k *= 0xcc9e2d51;
        k = (k << 15) | (k >>> 17);
        k *= 0x1b873593;
        hash ^= k;
        hash = (hash << 13) | (hash >>> 19);
        hash *= 5;
        hash += 0xe6546b64;
    }
    if (remaining) {
        k ^= (key.charCodeAt(i) & 0xffff);
        k *= 0xcc9e2d51;
        k = (k << 15) | (k >>> 17);
        k *= 0x1b873593;
        hash ^= k;
    }
    hash ^= len;
    hash ^= hash >>> 16;
    hash *= 0x85ebca6b;
    hash ^= hash >>> 13;
    hash *= 0xc2b2ae35;
    hash ^= hash >>> 16;
    return hash | 0;
}
export function hashCodeFor(key) {
    const keyType = typeof key;
    switch (keyType) {
        case 'undefined':
            return 0;
        case 'boolean':
            return key ? 1 : 0;
        case 'string':
            return hash(key);
        case 'number':
            if (!Number.isFinite(key)) {
                return 0;
            }
            if (Number.isSafeInteger(key)) {
                return key | 0;
            }
            return hash(key.toString());
        case 'bigint':
        case 'symbol':
        case 'function':
            return hash(key.toString());
        case 'object':
        default: {
            if (key === null) {
                return 0;
            }
            if (key.hashCode) {
                if (isFunction(key.hashCode)) {
                    return hashCodeFor(key.hashCode(key));
                }
                return hashCodeFor(key.hashCode);
            }
            if (key instanceof Date) {
                return key.getTime();
            }
            if (key instanceof RegExp) {
                return hash(key.toString());
            }
            if (key instanceof Option) {
                if (key.has) {
                    return 31 * hashCodeFor(key.value);
                }
                return 0;
            }
            if (Object.prototype.hasOwnProperty.call(key, '_mootable_hashCode')) {
                return hashCodeFor(key._mootable_hashCode);
            }
            const hashCode = HASH_COUNTER++;
            Object.defineProperty(key, '_mootable_hashCode', {
                value: hashCode
            });
            return hashCode;
        }
    }
}
let HASH_COUNTER = 0;
export function equalsFor(key) {
    switch (typeof key) {
        case 'object':
            if (key) {
                if (key instanceof RegExp) {
                    return (me, them) => {
                        if (them instanceof RegExp) {
                            return me.toString() === them.toString();
                        }
                        return false;
                    };
                } else if (key instanceof Date) {
                    return (me, them) => {
                        if (them instanceof Date) {
                            return me.getTime() === them.getTime();
                        }
                        return false;
                    };
                } else if (key instanceof Option) {
                    if (key.has) {
                        const valueEquals = equalsFor(key.value);
                        return (me, them) => {
                            if (them.has) {
                                return valueEquals(me.value, them.value);
                            }
                            return false;
                        };
                    } else {
                        return (me, them) => !them.has;
                    }
                } else if (isFunction(key.equals)) {
                    return (me, them) => me.equals(them, me);
                }
            }
            return strictEquals;
        case 'number':
        case 'bigint':
            return sameValueZero;
        default:
            return strictEquals;
    }
}
export function equalsAndHash(key, options) {
    if (options) {
        let hash = options.hash;
        let equals = options.equals;
        if (isFunction(hash)) {
            hash = hash(key);
        }
        if (!Number.isSafeInteger(hash)) {
            hash = hashCodeFor(key);
        }
        if (!isFunction(equals)) {
            equals = equalsFor(key);
        }
        return {hash, equals};
    }
    const toSetOn = {};
    const keyType = typeof key;
    switch (keyType) {
        case 'undefined':
            toSetOn.hash = 0;
            toSetOn.equals = strictEquals;
            return toSetOn;
        case 'boolean':
            toSetOn.hash = key ? 1 : 0;
            toSetOn.equals = strictEquals;
            return toSetOn;
        case 'string':
            toSetOn.hash = hash(key);
            toSetOn.equals = strictEquals;
            return toSetOn;
        case 'number':
            if (!Number.isFinite(key)) {
                toSetOn.hash = 0;
                toSetOn.equals = sameValueZero;
                return toSetOn;
            }
            if (Number.isSafeInteger(key)) {
                toSetOn.hash = key | 0;
                toSetOn.equals = sameValueZero;
                return toSetOn;
            }
            toSetOn.hash = hash(key.toString());
            toSetOn.equals = sameValueZero;
            return toSetOn;
        case 'bigint':
            toSetOn.hash = hash(key.toString());
            toSetOn.equals = sameValueZero;
            return toSetOn;
        case 'symbol':
        case 'function':
            toSetOn.hash = hash(key.toString());
            toSetOn.equals = strictEquals;
            return toSetOn;
        case 'object':
        default: {
            if (key === null) {
                toSetOn.hash = 0;
                toSetOn.equals = strictEquals;
                return toSetOn;
            }
            toSetOn.equals = equalsFor(key);
            if (key.hashCode) {
                if (isFunction(key.hashCode)) {
                    toSetOn.hash = hashCodeFor(key.hashCode(key));
                    return toSetOn;
                } else {
                    toSetOn.hash = hashCodeFor(key.hashCode);
                    return toSetOn;
                }
            }
            if (key instanceof Date) {
                toSetOn.hash = key.getTime();
                return toSetOn;
            }
            if (key instanceof RegExp) {
                toSetOn.hash = hash(key.toString());
                return toSetOn;
            }
            if (key instanceof Option) {
                if (key.has) {
                    toSetOn.hash = 31 * hashCodeFor(key.value);
                    return toSetOn;
                }
                toSetOn.hash = 0;
                return toSetOn;
            }
            if (Object.prototype.hasOwnProperty.call(key, '_mootable_hashCode')) {
                toSetOn.hash = hashCodeFor(key._mootable_hashCode);
                return toSetOn;
            }
            const hashCode = HASH_COUNTER++;
            Object.defineProperty(key, '_mootable_hashCode', {
                value: hashCode
            });
            toSetOn.hash = hashCode;
            return toSetOn;
        }
    }
}