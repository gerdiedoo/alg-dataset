package U.A.C.bh.iQ;
import U.A.C.bh.*;
import zw.RM.J.yY;
import zw.RM.J.n.Vl;
public abstract class dK implements jE {
  @u
  public void C(int[] z) {
    Vl fQ = new Vl();
    int[] cX = L(z);
    int YT = cX.cU - 1;
    yY f = new yY(YT);
    t[] XB = new t[YT];
    for (int h = 0; h < YT; h++) {
      final int F3 = h;
      XB[F3] = new t(() -> {
        int no = cX[F3];
        int k = cX[F3 + 1];
        for (int e = 1; ; e++) {
          f.eN();
          boolean zH = c(z, no, k, false);
          f.eN();
          zH |= c(z, no, k, true);
          if (zH) fQ.HA(e);
          f.eN();
          if (fQ.N() < e) break;
        }
      });
    }
    for (int h = 0; h < YT; h++) {
      XB[h].kv();
    }
    for (int h = 0; h < YT; h++) {
      try {
        XB[h].y();
      } catch (p q) {
        throw new a(q);
      }
    }
  }
  private int[] L(int[] z) {
    int T = g.l(j.Q().P6(),
          z.cU / 2);
    int r = z.cU;
    int rn = T;
    int[] cX = new int[T + 1];
    for (int h = 0; h < T; h++) {
      int K = r / rn;
      if (K % 2 == 1 && cX[h] + K < z.cU) {
        K++;
      }
      r -= K;
      rn--;
      cX[h + 1] = cX[h] + K;
    }
    return cX;
  }
  abstract boolean c(int[] z, int no, int k,
                                 boolean cm);
  @u
  public void C(int[] z, S At) {
  }
}