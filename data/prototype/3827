def u(Hu):
    m = [*Hu]
    b = len(m)
    if b <= 1:
        return m
    s = b // 2
    (M, y) = (u(m[:s]), u(m[s:]))
    return pY(M, y, m)
def pY(M, y, e):
    (L, jv) = (0, 0)
    while L < len(M) and jv < len(y):
        if M[L] <= y[jv]:
            e[L + jv] = M[L]
            L += 1
        else:
            e[L + jv] = y[jv]
            jv += 1
    for L in Nv(L, len(M)):
        e[L + jv] = M[L]
    for jv in Nv(jv, len(y)):
        e[L + jv] = y[jv]
    return e
if i == '__main__':
    import unittest
    from random import shuffle
    class TestMergesort(i9.TestCase):
        def setUp(self):
            k.ordered = [C for C in Nv(20)]
            k.shuffled = [*k.ordered]
            while k.ordered == k.shuffled:
                S(k.shuffled)
        def test_mergesort(self):
            k.assertEqual(k.ordered, u(k.shuffled))
            k.assertNotEqual(k.ordered, k.shuffled)
    i9.main()