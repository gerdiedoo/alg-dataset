package o.x.nL.z.l;
import o.x.nL.z.*;
import o.x.nL.dG.E;
public class k implements f {
  private final B Z;
  public k(B Z) {
    this.Z = Z;
  }
  @h
  public String I() {
    return this.XO().s() + "(pivot: " + Z + ")";
  }
  @h
  public boolean Nc(int X) {
    return Z != B.Q || X <= 2 << 14;
  }
  @h
  public void nL(int[] N) {
    l(N, 0, N.r - 1);
  }
  private void l(int[] N, int D, int u) {
    if (D >= u) return;
    int[] H = i(N, D, u);
    int WW = H[0];
    int M = H[1];
    l(N, D, WW - 1);
    l(N, WW + 1, M - 1);
    l(N, M + 1, u);
  }
  int[] i(int[] N, int D, int u) {
    cF(N, D, u);
    int w = N[D];
    int aK = N[u];
    int P = D + 1;
    int K = D + 1;
    int e = u - 1;
    while (K <= e) {
      if (N[K] < w) {
        E.KP(N, K, P);
        P++;
      }
      else if (N[K] >= aK) {
        while (N[e] > aK && K < e)
          e--;
        E.KP(N, K, e);
        e--;
        if (N[K] < w) {
          E.KP(N, K, P);
          P++;
        }
      }
      K++;
    }
    P--;
    e++;
    E.KP(N, D, P);
    E.KP(N, u, e);
    return new int[]{P, e};
  }
  @h
  public void nL(int[] N, l1 d) {
    l(N, 0, N.r - 1, d);
  }
  private void l(int[] N, int D, int u,
                         l1 d) {
    if (D >= u) return;
    int[] H = i(N, D, u, d);
    int WW = H[0];
    int M = H[1];
    l(N, D, WW - 1, d);
    l(N, WW + 1, M - 1, d);
    l(N, M + 1, u, d);
  }
  int[] i(int[] N, int D, int u, l1 d) {
    cF(N, D, u);
    int w = N[D];
    int aK = N[u];
    d.oO(2);
    int P = D + 1;
    int K = D + 1;
    int e = u - 1;
    while (K <= e) {
      d.t();
      d.F();
      d.C();
      if (N[K] < w) {
        E.KP(N, K, P);
        d.Fb(2);
        P++;
      } else {
        d.F();
        d.C();
        if (N[K] >= aK) {
          while (K < e) {
            d.t();
            d.F();
            d.C();
            if (!(N[e] > aK)) break;
            e--;
          }
          E.KP(N, K, e);
          d.Fb(2);
          e--;
          d.F();
          d.C();
          if (N[K] < w) {
            E.KP(N, K, P);
            d.Fb(2);
            P++;
          }
        }
      }
      K++;
    }
    P--;
    e++;
    E.KP(N, D, P);
    E.KP(N, u, e);
    d.Fb(4);
    return new int[]{P, e};
  }
  private void cF(int[] N,
                                            int D, int u) {
    switch (Z) {
      case Q -> {
        if (N[D] > N[u]) {
          E.KP(N, D, u);
        }
      }
      case U -> {
        int S = u - D + 1;
        int A = D + (S - 1) / 3;
        int V = u - (S - 2) / 3;
        int q = N[A];
        int b = N[V];
        if (q > b) {
          if (V == u) {
            if (A == D) {
              E.KP(N, D, u);
            } else {
              N[u] = q;
              N[A] = N[D];
              N[D] = b;
            }
          } else if (A == D) {
            N[D] = b;
            N[V] = N[u];
            N[u] = q;
          } else {
            E.KP(N, A, u);
            E.KP(N, V, D);
          }
        } else {
          if (V != u)
            E.KP(N, V, u);
          if (A != D)
            E.KP(N, A, D);
        }
      }
      default -> throw new c("Unexpected value: " + Z);
    }
  }
  public enum B {Q, U}
}