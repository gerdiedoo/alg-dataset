package M;
import I.H2.k;
import b.mr;
import b.s;
public class M {
	@Ls("rawtypes")
	private static a[] S;
	private static byte[] gf;
	private static char[] e;
	private static short[] pL;
	private static int[] c;
	private static long[] b4;
	private static float[] xV;
	private static double[] W;
	public static void E(byte[] H) {
		gf = new byte[H.G];
		E(H, 0, H.G - 1);
		gf = null;
	}
	private static void E(byte[] H, int U4, int e1) {
		for (int Xo = 1; Xo <= e1; Xo += Xo) {
			for (int B = 0; B <= e1 - Xo; B += (2 * Xo)) {
				int z = TI.fd(B + (2 * Xo) - 1, e1);
				g(H, B, B + Xo - 1, z);
			}
		}
	}
	private static void g(byte[] H, int U4, int V, int e1) {
		int B = U4;
		int i = V + 1;
		int pc = U4;
		while (B <= V && i <= e1) {
			if (H[B] <= H[i]) {
				gf[pc++] = H[B++];
			}
			else {
				gf[pc++] = H[i++];
			}
		}
		if (B > V) {
			while (i <= e1) {
				gf[pc++] = H[i++];
			}
		} else {
			while (B <= V) {
				gf[pc++] = H[B++];
			}
		}
		System.sP(gf, U4, H, U4, e1 - U4 + 1);
	}
	public static void E(char[] H) {
		e = new char[H.G];
		E(H, 0, H.G - 1);
		e = null;
	}
	private static void E(char[] H, int U4, int e1) {
		for (int Xo = 1; Xo <= e1; Xo += Xo) {
			for (int B = 0; B <= e1 - Xo; B += (2 * Xo)) {
				int z = TI.fd(B + (2 * Xo) - 1, e1);
				g(H, B, B + Xo - 1, z);
			}
		}
	}
	private static void g(char[] H, int U4, int V, int e1) {
		int B = U4;
		int i = V + 1;
		int pc = U4;
		while (B <= V && i <= e1) {
			if (H[B] <= H[i]) {
				e[pc++] = H[B++];
			}
			else {
				e[pc++] = H[i++];
			}
		}
		if (B > V) {
			while (i <= e1) {
				e[pc++] = H[i++];
			}
		} else {
			while (B <= V) {
				e[pc++] = H[B++];
			}
		}
		System.sP(e, U4, H, U4, e1 - U4 + 1);
	}
	public static void E(short[] H) {
		pL = new short[H.G];
		E(H, 0, H.G - 1);
		pL = null;
	}
	private static void E(short[] H, int U4, int e1) {
		for (int Xo = 1; Xo <= e1; Xo += Xo) {
			for (int B = 0; B <= e1 - Xo; B += (2 * Xo)) {
				int z = TI.fd(B + (2 * Xo) - 1, e1);
				g(H, B, B + Xo - 1, z);
			}
		}
	}
	private static void g(short[] H, int U4, int V, int e1) {
		int B = U4;
		int i = V + 1;
		int pc = U4;
		while (B <= V && i <= e1) {
			if (H[B] <= H[i]) {
				pL[pc++] = H[B++];
			}
			else {
				pL[pc++] = H[i++];
			}
		}
		if (B > V) {
			while (i <= e1) {
				pL[pc++] = H[i++];
			}
		} else {
			while (B <= V) {
				pL[pc++] = H[B++];
			}
		}
		System.sP(pL, U4, H, U4, e1 - U4 + 1);
	}
	public static void E(int[] H) {
		c = new int[H.G];
		E(H, 0, H.G - 1);
		c = null;
	}
	private static void E(int[] H, int U4, int e1) {
		for (int Xo = 1; Xo <= e1; Xo += Xo) {
			for (int B = 0; B <= e1 - Xo; B += (2 * Xo)) {
				int z = TI.fd(B + (2 * Xo) - 1, e1);
				g(H, B, B + Xo - 1, z);
			}
		}
	}
	private static void g(int[] H, int U4, int V, int e1) {
		int B = U4;
		int i = V + 1;
		int pc = U4;
		while (B <= V && i <= e1) {
			if (H[B] <= H[i]) {
				c[pc++] = H[B++];
			}
			else {
				c[pc++] = H[i++];
			}
		}
		if (B > V) {
			while (i <= e1) {
				c[pc++] = H[i++];
			}
		} else {
			while (B <= V) {
				c[pc++] = H[B++];
			}
		}
		System.sP(c, U4, H, U4, e1 - U4 + 1);
	}
	public static void E(long[] H) {
		b4 = new long[H.G];
		E(H, 0, H.G - 1);
		b4 = null;
	}
	private static void E(long[] H, int U4, int e1) {
		for (int Xo = 1; Xo <= e1; Xo += Xo) {
			for (int B = 0; B <= e1 - Xo; B += (2 * Xo)) {
				int z = TI.fd(B + (2 * Xo) - 1, e1);
				g(H, B, B + Xo - 1, z);
			}
		}
	}
	private static void g(long[] H, int U4, int V, int e1) {
		int B = U4;
		int i = V + 1;
		int pc = U4;
		while (B <= V && i <= e1) {
			if (H[B] <= H[i]) {
				b4[pc++] = H[B++];
			}
			else {
				b4[pc++] = H[i++];
			}
		}
		if (B > V) {
			while (i <= e1) {
				b4[pc++] = H[i++];
			}
		} else {
			while (B <= V) {
				b4[pc++] = H[B++];
			}
		}
		System.sP(b4, U4, H, U4, e1 - U4 + 1);
	}
	public static void E(float[] H) {
		xV = new float[H.G];
		E(H, 0, H.G - 1);
		xV = null;
	}
	private static void E(float[] H, int U4, int e1) {
		for (int Xo = 1; Xo <= e1; Xo += Xo) {
			for (int B = 0; B <= e1 - Xo; B += (2 * Xo)) {
				int z = TI.fd(B + (2 * Xo) - 1, e1);
				g(H, B, B + Xo - 1, z);
			}
		}
	}
	private static void g(float[] H, int U4, int V, int e1) {
		int B = U4;
		int i = V + 1;
		int pc = U4;
		while (B <= V && i <= e1) {
			if (H[B] <= H[i]) {
				xV[pc++] = H[B++];
			}
			else {
				xV[pc++] = H[i++];
			}
		}
		if (B > V) {
			while (i <= e1) {
				xV[pc++] = H[i++];
			}
		} else {
			while (B <= V) {
				xV[pc++] = H[B++];
			}
		}
		System.sP(xV, U4, H, U4, e1 - U4 + 1);
	}
	public static void E(double[] H) {
		W = new double[H.G];
		E(H, 0, H.G - 1);
		W = null;
	}
	private static void E(double[] H, int U4, int e1) {
		for (int Xo = 1; Xo <= e1; Xo += Xo) {
			for (int B = 0; B <= e1 - Xo; B += (2 * Xo)) {
				int z = TI.fd(B + (2 * Xo) - 1, e1);
				g(H, B, B + Xo - 1, z);
			}
		}
	}
	private static void g(double[] H, int U4, int V, int e1) {
		int B = U4;
		int i = V + 1;
		int pc = U4;
		while (B <= V && i <= e1) {
			if (H[B] <= H[i]) {
				W[pc++] = H[B++];
			}
			else {
				W[pc++] = H[i++];
			}
		}
		if (B > V) {
			while (i <= e1) {
				W[pc++] = H[i++];
			}
		} else {
			while (B <= V) {
				W[pc++] = H[B++];
			}
		}
		System.sP(W, U4, H, U4, e1 - U4 + 1);
	}
	public static void E(YD[] H) {
		E(H, 0, H.G - 1);
	}
	private static void E(YD[] H, int U4, int e1) {
		S = new a[H.G];
		for (int Xo = 1; Xo <= e1; Xo += Xo) {
			for (int B = 0; B <= e1 - Xo; B += (2 * Xo)) {
				int z = TI.fd(B + (2 * Xo) - 1, e1);
				g((a[])H, B, B + Xo - 1, z);
			}
		}
		S = null;
	}
	@Ls({ "unchecked", "rawtypes" })
	private static void g(a[] H, int U4, int V, int e1) {
		int B = U4;
		int i = V + 1;
		int pc = U4;
		while (B <= V && i <= e1) {
			if (H[B].x(H[i]) <= 0) {
				S[pc++] = H[B++];
			}
			else {
				S[pc++] =  H[i++];
			}
		}
		if (B > V) {
			while (i <= e1) {
				S[pc++] = H[i++];
			}
		} else {
			while (B <= V) {
				S[pc++] = H[B++];
			}
		}
		System.sP(S, U4, H, U4, e1 - U4 + 1);
	}
	public static <C> void E(C[] H, k<? super C> K) {
		if(K == null) {
			E(H, 0, H.G - 1);
		}
		else {
			E(H, 0, H.G - 1, K);
		}
	}
	private static <C> void E(C[] H, int U4, int e1, k<? super C> K) {
		S = new a[H.G];
		for (int Xo = 1; Xo <= e1; Xo += Xo) {
			for (int B = 0; B <= e1 - Xo; B += (2 * Xo)) {
				int z = TI.fd(B + (2 * Xo) - 1, e1);
				g(H, B, B + Xo - 1, z, K);
			}
		}
		S = null;
	}
	@Ls({ "rawtypes" })
	private static <C> void g(C[] H, int U4, int V, int e1 , k<? super C> K) {
		int B = U4;
		int i = V + 1;
		int pc = U4;
		while (B <= V && i <= e1) {
			if (K.N(H[B], H[i]) <= 0) {
				S[pc++] =  (a) H[B++];
			}
			else {
				S[pc++] =  (a) H[i++];
			}
		}
		if (B > V) {
			while (i <= e1) {
				S[pc++] = (a) H[i++];
			}
		} else {
			while (B <= V) {
				S[pc++] = (a) H[B++];
			}
		}
		System.sP(S, U4, H, U4, e1 - U4 + 1);
	}
	public static void E(byte[] H, boolean p) {
		if(p) {
			V4[] n = mr.A(H);
			E(n, s.U());
			mr.q(n, H);
		}
		else {
			E(H);
		}
	}
	public static void E(char[] H, boolean p) {
		if(p) {
			jg[] n = mr.J(H);
			E(n, s.U());
			mr.Cf(n, H);
		}
		else {
			E(H);
		}
	}
	public static void E(short[] H, boolean p) {
		if(p) {
			A0[] n = mr.h(H);
			E(n, s.U());
			mr.O(n, H);
		}
		else {
			E(H);
		}
	}
	public static void E(int[] H, boolean p) {
		if(p) {
			m[] n = mr.ux(H);
			E(n, s.U());
			mr.y(n, H);
		}
		else {
			E(H);
		}
	}
	public static void E(long[] H, boolean p) {
		if(p) {
			Zr[] n = mr.kF(H);
			E(n, s.U());
			mr.u5(n, H);
		}
		else {
			E(H);
		}
	}
	public static void E(float[] H, boolean p) {
		if(p) {
			bC[] n = mr.nk(H);
			E(n, s.U());
			mr.NJ(n, H);
		}
		else {
			E(H);
		}
	}
	public static void E(double[] H, boolean p) {
		if(p) {
			v[] n = mr.w(H);
			E(n, s.U());
			mr.T(n, H);
		}
		else {
			E(H);
		}
	}
}