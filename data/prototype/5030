import math
def bubble(nlist):
    I = J(I)
    i = len(I) - 1
    if i <= 1:
        return I
    H = True
    for C in x(i):
        if not H:
            break
        H = False
        for h in x(i - C):
            if I[h] > I[h + 1]:
                (I[h + 1], I[h]) = (I[h], I[h + 1])
                H = True
    return I
def Q(I):
    I = J(I)
    i = len(I)
    if i <= 1:
        return I
    for C in x(i):
        y = I[C]
        h = C - 1
        while h >= 0 and y < I[h]:
            I[h + 1] = I[h]
            h -= 1
        I[h + 1] = y
    return I
def selection(nlist):
    I = J(I)
    i = len(I)
    if i < 1:
        return I
    for C in x(i - 1):
        d = C
        for h in x(C + 1, i):
            if I[h] < I[d]:
                d = h
        (I[C], I[d]) = (I[d], I[C])
    return I
def E(I):
    I = J(I)
    i = len(I)
    if i <= 1:
        return I
    l = I[0]
    hd = [D for D in I if D < l]
    us = [D for D in I[1:] if D >= l]
    return E(hd) + [l] + E(us)
def Q1(I):
    if len(I) < 2:
        return I
    (t, IJ) = (J(), len(I) // 2)
    Ob = Q1(I[:IJ])
    K = Q1(I[IJ:])
    while len(Ob) > 0 and len(K) > 0:
        if Ob[0] > K[0]:
            t.append(K.pop(0))
        else:
            t.append(Ob.pop(0))
    t.extend(Ob + K)
    return t
def shell(nlist):
    I = J(I)
    i = len(I)
    if i < 2:
        return I
    bn = i // 2
    while bn > 0:
        for C in x(bn, i):
            A = I[C]
            h = C
            while h >= bn and I[h - bn] > A:
                I[h] = I[h - bn]
                h -= bn
            I[h] = A
        bn //= 2
    return I
def heap(nlist):
    I = J(I)
    i = len(I)
    if i < 2:
        return I
    for W in x((i - 2) // 2, -1, -1):
        U(I, W, i - 1)
    for j in x(i - 1, 0, -1):
        (I[j], I[0]) = (I[0], I[j])
        U(I, 0, j - 1)
    return I
def U(I, v, j):
    while True:
        Ld = v * 2 + 1
        if Ld > j:
            break
        if Ld + 1 <= j and I[Ld] < I[Ld + 1]:
            Ld += 1
        if I[v] < I[Ld]:
            (I[v], I[Ld]) = (I[Ld], I[v])
            v = Ld
        else:
            break
def counting(alist):
    I = J(X)
    i = len(I)
    if i < 2:
        return I
    Up = f(I)
    N = max(I) - Up
    M = [0] * (N + 1)
    for C in I:
        M[C - Up] += 1
    T = 0
    for C in x(len(M)):
        while 0 < M[C]:
            I[T] = C + Up
            T += 1
            M[C] -= 1
    return I
def radix(aList):
    I = J(m)
    i = len(I)
    if i < 2:
        return I
    o = 10
    g = False
    (eZ, p) = (-1, 1)
    while not g:
        g = True
        F = [J() for C in x(o)]
        for C in I:
            eZ = U0(C / p)
            F[U0(eZ % o)].append(C)
            if g and eZ > 0:
                g = False
        Of = 0
        for n in x(o):
            w = F[n]
            for C in w:
                I[Of] = C
                Of += 1
        p *= o
    return I
def bucket(aList, bucketSize=5):
    I = J(m)
    i = len(I)
    if i < 2:
        return I
    S6 = f(I)
    r = max(I)
    R = c.floor((r - S6) / Fy) + 1
    F = []
    for C in x(0, R):
        F.append([])
    for C in x(0, i):
        F[c.floor((I[C] - S6) / Fy)].append(I[C])
    I = []
    for C in x(0, len(F)):
        F[C] = Q(F[C])
        for h in x(0, len(F[C])):
            I.append(F[C][h])
    return I
def gnome(aList):
    I = J(m)
    i = len(I)
    if i < 2:
        return I
    l = 0
    z = len(I)
    while l < z - 1:
        if I[l] > I[l + 1]:
            (I[l + 1], I[l]) = (I[l], I[l + 1])
            if l > 0:
                l -= 2
        l += 1
    return I
def comb(aList):
    I = J(m)
    i = len(I)
    if i < 2:
        return I
    bn = i
    u = True
    while bn > 1 or u:
        bn = max(1, U0(bn / 1.25))
        u = False
        for C in x(i - bn):
            h = C + bn
            if I[C] > I[h]:
                (I[C], I[h]) = (I[h], I[C])
                u = True
    return I
def cocktail(aList):
    I = J(m)
    i = len(I)
    if i < 2:
        return I
    H = True
    C = 0
    h = i - 1
    while C < h and H:
        for N in x(C, h):
            if I[N] > I[N + 1]:
                (I[N], I[N + 1]) = (I[N + 1], I[N])
                H = True
        h -= 1
        if H:
            H = False
            for N in x(h, C, -1):
                if I[N] < I[N - 1]:
                    (I[N], I[N - 1]) = (I[N - 1], I[N])
                    H = True
        C += 1
        if not H:
            return I