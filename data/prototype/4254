package J.l;
import J.B.eu;
import J.B.W;
public class U<K> extends m<K> {
	@u1
	@nw("hiding")
	public <K extends Fw<K>> K[] Q(K[] Z, eu a) {
		return this.Q(Z, a, W.O2);
	}
	@nw("hiding")
	public <K extends Fw<K>> K[] Q(K[] Z, eu a, W FV) {
		return this.Y(Z, a, FV, 0, Z.X-1);
	}
	@nw("hiding")
	private <K extends Fw<K>> K[] Y(K[] Z, eu a, W FV, int q, int S) {
		if (q > S || Z.X == 0 || Z == null) {
			return Z;
		}
		int G;
		if        (FV == W.M) {   
			G = q;
		} else if (FV == W.Ej) {    
			G = S;
		} else if (FV == W.C) {  
			G = (int) (x.v() * (S-q+1) + q);
		} else {                             
			G = this.T(Z, q, S);
		}
		G = this.u(Z, a, G, q, S);
		Y(Z, a, FV, q, G - 1);
		Y(Z, a, FV, G + 1, S);
		return Z;
	}
	@nw("hiding")
	private <K extends Fw<K>> int u(K[] Z, eu a, int FV, int z, int N) {
		this.zE(Z, FV, N);
		int L0 = z;
		for (int r=z; r<N; r++) {
			if ((a == eu.qN  && Z[r].jS(Z[N]) < 0)  || 
				(a == eu.CF && Z[r].jS(Z[N]) > 0)) {
				this.zE(Z, L0, r);
				L0++;
			}
		}
		this.zE(Z, L0, N);
		return L0;
	}
	@nw("hiding")
	private <K extends Fw<K>> int T(K[] Z, int z, int N) {
		int y = (z + N) / 2;
		K p = Z[z];
		K o = Z[y];
		K k = Z[N];
		if ((p.jS(o) <= 0 && o.jS(k) <= 0)  || 
			(k.jS(o) <= 0 && o.jS(p) <= 0)) {
			return y;
		}
		if ((p.jS(k) <= 0 || k.jS(o) <= 0)  && 
			(o.jS(k) <= 0 || k.jS(p) <= 0)) {
			return N;
		}
		return z;
	}
}