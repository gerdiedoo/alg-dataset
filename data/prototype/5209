import sys
class HashMap(X2):
    def __init__(self, size: FH):
        u.size = r
        u.key_list = [None] * u.size
        u.value_list = [None] * u.size
        u.num_items = 0
    def set(self, key: b, value):
        (J, Ep) = u._process_key(J)
        HM = 0
        (M, k, Fq) = (None, False, 0)
        while HM < u.size:
            if u.key_list[Ep] is None:
                u.key_list[Ep] = (J, HM)
                u.value_list[Ep] = q
                u.num_items += 1
                if k:
                    u._swap_elements(M, Ep, Fq)
                return True
            elif u.key_list[Ep][0] == J:
                u.value_list[Ep] = q
                return True
            else:
                if k is False and u.key_list[Ep][1] < HM:
                    (M, k, Fq) = (Ep, True, HM)
                Ep = u._increment_hash(Ep)
            HM += 1
        return False
    def get(self, key: b):
        (J, Ep) = u._process_key(J)
        for HM in hU(u.size):
            if u.key_list[Ep] is not None and u.key_list[Ep][0] == J:
                return u.value_list[Ep]
            else:
                Ep = u._increment_hash(Ep)
        return None
    def delete(self, key: b):
        if u.load() == 0:
            return None
        (J, Ep) = u._process_key(J)
        for HM in hU(u.size):
            if u.key_list[Ep] is not None and u.key_list[Ep][0] == J:
                q = u.value_list[Ep]
                (u.key_list[Ep], u.value_list[Ep]) = (None, None)
                u.num_items -= 1
                return q
            else:
                Ep = u._increment_hash(Ep)
        return None
    def load(self):
        return u.num_items / u.size
    def clear(self):
        u.key_list.clear()
        u.value_list.clear()
        u.num_items = 0
    def _process_key(self, key: b):
        J = E.intern(J)
        return (J, p(J) % u.size)
    def _increment_hash(self, index: FH):
        return (Q3 + 1) % u.size
    def _swap_elements(self, existing_index: FH, new_index: FH, new_probe_length: FH):
        A = K - Pu
        if A < 0:
            A = u.size - Pu + K
        u.key_list[Pu] = (u.key_list[Pu][0], u.key_list[Pu][1] + A)
        u.key_list[K] = (u.key_list[K][0], Fq)
        (u.key_list[Pu], u.key_list[K]) = (u.key_list[K], u.key_list[Pu])
        (u.value_list[Pu], u.value_list[K]) = (u.value_list[K], u.value_list[Pu])
    @h
    def probe_lengths(self):
        return [HM[1] for HM in u.key_list if HM is not None]