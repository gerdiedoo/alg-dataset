package ff.G;
import Fy.N.q.P.AF.pg;
import CG.j.bv;
import CG.j.Mm;
import CG.j.CD;
import CG.u.*;
abstract class t<aw, ii> {
    public static final t lj = new dO(
            new Fy.N.q.P.AF.Nn());
    final Fy.N.q.P.AF.v<aw, TR> En;  
    public static final String UN = new String("Non existing mapping ok");
    private static final I qX = new I();
    public t(Fy.N.q.P.AF.v<aw, TR> En) {
        this.En = En;
    }
    private aw R(aw fr) {
        return fr == null ? (aw) qX : fr;
    }
    private aw OK(aw fr) {
        return fr == qX ? null : fr;
    }
    protected v<aw, ii> B() {
        return E.X7();
    }
    protected abstract dO<aw, ii> sW();
    public ii tc(o<aw, ii> yU, aw fr) {
        I jH = nx(yU, fr);
        return jH != UN ? (ii) jH : null;
    }
    private I nx(o<aw, ii> yU, I fr) {
        aw J = R((aw) fr);
        final TR k4 = En.tc(J);
        if (k4 == null)
            return B().tc(J);
        return p(yU, k4);
    }
    protected static I p(o yU, int k4) {
        switch (k4) {
            case -1:
                return yU.BR;
            case -2:
                return yU.oT;
            case -3:
                return yU.Eg;
        }
        return ((I[]) yU.BR)[k4];
    }
    public ii vc(o<aw, ii> yU, aw fr, I ok) {
        aw J = R(fr);
        TR k4 = En.tc(J);
        I rM = UN;
        if (k4 == null) {
            rM = B().tc(J);
            v<aw, ii> FI = Tk.yL(B(), J, ok);
            if (FI != null) {
                yU.tf = sW().g(FI);
                return (ii) rM;
            }
            if (ok == UN)
                return (ii) rM;
            k4 = ja(yU, J);
        }
        switch (k4) {
            case -1:
                if (rM == UN)
                    rM = yU.BR;
                yU.BR = ok;
                break;
            case -2:
                if (rM == UN)
                    rM = yU.oT;
                yU.oT = ok;
                break;
            case -3:
                if (rM == UN)
                    rM = yU.Eg;
                yU.Eg = ok;
                break;
            default:
                I[] Ir = (I[]) yU.BR;
                if (rM == UN)
                    rM = Ir[k4];
                Ir[k4] = ok;
                break;
        }
        return (ii) rM;
    }
    private TR ja(o<aw, ii> yU, aw fr) {
        final t<aw, ii> eQ = sW().oS(fr, B());
        yU.tf = eQ;
        int lx = En.a();
        if (lx == 3) {
            I[] Ir = new I[4];
            Ir[0] = yU.BR;
            yU.BR = Ir;
        } else if (lx > 3) {
            I[] Ir = (I[]) yU.BR;
            if (Ir.l3 < lx - 1) {
                int w3 = Ir.l3 * 3 / 2;
                w3 += w3 & 1;  
                I[] i5 = new I[w3];
                System.U(Ir, 0, i5, 0, Ir.l3);
                yU.BR = i5;
            }
        }
        return eQ.En.tc(fr);
    }
    public int a(o<aw, ii> yU) {
        return En.a() + B().a() - D(yU);
    }
    private int D(o<aw, ii> yU) {
        int M = 0;
        switch (En.a()) {
            default:  
                for (I Ti : (I[]) yU.BR) {
                    if (Ti == UN) M++;
                }
            case 3:  
                if (yU.BR == UN) M++;
            case 2:  
                if (yU.oT == UN) M++;
            case 1:  
                if (yU.Eg == UN) M++;
            case 0:
        }
        return M;
    }
    public boolean Ii(o<aw, ii> yU, I fr) {
        aw J = R((aw) fr);
        final TR k4 = En.tc(J);
        if (k4 == null)
            return B().Ii(J);
        return p(yU, k4) != UN;
    }
    public O<aw> d1(o<aw, ii> yU) {
        return new t.y9<aw, ii>(yU);
    }
    public O<ii> d(o<aw, ii> yU) {
        return new t.Ax<aw, ii>(yU);
    }
    public O<v.f<aw, ii>> cG(o<aw, ii> yU) {
        return new t.e<aw, ii>(yU);
    }
    public void em(final o<aw, ii> yU, final CD k) throws bv {
        int a = En.a() - D(yU);
        k.l(a);
        if (a > 0)
            for (pg<aw, TR> x : En) {
                I ok = p(yU, x.V6());
                if (ok == UN) continue;
                k.Ui(OK(x.W8()));
                k.Ui(ok);
            }
        k.Ui(B());
    }
    public static <aw, ii> void W5(o<aw, ii> yU, Mm k) throws bv, W {
        int a = k.Bq();
        yU.tf = t.lj;
        for (int i = 0; i < a; i++) {
            aw fr = (aw) k.PV();
            ii ok = (ii) k.PV();
            yU.vc(fr, ok);
        }
        v<aw, ii> TE = (v<aw, ii>) k.PV();
        for (v.f<aw, ii> x : TE.cG()) {
            yU.vc(x.wh(), x.n());
        }
    }
    static class y9<aw, ii> extends w<aw> {
        private final o<aw, ii> yU;
        public y9(o<aw, ii> yU) {
            this.yU = yU;
        }
        @h
        public int a() {
            return yU.a();
        }
        @h
        public boolean ab(I Ti) {
            return yU.Ii(Ti);
        }
        @h
        public boolean H(I Ti) {
            return yU.H(Ti) != null;  
        }
        @h
        public L<aw> sR() {
            return new r<aw, ii>(yU);
        }
        @h
        public void oC() {
            yU.oC();
        }
    }
    static class Ax<aw, ii> extends w<ii> {
        private final o<aw, ii> yU;
        public Ax(o<aw, ii> yU) {
            this.yU = yU;
        }
        @h
        public int a() {
            return yU.a();
        }
        @h
        public L<ii> sR() {
            return new F<aw, ii>(yU);
        }
        @h
        public void oC() {
            yU.oC();
        }
    }
    static class e<aw, ii> extends w<v.f<aw, ii>> {
        private final o<aw, ii> yU;
        public e(o<aw, ii> yU) {
            this.yU = yU;
        }
        @h
        public L<v.f<aw, ii>> sR() {
            return new UP<aw, ii>(yU);
        }
        @h
        public boolean ab(I Ti) {
            if (!(Ti instanceof v.f))
                return false;
            v.f<aw, ii> l7 = (v.f<aw, ii>) Ti;
            aw fr = l7.wh();
            ii ok = l7.n();
            ii A = yU.tc(fr);
            if (ok == null) {
                return A == null && yU.Ii(fr);
            }
            return ok.equals(A);
        }
        @h
        public boolean H(I Ti) {
            if (!(Ti instanceof v.f))
                return false;
            v.f<aw, ii> l7 = (v.f<aw, ii>) Ti;
            return yU.H(l7.wh()) != null;  
        }
        @h
        public int a() {
            return yU.a();
        }
        @h
        public void oC() {
            yU.oC();
        }
    }
    static abstract class G3<aw, ii, s> implements L<s> {
        boolean MW = true;
        private final o<aw, ii> yU;
        L Cz;
        v.f<aw, ii> nU, m;
        public G3(o<aw, ii> yU) {
            this.yU = yU;
            if (yU.oE()) return;
            this.Cz = yU.tf.B().cG().sR();
            aG();
        }
        private void aG() {
            if (!Cz.b() && MW) {
                MW = false;
                Cz = yU.tf.En.C().cG().sR();
            }
            if (!Cz.b()) {
                m = null;
                return;
            }
            while (Cz.b()) {
                v.f x = (v.f) Cz.m();
                ii ok;
                if (MW)
                    ok = (ii) x.n();
                else {
                    ok = (ii) p(yU, (TR) x.n());
                    if (ok == UN) continue;
                }
                m = new X<aw, ii>(yU, (aw) x.wh(), ok);
                return;
            }
            m = null;
        }
        public boolean b() {
            return m != null;
        }
        public v.f<aw, ii> V() {
            if (m == null)
                throw new su();
            nU = m;
            aG();
            return nU;
        }
        public void H() {
            if (nU == null) {
                throw new T();
            }
            yU.H(nU.wh());
            nU = null;
        }
    }
    static class r<aw, ii> extends G3<aw, ii, aw> {
        public r(o<aw, ii> K) {
            super(K);
        }
        public aw m() {
            return V().wh();
        }
    }
    static class F<aw, ii> extends G3<aw, ii, ii> {
        public F(o<aw, ii> K) {
            super(K);
        }
        public ii m() {
            return V().n();
        }
    }
    static class UP<aw, ii> extends G3<aw, ii, v.f<aw, ii>> {
        public UP(o<aw, ii> K) {
            super(K);
        }
        public v.f<aw, ii> m() {
            return V();
        }
    }
    static class X<aw, ii> implements v.f<aw, ii> {
        final aw fr;
        ii ok;
        private final o<aw, ii> yU;
        public X(o<aw, ii> yU, aw fr, ii ok) {
            this.yU = yU;
            this.fr = fr;
            this.ok = ok;
        }
        public aw wh() {
            return yU.tf.OK(fr);
        }
        public ii n() {
            return ok;
        }
        public ii c(ii ok) {
            this.ok = ok;
            return yU.vc(fr, ok);
        }
        private static boolean S(I Y, I Nb) {
            return Y == null ? Nb == null : Y.equals(Nb);
        }
        public boolean equals(I Ti) {
            if (!(Ti instanceof v.f)) {
                return false;
            }
            v.f<?, ?> l7 = (v.f<?, ?>) Ti;
            return S(wh(), l7.wh()) && S(ok, l7.n());
        }
        public int hashCode() {
            return (fr == qX ? 0 : fr.hashCode()) ^
                    (ok == null ? 0 : ok.hashCode());
        }
        @h
        public String toString() {
            return yU.tf.OK(fr) + "=" + ok;
        }
    }
}