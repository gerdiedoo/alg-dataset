package q.C.TX.d;
public class k implements Ov
{
	static H [] m;
    public void E(H[] n)
    {
    	this.m=n;
    	Tk(0, m.S-1);
    	n=this.m;
    }
    private void Tk( int Gs, int u)
    {
		if (Gs < u) {
		    int j = (Gs + u) / 2;
		    Tk( Gs, j);
		    Tk( j+1, u);
		    w(Gs, j, u);
		}
    }
    private void w( int Gs, int j, int u)
    {
	int B = j - Gs + 1;
	int pO = u - j;
	H[] Xc = new H[B + 1];
	H[] A = new H[pO + 1];
	for (int b8 = 0; b8 < B; b8++)
	    Xc[b8] = m[Gs + b8];
	for (int i = 0; i < pO; i++)
	    A[i] = m[j + i + 1];
	Xc[B] = null;	 
	A[pO] = null;
	for (int b8 = 0, i = 0, X = Gs; X <= u; X++) {
	    if (e(Xc[b8], A[i]) <= 0)
		m[X] = Xc[b8++];
	    else
		m[X] = A[i++];
	}
    }
    private int e(H v, H s)
    {
	if (v == null) {
	    if (s == null)
		return 0;	    
	    else
		return 1;	    
	}
	else if (s == null)
	    return -1;		    
	else
	    return v.D(s);  
    }
}