import Z.H.J.z;
import Z.dD.E;
public class b<e extends RO<e> & t<e>>
{
    public static <e extends RO<e> & t<e>> void pY(E<e> Nq)
    {
        m(Nq, 0, Nq.r()-1);
    }
    private static <e extends RO<e> & t<e>> void m(E<e> a, int rk, int AV)
    {
        if (rk < AV)
        {
            int Y = (rk + AV) / 2;
            m(a, rk, Y);
            m(a, Y+1, AV);
            Mg(a, rk, Y, AV);
        }
    }
    private static <e extends RO<e> & t<e>> void Mg(E<e> a, int rk, int Y, int AV)
    {
        E<e> g = new E<e>(a.L(rk, Y+1));
        E<e> D = new E<e>(a.L(Y+1, AV+1));
        g.X(g.B(0).R());
        D.X(D.B(0).R());
        int G = 0;
        int k = 0;
        for (int f = rk; f <= AV; f++)
        {
            if (g.B(G).Iz(D.B(k)) <= 0)
            {
                a.V(f, g.B(G));
                G++;
            }
            else
            {
                a.V(f, D.B(k));
                k++;
            }
        }
    }
    public static <e extends RO<e> & t<e>> void pY(e[] y)
    {
        Kj(y, 0, y.h-1);
    }
    private static <e extends RO<e> & t<e>> void Kj(e[] a, int rk, int AV)
    {
        if (rk < AV)
        {
            int Y = (rk + AV) / 2;
            Kj(a, rk, Y);
            Kj(a, Y+1, AV);
            j_(a, rk, Y, AV);
        }
    }
    private static <e extends RO<e> & t<e>> void j_(e[] a, int rk, int Y, int AV)
    {
        e[] g = (e[]) z.o(a[0].U(),Y-rk +2);
        e[] D = (e[]) z.o(a[0].U(),AV - Y +1);
        I(a, g, rk);
        I(a, D, Y+1);
        int G = 0;
        int k = 0;
        for (int f = rk; f <= AV; f++)
        {
            if (g[G].Iz(D[k]) <= 0)
            {
                a[f] = g[G];
                G++;
            }
            else
            {
                a[f] = D[k];
                k++;
            }
        }
    }
    private static <e extends RO<e> & t<e>> void I(e[] M, e[] O, int rk)
    {
        for (int G = rk; G < rk+O.h-1; G++)
        {
            O[G - rk] = M[G];
        }
        O[O.h-1] = M[0].R();
    }
}