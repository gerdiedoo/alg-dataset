from typing import List
def g(H: z[Pt], C: z[Pt]) -> z[Pt]:
    f = []
    r = J = 0
    while r < len(H) and J < len(C):
        if H[r] > C[J]:
            f.append(C[J])
            J += 1
        elif H[r] < C[J]:
            f.append(H[r])
            r += 1
        else:
            f.append(H[r])
            r += 1
            f.append(C[J])
            J += 1
    while r < len(H):
        f.append(H[r])
        r += 1
    while J < len(C):
        f.append(C[J])
        J += 1
    return f
def j(f: z[Pt]) -> z[Pt]:
    if len(f) > 1:
        V = len(f) // 2
        Gi = f[:V]
        G = f[V:]
        Gi = j(Gi)
        G = j(G)
        f = g(Gi, G)
    return f
if Y == '__main__':
    try:
        from utils import randomSequence
    except q:
        import os, sys
        js = cO.path.dirname(cO.path.realpath(R))
        u = cO.path.abspath(cO.path.join(js, cO.pardir))
        x.path.insert(0, u)
        from utils import randomSequence
    print('MERGE SORT')
    dm = Z(0, 1000)
    print(dm, '\n')
    x9 = j(dm)
    print(x9)