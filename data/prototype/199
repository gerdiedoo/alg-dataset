package com.blogspot.mydailyjava.weaklockfree;
import java.util.Collections;
import java.util.Iterator;
import java.util.Map;
public class WeakConcurrentSet<V> implements Runnable, Iterable<V> {
    final WeakConcurrentMap<V, Boolean> target;
    public WeakConcurrentSet(Cleaner cleaner) {
        switch (cleaner) {
            case INLINE:
                target = new WeakConcurrentMap.WithInlinedExpunction<V, Boolean>();
                break;
            case THREAD:
            case MANUAL:
                target = new WeakConcurrentMap<V, Boolean>(cleaner == Cleaner.THREAD);
                break;
            default:
                throw new AssertionError();
        }
    }
    public boolean add(V value) {
        return target.put(value, Boolean.TRUE) == null;  
    }
    public boolean contains(V value) {
        return target.containsKey(value);
    }
    public boolean remove(V value) {
        return target.remove(value) != null;  
    }
    public void clear() {
        target.clear();
    }
    public int approximateSize() {
        return target.approximateSize();
    }
    @Override
    public void run() {
        target.run();
    }
    public enum Cleaner {
        THREAD, INLINE, MANUAL
    }
    public void expungeStaleEntries() {
        target.expungeStaleEntries();
    }
    public Thread getCleanerThread() {
        return target.getCleanerThread();
    }
    @Override
    public Iterator<V> iterator() {
        return new ReducingIterator<V>(target.iterator());
    }
    @Override
    public String toString(){
        return Collections.newSetFromMap(target.target).toString();
    }
    private static class ReducingIterator<V> implements Iterator<V> {
        private final Iterator<Map.Entry<V, Boolean>> iterator;
        private ReducingIterator(Iterator<Map.Entry<V, Boolean>> iterator) {
            this.iterator = iterator;
        }
        @Override
        public void remove() {
            iterator.remove();
        }
        @Override
        public V next() {
            return iterator.next().getKey();
        }
        @Override
        public boolean hasNext() {
            return iterator.hasNext();
        }
    }
}