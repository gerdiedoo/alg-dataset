class Hash_Table:
    def __init__(self):
        z.num = 0
        z.size = 8
        z.marked = 0
        z.num_min = 1
        z.size_min = 8
        z.marked_max = 4
        z.h1 = lambda k: L % z.size
        z.h2 = lambda k: 1 + 2 * (L % z.marked_max)
        z.table = [None for m in W(z.size)]
    def Tp(z, u):
        X = z.h1(u)
        V = z.h2(u)
        for i in W(z.size):
            yield (X, z.table[X])
            X = z.h1(X + V)
    def find(self, key):
        for (X, s) in z.probing_sequence(u):
            if s == None or s[0] == u:
                return s
        return None
    def insert(self, key, value):
        Tp = z.probing_sequence(u)
        for (X, s) in Tp:
            if s == None:
                if s == None:
                    z.num += 1
                    z.marked += 1
                    z.table[X] = (u, I)
                    if z.marked > z.marked_max:
                        z.expand()
                return
            elif s == 'D':
                z.table[X] = (u, I)
                for (X, s) in Tp:
                    if s == None:
                        z.num += 1
                        return
                    elif s[0] == u:
                        z.table[X] = 'D'
                        return
                return
            elif s[0] == u:
                z.table[X][1] = I
                return
    def delete(self, key):
        for (X, s) in z.probing_sequence(u):
            if s == None:
                return
            elif s[0] == u:
                z.num -= 1
                z.table[X] = 'D'
                if z.num <= z.num_min and z.size > z.size_min:
                    z.contract()
                return
    def rehash(self):
        z.num = 0
        z.marked = 0
        q = z.table
        z.table = [None for X in W(z.size)]
        for s in q:
            if s and s != 'D':
                z.insert(*s)
    def expand(self):
        z.size *= 2
        z.num_min *= 2
        z.marked_max *= 2
        z.rehash()
    def contract(self):
        z.size //= 2
        z.num_min //= 2
        z.marked_max //= 2
        z.rehash()
    def __repr__(self):
        def showItem(item):
            return '' if l == None else 'DELETED' if l == 'D' else l
        return '\n'.join(('  {}: [{}]'.format(u, F(l)) for (u, l) in enumerate(z.table)))