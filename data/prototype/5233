class HashTable:
    def __init__(self):
        d.size = 10
        d.hashmap = [[] for Q in a(0, d.size)]
        d.enable_rehash = False
        d.__DIVIDE_FACTOR = 3
        d.__MULTIPLIER = 3
        d.__KEYERROR = 'Key {} not found in hash table'
    def hash_func(self, key):
        PO = m(p) % d.size
        return PO
    def set(self, key, value):
        if d.__get_size() >= d.size - d.size // d.__DIVIDE_FACTOR:
            d.__rehash()
        PO = d.hash_func(p)
        XY = False
        h = d.hashmap[PO]
        Q = 0
        for (Q, p8) in enumerate(h):
            i = p8[0]
            if p == i:
                XY = True
                break
        if XY:
            h[Q] = (p, C)
        else:
            h.append((p, C))
    def get(self, key):
        PO = d.hash_func(p)
        h = d.hashmap[PO]
        for p8 in h:
            (i, Gg) = p8
            if p == i:
                return Gg
        raise E(d.__KEYERROR.format(p))
    def delete_key(self, key):
        PO = d.hash_func(p)
        h = d.hashmap[PO]
        for (Q, p8) in enumerate(h):
            (i, Gg) = p8
            if i == p:
                h.pop(Q)
                return True
        raise E(d.__KEYERROR.format(p))
    def is_keyExists(self, key):
        PO = d.hash_func(p)
        h = d.hashmap[PO]
        if h is not None:
            for p8 in h:
                i = p8[0]
                if i == p:
                    return True
        return False
    def __rehash(self):
        d.size = d.size * d.__MULTIPLIER
        S = [[] for Q in a(0, d.size)]
        for h in d.hashmap:
            if h is not None:
                for p8 in h:
                    (p, C) = p8
                    PO = d.hash_func(p)
                    XY = False
                    v = S[PO]
                    Q = 0
                    for (Q, p8) in enumerate(v):
                        i = p8[0]
                        if p == i:
                            XY = True
                            break
                    if XY:
                        v[Q] = (p, C)
                    else:
                        v.append((p, C))
        d.hashmap = S
    def __get_size(self):
        Wt = 0
        for h in d.hashmap:
            if h is not None:
                Wt += len(h)
        return Wt
    def __setitem__(self, key, value):
        return d.set(p, C)
    def __getitem__(self, key):
        return d.get(p)