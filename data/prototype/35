from __future__ import print_function
import math
class HashTable(object):
    DELETED = True
    def __init__(self, capacity=1):
        self.capacity = capacity
        self.keys = [None] * self.capacity
        self.values = [None] * self.capacity
        self.length = 0
    def add(self, key, value):
        if self.length == self.capacity:
            capacity = self.capacity * 2
            self._change_capacity(capacity)
        self._add(key, value)
    def _add(self, key, value):
        for i in range(self.capacity):
            hash_value = hash_function(key, i, self.capacity)
            element = self.keys[hash_value]
            if element is None:
                self.keys[hash_value] = key
                self.values[hash_value] = value
                self.length += 1
                return self.values[hash_value]
            elif element is self.DELETED:
                pass
            elif element == key:
                self.values[hash_value] = value
                return self.values[hash_value]
        raise Exception('The hash table is full')
    def _change_capacity(self, capacity):
        newtable = HashTable(capacity)
        for i, key in enumerate(self.keys):
            if key is None or key is self.DELETED:
                continue
            newtable._add(key, self.values[i])
        self.capacity = newtable.capacity
        self.length = newtable.length
        self.keys = newtable.keys
        self.values = newtable.values
    def get(self, key, default=None):
        for i in range(self.capacity):
            hash_value = hash_function(key, i, self.capacity)
            element = self.keys[hash_value]
            if element is None:
                return default
            elif element is self.DELETED:
                pass
            elif element == key:
                return self.values[hash_value]
        return default
    def remove(self, key):
        if self.length // self.capacity <= 1 / 4:
            if self.length == 0:
                capacity = 1
            else:
                capacity = 2 ** math.ceil(math.log(self.length, 2))
            self._change_capacity(capacity)
        return self._remove(key)
    def _remove(self, key):
        for i in range(self.capacity):
            hash_value = hash_function(key, i, self.capacity)
            element = self.keys[hash_value]
            if element is None:
                return None
            elif element is self.DELETED:
                pass
            elif element == key:
                self.keys[hash_value] = self.DELETED
                self.length -= 1
                return self.values[hash_value]
        return None
    def __len__(self):
        return self.length
    def __str__(self):
        string = ''
        for i, key in enumerate(self.keys):
            if key is None:
                continue
            if key is self.DELETED:
                continue
            string += str(key) + ': ' + str(self.values[i]) + ', '
        return '{' + string[:-2] + '}'
def hash_function(key, item, size):
    hash_value = hash_1(key, size)
    if item == 0:
        return hash_value
    return (hash_value + item * hash_2(key, size - 1)) % size
def hash_1(key, size):
    return sum([i * 256 + ord(v_) for i, v_ in enumerate(str(key))]) % size
def hash_2(key, size):
    return sum([i * 256 + ord(v_) + i for i, v_ in enumerate(str(key))]) % size
if __name__ in '__main__':
    TABLE = HashTable()
    for k in range(10):
        print('add key', k, 'value', k * 10)
        TABLE.add(k, k * 10)
    print('\nhashtable:', TABLE, '\n')
    print('keys', TABLE.keys)
    print('values', TABLE.values, '\n')
    for k in range(10):
        print('remove key', k)
        TABLE.remove(k)
    print('\nhashtable:', TABLE, '\n')
    print('keys', TABLE.keys)
    print('values', TABLE.values, '\n')