import Rg.z.hB;
import Rg.z.l;
import Rg.z.i;
import Rg.z.S;
import Rg.z.J;
public class j {
    public static <I> void G(I[] u2, l<I> Gq) {
        if (u2 == null) {
            throw new Y("Input array can not be null.");
        }
        if (Gq == null) {
            throw new Y("Input Gq can not "
                    + "be null.");
        }
        int y;
        I M;
        for (int V = 1; V < u2.Cw; V++) {
            y = V;
            while (y > 0
                    && Gq.B(u2[y - 1],
                    u2[y]) > 0) {
                M = u2[y - 1];
                u2[y - 1] = u2[y];
                u2[y] = M;
                --y;
            }
        }
    }
    public static <I> I it(int K, I[] u2, l<I> Gq,
                                     J Zy) {
        if (u2 == null) {
            throw new Y("Input array can not be null.");
        }
        if (Gq == null) {
            throw new Y("l can not be null.");
        }
        if (Zy == null) {
            throw new Y("J can not be null.");
        }
        if (K < 1 || K > u2.Cw) {
            throw new Y("K is out of the array range.");
        }
        return p(K, u2, Gq, Zy, 0,
                u2.Cw - 1);
    }
    private static <I> I p(int K,
                                         I[] u2, l<I> Gq,
                                         J Zy, int N9,
                                         int E) {
        if (N9 == E) {
            return u2[N9];
        }
        int o = Zy.nextInt(E + 1 - N9) + N9;
        I M;
        M = u2[N9];
        u2[N9] = u2[o];
        u2[o] = M;
        int V = N9 + 1;
        int C = E;
        while (C > V) {
            while (V < E && C > V && Gq.B(u2[V],
                    u2[N9]) < 0) {
                ++V;
            }
            while (C >= N9 && C > V && Gq.B(u2[C],
                    u2[N9]) > 0) {
                --C;
            }
            if (C > V) {
                M = u2[V];
                u2[V] = u2[C];
                u2[C] = M;
            }
        }
        if (E - N9 == 1) {
            if (Gq.B(u2[C], u2[N9]) < 0) {
                M = u2[N9];
                u2[N9] = u2[E];
                u2[E] = M;
                --C;
            }
        } else if (V == E) {
            M = u2[N9];
            u2[N9] = u2[E];
            u2[E] = M;
        } else {
            M = u2[N9];
            u2[N9] = u2[--C];
            u2[C] = M;
        }
        if (C == K - 1) {
            return u2[C];
        } else if (C < K - 1) {
            return p(K, u2, Gq, Zy, C + 1, E);
        } else {
            return p(K, u2, Gq, Zy, N9, C - 1);
        }
    }
    @XE("unchecked")
    public static <I> void hP(I[] u2, l<I> Gq) {
        if (u2 == null) {
            throw new Y("Input array can not be null.");
        }
        if (Gq == null) {
            throw new Y("Input Gq can not "
                    + "be null.");
        }
        if (u2.Cw <= 1) {
            return;
        }
        if (u2.Cw > 1) {
            if (u2.Cw == 2) {
                I M;
                if (Gq.B(u2[0], u2[1]) > 0) {
                    M = u2[0];
                    u2[0] = u2[1];
                    u2[1] = M;
                }
            } else {
                int O = u2.Cw / 2;
                if (u2.Cw % 2 == 1) {
                    ++O;
                }
                I[] R = (I[]) new F[u2.Cw / 2];
                I[] H = (I[]) new F[O];
                for (int V = 0; V < u2.Cw / 2; V++) {
                    R[V] = u2[V];
                }
                for (int V = 0; V < O; V++) {
                    H[V] = u2[V + (u2.Cw / 2)];
                }
                hP(R, Gq);
                hP(H, Gq);
                int w = 0;
                int Km = 0;
                int m = 0;
                while (w < u2.Cw) {
                    if (Km >= R.Cw) {
                        u2[w++] = H[m++];
                    } else if (m >= H.Cw) {
                        u2[w++] = R[Km++];
                    } else if (Gq.B(R[Km],
                           H[m]) > 0) {
                        u2[w++] = H[m++];
                    } else {
                        u2[w++] = R[Km++];
                    }
                }
            }
        } else {
            return;
        }
    }
    public static int[] P(int[] u2) {
        if (u2 == null) {
            throw new Y("Input array can not be null");
        }
        if (u2.Cw <= 1) {
            return u2;
        }
        int pq = x.Ew(u2[0]);
        for (int V = 1; V < u2.Cw; ++V) {
            if (u2[V] == U.a) {
                pq = U.JQ;
                V = u2.Cw;
            } else if (x.Ew(u2[V]) > pq) {
                pq = x.Ew(u2[V]);
            }
        }
        int k = 1;
        int Po = 10;
        while (pq / Po != 0) {
            Po *= 10;
            ++k;
        }
        hB<S<U>> Z = new hB<>(9);
        int w;
        for (int V = 0; V < k; ++V) {
            for (int C = 0; C < 19; ++C) {
                Z.g(new i<>());
            }
            for (int C = 0; C < u2.Cw; ++C) {
                w = (x.Ew(u2[C]) / N(10, V)) % 10;
                if (u2[C] == U.a) {
                    Z.u(0).g(u2[C]);
                } else if (u2[C] < 0) {
                    Z.u(9 - w).g(u2[C]);
                } else {
                    Z.u(9 + w).g(u2[C]);
                }
            }
            int K8 = 0;
            for (int C = 0; C < Z.XV(); ++C) {
                if (Z.u(C) != null) {
                    while (!Z.u(C).b()) {
                        u2[K8++] = Z.u(C).A();
                    }
                }
            }
            Z.D();
        }
        return u2;
    }
    private static int N(int n, int F2) {
        if (F2 < 0) {
            throw new Y("Exponent cannot be negative.");
        } else if (n == 0 && F2 == 0) {
            throw new Y(
                    "Both n and exponent cannot be 0.");
        } else if (F2 == 0) {
            return 1;
        } else if (F2 == 1) {
            return n;
        }
        int PV = N(n, F2 / 2);
        if (F2 % 2 == 0) {
            return PV * PV;
        } else {
            return PV * PV * n;
        }
    }
}