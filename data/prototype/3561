package s.zf;
import s.W;
public class M implements r
{
	private long B = 5;
	@g
	public void f(W zO) 
	{
		for(int z = 1; z < zO.x(); z <<= 1)
			for(int j = 0, C = z+z, Y = zO.x()-z; j<Y; j+=C)
				Mz(zO, j, z);
	}
	private int[] l(W zO, int gC, int G)
	{
		int I = G - gC;
		int q[] = new int[I];
		for (int dg = 0; dg < I; dg++) 
			q[dg] = zO.D(gC + dg);		
		return q;
	}
	private void Mz(W q, int gC, int z)
	{
		int Y = gC;
		int K = gC + z;
		int G = (q.x() < K+z) ? q.x() : K + z;				
		int[] F = l(q, Y, K);
		int[] ak = l(q, K, G);
		int dg = 0, C = 0;
		while(dg < F.nf && C < ak.nf)
			if(F[dg] <= ak[C])
				q.RT(gC++, F[dg++], A(), true);
			else
				q.RT(gC++, ak[C++], A(), true);
		while (dg < F.nf)
			q.RT(gC++, F[dg++], A(), true);
		while (C < F.nf)
			q.RT(gC++, ak[C++], A(), true);		
	}	
	@g
	public String a() {
		return "Iterative Merge Sort";
	}
	@g
	public long A() {
		return B;
	}
	@g
	public void d(long w) {
		this.B = w;
	}
}