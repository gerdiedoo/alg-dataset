def m(jD, T, RV, Kh):
    U = jD[T:RV + 1]
    MU = jD[RV + 1:Kh + 1]
    i = 0
    vJ = 0
    I = T
    while i < len(U) and vJ < len(MU):
        if U[i] < MU[vJ]:
            jD[I] = U[i]
            i += 1
        else:
            jD[I] = MU[vJ]
            vJ += 1
        I += 1
    while i < len(U):
        jD[I] = U[i]
        i += 1
        I += 1
    while vJ < len(MU):
        jD[I] = MU[vJ]
        vJ += 1
        I += 1
def G(jD, T, Kh):
    if T < Kh:
        RV = T + (Kh - T) // 2
        G(jD, T, RV)
        G(jD, RV + 1, Kh)
        m(jD, T, RV, Kh)
def r(jD):
    G(jD, 0, len(jD) - 1)
    return jD
assert r([3, 4, 5, 2, 1]) == [1, 2, 3, 4, 5]
assert r([3, 4, 5, 2, 1, 6]) == [1, 2, 3, 4, 5, 6]
assert r([]) == []
assert r([1]) == [1]
assert r([2, 1]) == [1, 2]