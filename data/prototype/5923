import L.k.yj;
import L.k.n;
import L.k.T;
import L.k.u;
import L.k.J;
public class e {
    public static <h> void F(h[] U, n<h> Wx) {
        if (U == null) {
            throw new f("Input array can not be null.");
        }
        if (Wx == null) {
            throw new f("Input Wx can not "
                    + "be null.");
        }
        int y;
        h c;
        for (int w = 1; w < U.S; w++) {
            y = w;
            while (y > 0
                    && Wx.cx(U[y - 1],
                    U[y]) > 0) {
                c = U[y - 1];
                U[y - 1] = U[y];
                U[y] = c;
                --y;
            }
        }
    }
    public static <h> h K(int p1, h[] U, n<h> Wx,
                                     J P) {
        if (U == null) {
            throw new f("Input array can not be null.");
        }
        if (Wx == null) {
            throw new f("n can not be null.");
        }
        if (P == null) {
            throw new f("J can not be null.");
        }
        if (p1 < 1 || p1 > U.S) {
            throw new f("K is out of the array range.");
        }
        return V(p1, U, Wx, P, 0,
                U.S - 1);
    }
    private static <h> h V(int p1,
                                         h[] U, n<h> Wx,
                                         J P, int E,
                                         int p) {
        if (E == p) {
            return U[E];
        }
        int s = P.nextInt(p + 1 - E) + E;
        h c;
        c = U[E];
        U[E] = U[s];
        U[s] = c;
        int w = E + 1;
        int Ik = p;
        while (Ik > w) {
            while (w < p && Ik > w && Wx.cx(U[w],
                    U[E]) < 0) {
                ++w;
            }
            while (Ik >= E && Ik > w && Wx.cx(U[Ik],
                    U[E]) > 0) {
                --Ik;
            }
            if (Ik > w) {
                c = U[w];
                U[w] = U[Ik];
                U[Ik] = c;
            }
        }
        if (p - E == 1) {
            if (Wx.cx(U[Ik], U[E]) < 0) {
                c = U[E];
                U[E] = U[p];
                U[p] = c;
                --Ik;
            }
        } else if (w == p) {
            c = U[E];
            U[E] = U[p];
            U[p] = c;
        } else {
            c = U[E];
            U[E] = U[--Ik];
            U[Ik] = c;
        }
        if (Ik == p1 - 1) {
            return U[Ik];
        } else if (Ik < p1 - 1) {
            return V(p1, U, Wx, P, Ik + 1, p);
        } else {
            return V(p1, U, Wx, P, E, Ik - 1);
        }
    }
    @Hv("unchecked")
    public static <h> void z(h[] U, n<h> Wx) {
        if (U == null) {
            throw new f("Input array can not be null.");
        }
        if (Wx == null) {
            throw new f("Input Wx can not "
                    + "be null.");
        }
        if (U.S <= 1) {
            return;
        }
        if (U.S > 1) {
            if (U.S == 2) {
                h c;
                if (Wx.cx(U[0], U[1]) > 0) {
                    c = U[0];
                    U[0] = U[1];
                    U[1] = c;
                }
            } else {
                int X = U.S / 2;
                if (U.S % 2 == 1) {
                    ++X;
                }
                h[] a = (h[]) new d[U.S / 2];
                h[] pu = (h[]) new d[X];
                for (int w = 0; w < U.S / 2; w++) {
                    a[w] = U[w];
                }
                for (int w = 0; w < X; w++) {
                    pu[w] = U[w + (U.S / 2)];
                }
                z(a, Wx);
                z(pu, Wx);
                int A = 0;
                int fy = 0;
                int EM = 0;
                while (A < U.S) {
                    if (fy >= a.S) {
                        U[A++] = pu[EM++];
                    } else if (EM >= pu.S) {
                        U[A++] = a[fy++];
                    } else if (Wx.cx(a[fy],
                           pu[EM]) > 0) {
                        U[A++] = pu[EM++];
                    } else {
                        U[A++] = a[fy++];
                    }
                }
            }
        } else {
            return;
        }
    }
    public static int[] b(int[] U) {
        if (U == null) {
            throw new f("Input array can not be null");
        }
        if (U.S <= 1) {
            return U;
        }
        int Bk = p8.Xv(U[0]);
        for (int w = 1; w < U.S; ++w) {
            if (U[w] == o.R) {
                Bk = o.Y;
                w = U.S;
            } else if (p8.Xv(U[w]) > Bk) {
                Bk = p8.Xv(U[w]);
            }
        }
        int V4 = 1;
        int JR = 10;
        while (Bk / JR != 0) {
            JR *= 10;
            ++V4;
        }
        yj<u<o>> m = new yj<>(9);
        int A;
        for (int w = 0; w < V4; ++w) {
            for (int Ik = 0; Ik < 19; ++Ik) {
                m.G(new T<>());
            }
            for (int Ik = 0; Ik < U.S; ++Ik) {
                A = (p8.Xv(U[Ik]) / iS(10, w)) % 10;
                if (U[Ik] == o.R) {
                    m.N(0).G(U[Ik]);
                } else if (U[Ik] < 0) {
                    m.N(9 - A).G(U[Ik]);
                } else {
                    m.N(9 + A).G(U[Ik]);
                }
            }
            int D = 0;
            for (int Ik = 0; Ik < m.I(); ++Ik) {
                if (m.N(Ik) != null) {
                    while (!m.N(Ik).Vz()) {
                        U[D++] = m.N(Ik).t6();
                    }
                }
            }
            m.v();
        }
        return U;
    }
    private static int iS(int dy, int l) {
        if (l < 0) {
            throw new f("Exponent cannot be negative.");
        } else if (dy == 0 && l == 0) {
            throw new f(
                    "Both dy and exponent cannot be 0.");
        } else if (l == 0) {
            return 1;
        } else if (l == 1) {
            return dy;
        }
        int q = iS(dy, l / 2);
        if (l % 2 == 0) {
            return q * q;
        } else {
            return q * q * dy;
        }
    }
}