package P.H0;
import K.nj.Sg;
public class l {
	private l() {
	}
	public static void p(E[] yq) {
		if(yq == null)
			throw new d();
		E[] L = new E[yq.u];
		p(yq, L, 0, yq.u - 1);
	}
	public static void p(z[] yq, Sg P) {
		if(yq == null)
			throw new d();
		E[] L = new E[yq.u];
		p(yq, L, P, 0, yq.u - 1);
	}
	private static void p(E[] Iz, E[] L, int Y, int h) {
		if (h <= Y)
			return;
		int i = Y + (h - Y) / 2;
		p(Iz, L, Y, i);
		p(Iz, L, i + 1, h);
		Q(Iz, L, Y, i, h);
	}
	private static void p(z[] Iz, z[] L, Sg P, int Y,
			int h) {
		if (h <= Y)
			return;
		int i = Y + (h - Y) / 2;
		p(Iz, L, P, Y, i);
		p(Iz, L, P, i + 1, h);
		Q(Iz, L, P, Y, i, h);
	}
	private static void Q(E[] Iz, E[] L, int Y,
			int i, int h) {
		for (int B = Y; B <= h; B++) {
			L[B] = Iz[B];
		}
		int O = Y, e = i + 1;
		for (int B = Y; B <= h; B++) {
			if (O > i)
				Iz[B] = L[e++];
			else if (e > h)
				Iz[B] = L[O++];
			else if (a(L[e], L[O]))
				Iz[B] = L[e++];
			else
				Iz[B] = L[O++];
		}
	}
	private static void Q(z[] Iz, z[] L, Sg P, int Y,
			int i, int h) {
		for (int B = Y; B <= h; B++) {
			L[B] = Iz[B];
		}
		int O = Y, e = i + 1;
		for (int B = Y; B <= h; B++) {
			if (O > i)
				Iz[B] = L[e++];
			else if (e > h)
				Iz[B] = L[O++];
			else if (a(P, L[e], L[O]))
				Iz[B] = L[e++];
			else
				Iz[B] = L[O++];
		}
	}
	private static boolean a(E v, E hp) {
		return v.SS(hp) < 0;
	}
	private static boolean a(Sg xH, z v, z hp) {
		return xH.f(v, hp) < 0;
	}
	private static void G(z[] Iz, int O, int e) {
		z s = Iz[O];
		Iz[O] = Iz[e];
		Iz[e] = s;
	}
	public static void V9(E[] yq) {
		int y = yq.u;
		for (int O = 0; O < y; O++) {
			System.out.t(yq[O] + ",");
		}
	}
}