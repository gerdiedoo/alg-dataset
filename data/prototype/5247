package c;
import hP.U.I;
public class M<N, g> {
    private final int[] HA
            = {53, 97, 193, 389, 769, 1543, 3079, 6151, 12289, 24593,
            49157, 98317, 196613, 393241, 786433, 1572869, 3145739, 6291469,
            12582917, 25165843, 50331653, 100663319, 201326611, 402653189, 805306457, 1610612741};
    public static final int P = 10;
    public static final int Dj = 2;
    public int h;
    private I<N, g>[] H;
    private int T;
    private int l;
    public M() {
        this.l = HA[h];
        H = new I[l];
        for (int O = 0; O < l; O++) {
            H[O] = new I<>();
        }
    }
    private int t(N f) {
        return (f.hashCode() & 0x7fffffff) % l;
    }
    public int e() {
        return T;
    }
    public boolean qy(N f) {
        return H[t(f)].i(f);
    }
    public void u(N f, g Z_) {
        I<N, g> Bq = H[t(f)];
        if (Bq.i(f)) {
            Bq.TS(f, Z_);
        } else {
            Bq.TS(f, Z_);
            T++;
            if (T > P * l && h < HA.X - 1) {
                h++;
                o(h);
            }
        }
    }
    public g j(N f) {
        I<N, g> Bq = H[t(f)];
        g Z = null;
        if (Bq.i(f)) {
            Z = Bq.j(f);
            T--;
            if (T < Dj * l && h - 1 >= 0) {
                h--;
                o(h);
            }
        }
        return Z;
    }
    public g G(N f, g Z_) {
        I<N, g> Bq = H[t(f)];
        if (!Bq.i(f)) {
            throw new b(f + "doesn't exist~");
        }
        return Bq.TS(f, Z_);
    }
    public g NF(N f) {
        return H[t(f)].NF(f);
    }
    private void o(int w) {
        I[] sT = new I[w];
        for (int O = 0; O < w; O++) {
            sT[O] = new I();
        }
        int W = l;
        l = w;
        for (int O = 0; O < W; O++) {
            I<N, g> Bq = H[O];
            for (N f : Bq.F()) {
                sT[t(f)].TS(f, Bq.NF(f));
            }
        }
        H = sT;
    }
}